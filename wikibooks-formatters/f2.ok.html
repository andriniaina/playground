<html>
	<head>
		<meta name="generator" content="HTML Tidy for Windows (vers 25 March 2009), see www.w3.org">
		<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
		<meta name="Generator" content="Microsoft Word 15 (filtered)">
		<title>
			F# programming
		</title>
		<style>
			.Preformatted
			{
				background-color: #e6e6e6;
			}
		</style>
		
	</head>
	<body lang="FR" link="#0563C1" vlink="#954F72">
		<div class="WordSection1">
			<h1 class="HeadingArticle">
				F Sharp Programming
			</h1>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Contents
			</h2>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Preface"><span style='color:windowtext;text-decoration:none'>Preface</span></a></span></span> <span lang="EN-US">- About this book and its authors.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 2.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Introduction"><span style='color:windowtext;text-decoration:none'>Introduction</span></a></span></span> <span lang="EN-US">- Introducing the F# Programming Language.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				F# Basics
			</h3>
			<p class="TextBody">
				<em><span lang="EN-US">This section is suitable for complete beginners to F# and Functional Programming in general.</span></em>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Getting_Set_Up"><span style='color:windowtext;text-decoration:none'>Getting Set Up</span></a></span></span> <span lang="EN-US">- Installing F# on Windows, Linux and Mac.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 2.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Basic_Concepts"><span style='color:windowtext;text-decoration:none'>Basic Concepts</span></a></span></span> <span lang="EN-US">- A lightweight crash course in functional programming concepts.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h4 class="Heading3">
				Working With Functions
			</h4>
			<p class="TextBody">
				<em><span lang="EN-US">F# is a functional programming language. Not surprisingly, functions are a big part of the language, and mastering them is the first step to becoming an effective F# developer.</span></em>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Values_and_Functions"><span style='color:windowtext;text-decoration:none'>Declaring Values and Functions</span></a></span></span> <span lang="EN-US">- This article will show you how to declare simple functions, how to use type inference, and how to read F#'s 'arrow' notation.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 2.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Pattern_Matching_Basics"><span style='color:windowtext;text-decoration:none'>Pattern Matching Basics</span></a></span></span> <span lang="EN-US">- Pattern matching is used for control flow. Its conceptually similar to a switch statement in other languages, but orders of magnitude more powerful.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 3.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Recursion"><span style='color:windowtext;text-decoration:none'>Recursion and Recursive Functions</span></a></span></span> <span lang="EN-US">- A recursive function is a special type of function which calls itself.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 4.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Higher_Order_Functions"><span style='color:windowtext;text-decoration:none'>Higher Order Functions</span></a></span></span> <span lang="EN-US">- Higher order functions take and return functions as values. Combined with currying, it allows programmers to write powerful and expressive programs.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h4 class="Heading3">
				Immutable Data Structures
			</h4>
			<p class="TextBody">
				<em><span lang="EN-US">"Data structure" is a fancy word which refers to anything that helps programmers group and represent related values in useful, logical units. F# has a number of built-in data structures which include tuples, records, lists, unions, and a number of others.</span></em>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Option_Types"><span style='color:windowtext;text-decoration:none'>Option Types</span></a></span></span> <span lang="EN-US">- Option types are simple, lightweight data structures which are commonly used to represent successful or failed computation.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 2.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Tuples_and_Records"><span style='color:windowtext;text-decoration:none'>Tuples and Records</span></a></span></span> <span lang="EN-US">- Tuples and records are simple data structures which allow programmers to group related values together into a single unit.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 3.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Lists"><span style='color:windowtext;text-decoration:none'>Lists</span></a></span></span> <span lang="EN-US">- A list represents an ordered group of values. F#'s List library has extensive support for manipulating and working with lists.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 4.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Sequences"><span style='color:windowtext;text-decoration:none'>Sequences</span></a></span></span> <span lang="EN-US">- Sequence expressions represent sequences of data computed on-demand.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 5.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Sets_and_Maps"><span style='color:windowtext;text-decoration:none'>Sets and Maps</span></a></span></span> <span lang="EN-US">- Sets are conceptually similar to lists, except they cannot hold duplicate items. Maps allows programmers to relate <em>keys</em> to <em>values</em> and find items in the collection very efficiently.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 6.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Discriminated_Unions"><span style='color:windowtext;text-decoration:none'>Discriminated Unions</span></a></span></span> <span lang="EN-US">- Discriminated unions represent a finite, well-defined set of choices. Discriminated unions are often the tool of choice building up more complicated data structures including linked lists and a wide range of trees.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h4 class="Heading3">
				<span lang="EN-US">Imperative Programming</span>
			</h4>
			<p class="TextBody">
				<em><span lang="EN-US">F# is an "impure" programming language, meaning it allows programmers to write functions with side-effects and mutable state, very similar to the programming style used by imperative programming languages such as C# and Java.</span></em>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Mutable_Data"><span style='color:windowtext;text-decoration:none'>Mutable Data</span></a></span></span> <span lang="EN-US">- By default, variables in F# are immutable. However, F# supports mutable variables through mutable fields and ref cells.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 2.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Control_Flow"><span style='color:windowtext;text-decoration:none'>Control Flow</span></a></span></span> <span lang="EN-US">- Decision making and Loops.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 3.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Arrays"><span style='color:windowtext;text-decoration:none'>Arrays</span></a></span></span> <span lang="EN-US">- Arrays are ubiquitous mutable data structure used in imperative programming languages.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 4.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Mutable_Collections"><span style='color:windowtext;text-decoration:none'>Mutable Collections</span></a></span></span> <span lang="EN-US">- Lists and Dictionaries.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 5.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Input_and_Output"><span style='color:windowtext;text-decoration:none'>Basic I/O</span></a></span></span> <span lang="EN-US">- Reading and writing to files and the console window.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 6.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Exception_Handling"><span style='color:windowtext;text-decoration:none'>Exception Handling</span></a></span></span> <span lang="EN-US">- Exception handling allows programmers to catch and handle errors whenever an application enters an invalid state.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h4 class="Heading3">
				Object Oriented Programming
			</h4>
			<p class="TextBody">
				<em><span lang="EN-US">F# is a CLI/.NET programming language. CLI is an object-oriented platform. One of the most important features of F# is its ability to mix and match styles: since the .NET platform is Object Oriented, with F#, you often work with objects.</span></em>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Operator_Overloading"><span style='color:windowtext;text-decoration:none'>Operator Overloading</span></a></span></span> <span lang="EN-US">- C#-like operator overloading.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 2.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Classes"><span style='color:windowtext;text-decoration:none'>Classes</span></a></span></span> <span lang="EN-US">- classes and objects are the foundation of object-oriented programming (OOP). They are used to model actions, processes, and any conceptual entities in applications.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 3.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Inheritance"><span style='color:windowtext;text-decoration:none'>Inheritance</span></a></span></span> <span lang="EN-US">- inheritance makes OOP code reusable. It allows programmers to create classes which inherit features from another class and add its own modifications.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 4.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Interfaces"><span style='color:windowtext;text-decoration:none'>Interfaces</span></a></span></span> <span lang="EN-US">- interfaces abstract away the implementation details of a class by defining a template of methods an object must implement and expose publicly.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 5.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Events"><span style='color:windowtext;text-decoration:none'>Events</span></a></span></span> <span lang="EN-US">- events allow a classes to send and receive messages between one another.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 6.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Modules_and_Namespaces"><span style='color:windowtext;text-decoration:none'>Modules and Namespaces</span></a></span></span> <span lang="EN-US">- modules and namespaces are used to organize classes into groups of related functionality.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">F# Advanced</span>
			</h3>
			<p class="TextBody">
				<em><span lang="EN-US">F# is easy enough for beginners to learn as their first language, yet it provides a powerful set of tools which can be appreciated by experienced developers. This section describes advanced syntactic contructs and techniques often used in F# programs.</span></em>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Units_of_Measure"><span style='color:windowtext;text-decoration:none'>Units of Measure</span></a></span></span> <span lang="EN-US">- Units of measure attach metadata to floats, which allows floats to represent kilograms, pounds, Newtons, hectares, and so on.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 2.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Caching"><span style='color:windowtext;text-decoration:none'>Caching</span></a></span></span> <span lang="EN-US">- Techniques to store computed values for efficient future retrieval. Also called Memoization.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 3.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Active_Patterns"><span style='color:windowtext;text-decoration:none'>Active Patterns</span></a></span></span> <span lang="EN-US">- Active patterns allow programmers to wrap ad hoc values and objects in union-like structures for use in pattern matching.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 4.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Advanced_Data_Structures"><span style='color:windowtext;text-decoration:none'>Advanced Data Structures</span></a></span></span> <span lang="EN-US">- Overview of techniques used to implement immutable data structures.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 5.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Reflection"><span style='color:windowtext;text-decoration:none'>Reflection</span></a></span></span> <span lang="EN-US">- Reflection allows programmers to inspect types and metadata in objects.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 6.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Quotations"><span style='color:windowtext;text-decoration:none'>Quotations</span></a></span></span> <span lang="EN-US">- Quotations convert arbitrary F# code into an abstract syntax tree.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 7.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Computation_Expressions"><span style='color:windowtext;text-decoration:none'>Computation Expressions</span></a></span></span> <span lang="EN-US">- Similar to monads in Haskell, computation expressions are used to simplify code written continuation-passing style.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h4 class="Heading3">
				Multi-threaded and Concurrent Applications
			</h4>
			<p class="TextBody">
				<em><span lang="EN-US">Multi-threading is becoming increasingly important with the development of multi-core processors. Functional programmers can take advantage of immutable data structures to make massively scalable, concurrent applications that are simple and easy to write.</span></em>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Async_Workflows"><span style='color:windowtext;text-decoration:none'>Async Workflows</span></a></span></span> <span lang="EN-US">- F#'s async primitive is fundamental for writing functional, simple multi-threaded code.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 2.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/MailboxProcessor"><span style='color:windowtext;text-decoration:none'>MailboxProcessor Class</span></a></span></span> <span lang="EN-US">- Mailboxes are used to implement "message-passing concurrency," a style of concurrent programming used in massively parallel applications consisting 10s of 1000s of independent nodes.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h4 class="Heading3">
				F# Tools
			</h4>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Lexing_and_Parsing"><span style='color:windowtext;text-decoration:none'>Lexing and Parsing</span></a></span></span> <span lang="EN-US">- FsLex and FsYacc, lexer/parser generators based on the GNU Bison family of generators, are used to implement custom grammars and domain-specific languages in F#.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Authors</span>
			</h2>
			<p class="TextBody">
				<em><span lang="EN-US">If you have contributed to this book, please add your name to this list.</span></em>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=User:Awesome_Princess"><span style='color:windowtext;text-decoration:none'>Awesome Princess</span></a></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Notes
			</h2>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Notes_for_Contributors"><span style='color:windowtext;text-decoration:none'>Notes for Contributors</span></a>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Acknowledgments"><span style='color:windowtext;text-decoration:none'>Acknowledgments</span></a>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Exercise_Solutions"><span style='color:windowtext;text-decoration:none'>Exercise Solutions</span></a>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/License"><span style='color:windowtext;text-decoration:none'>License</span></a>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Resources
			</h2>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://msdn.microsoft.com/en-us/library/dd233181.aspx"><span style='color:windowtext;text-decoration:none'>F# Language Reference on MSDN Library</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/"><span style='color:windowtext;text-decoration:none'>F# Homepage on Microsoft Research</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://fsharp.net/"><span style='color:windowtext;text-decoration:none'>Microsoft F# Developer Center</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://tomasp.net/blog/real-world-book-msdn.aspx"><span style='color: windowtext;text-decoration:none'>Real-World F# Articles on MSDN</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec.html"><span style='color:windowtext;text-decoration:none'>Language Specification</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec.pdf"><span style='color:windowtext;text-decoration:none'>Language Specification PDF</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://fsharp.github.com/fsharp-component-design-guidelines.htm"><span style='color:windowtext;text-decoration:none'>F# Component Design Guidelines</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/fsharp-component-design-guidelines.pdf"><span style='color:windowtext;text-decoration:none'>F# Component Design Guidelines PDF</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://cs.hubfs.net/"><span style='color:windowtext;text-decoration:none'>hubFS F# Community</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://fpish.net/"><span style='color:windowtext;text-decoration:none'>fpish community-driven events and learning material</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://c4fsharp.net/"><span style='color:windowtext;text-decoration:none'>Community for F# monthly, virtual user group</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://fssnip.net/"><span style='color:windowtext;text-decoration:none'>F# Snippets</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://tryfsharp.org/"><span style='color:windowtext;text-decoration:none'>Try F# online</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://functional-teaching.net/"><span style='color:windowtext;text-decoration:none'>Using the F# Language for Teaching</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://functional-variations.net/"><span style='color:windowtext;text-decoration:none'>Cross-platform and other F# extensions</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://github.com/fsharp"><span style='color:windowtext;text-decoration:none'>F# source code and community projects on GitHub</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://fsxplat.codeplex.com/"><span style='color:windowtext;text-decoration:none'>F# cross-platform packages and samples</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://web.archive.org/web/20110715231625/http:/www.ctocorner.com/fsharp/book/default.aspx"><span style='color:windowtext;text-decoration:none'>The F# Survival Guide</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://fsharpforfunandprofit.com/"><span style='color:windowtext;text-decoration:none'>F# for fun and profit</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://www.strangelights.com/fsharp/wiki/"><span style='color:windowtext; text-decoration:none'>F-Sharp Wiki</span></a> <span class="Bold">(No longer available)</span></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=Objective_Caml"><span style='color:windowtext;text-decoration:none'>Objective Caml</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://sharp-gamedev.blogspot.com/"><span style='color:windowtext;text-decoration:none'>F# for game development</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://fsharpgamedev.codeplex.com/"><span style='color:windowtext;text-decoration:none'>Learning F# Through Game Development with XNA</span></a></span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h1 class="HeadingArticle">
				Preface
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Preface</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				How This Book Came To Be
			</h2>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Note to contributors: normally a preface is written by the author of a book. Since this book might have several authors, feel free to write your own preface.
			</p>
			<p class="TextBody">
				<em><span lang="EN-US">Written by <a href="http://en.wikibooks.org/w/index.php?title=User:Awesome_Princess"><span style='color:windowtext;text-decoration:none'>Awesome Princess</span></a></span></em><span lang="EN-US">: Normally, authors choose to write a preface to a book about the book itself. But, just because I'm an egomaniac, I want to write about myself instead. Not because I'm an especially interesting person, but because my experiences with functional programming are relevant to the creation of this book.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">So, in 2006, I was becoming bored with my job. The only kind of software I've ever written has been software that puts a GUI interface on top of a database, and I just became tired with it. I wanted to find an interesting programming job.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Just for fun, I started looking at job openings at different high tech companies (Google, eBay, Microsoft, Amazon, etc.). I noticed that all of the boring jobs -- CRUD apps, simple web development -- wanted programmers with Java, C#, or C++ experience. The interesting jobs -- compiler programming, digital circuit verification, massively parallel computing, biometrics -- sought programmers with experience in weird and unfamiliar languages. In particular:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">I read in Paul Graham's article <a href="http://www.paulgraham.com/avg.html"><span style='color:windowtext; text-decoration:none'>Beating the Averages</span></a> that the first version of Yahoo! Store was written largely in Lisp</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">I came across job postings for Google looking for programmers with Haskell or Python experience in addition to C++.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">I read in an <a href="http://www.erlang.org/faq/faq.html"><span style='color:windowtext; text-decoration:none'>Erlang FAQ</span></a> that the Erlang programming language is the tool of choice for telecommunications providers like T-Mobile.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">I've heard for years that Lisp was a niche language during the Golden Age of AI research.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">I ran across numerous Microsoft job postings in the area of driver verification looking for OCaml programmers.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The most remarkable applications in the world aren't written in Java; they're written in these weird, obscure languages. More interestingly, the languages in the highest demand -- Erlang, Haskell, Lisp, OCaml -- were all functional programming languages, a wholly alien programming paradigm from my vantage point deep in C#-Land. I decided to supplement my programming wisdom by learning one of these obscure functional programming languages.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The choice between one language or another wasn't too hard to make. If I'm going to learn a new language, it needs to satisfy a few conditions: it should be practical enough for personal use, relatively speedy, useful to employers, and impress my friends when I tell them I learned a weird new language. Haskell was quite scary to me at the time, and I can't really exploit Erlang's concurrency with the tiny scope of the apps I write for myself. The choice came down to Lisp and OCaml; based on <a href="http://www.cs.ubc.ca/~murphyk/Software/which_language.html"><span style='color:windowtext;text-decoration:none'>these comparisons of different languages</span></a>, I decided that OCaml's static-typing, speedy native code, tiny compiled binaries, and established niche in the financial market made it a good choice for me.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">I learned OCaml and it completely changed my way of thinking. After using the language and keeping up with OCaml newsgroups, I heard about a .NET port of OCaml called F#. I figured I already knew the .NET BCL inside and out, and I was already familiar with OCaml, I could probably learn this language pretty quickly.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In August 2007, I took the time to get familiar with the F# language. While I picked up most of it fairly well, one thing I noticed about the language was how completely inaccessible it was to people trying to learn the language. The complete dearth of F# material out there just makes it impossible for beginners to learn F# as their first language. Even today, November 2008, there are only a handful of publications, but even as a person with many years of programming experience, I struggled to follow along and comprehend the language.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">For a long time, I wanted to write something that would actually be useful to F# neophytes, something that would contain everything anyone needs to know about the language into a single comprehensive resource. This book was originally started by a fellow Wikibookian in 2006, but no one had written any substantial content for it for nearly 2 years. I found this book and decided that, for the sake of people wanting to learn F#, I'd compile everything I knew about the language into a format that would be acceptable for first-time programmers.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">I am happy with the way the book has been progressing. Ultimately, I'd like people to link to this book as the preferred, definitive F# tutorial on Internet.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h1 class="HeadingArticle">
				Introduction
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Introduction</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Introducing F#
			</h2>
			<p class="TextBody">
				<span lang="EN-US">The <span class="Bold">F#</span> programming language is part of Microsoft's family of .NET languages, which includes C#, Visual Basic.NET, JScript.NET, and others. As a .NET language, F# code compiles down to Common Language Infrastructure (CLI) byte code or Microsoft Intermediate Language (MSIL) which runs on top of the Common Language Runtime (CLR). All .NET languages share this common intermediate state which allows them to easily interoperate with one another and use the .NET Framework's Base Class Library (BCL).</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In many ways, it's easy to think of F# as a .NET implementation of <a href="http://en.wikibooks.org/w/index.php?title=Objective_Caml"><span style='color:windowtext;text-decoration:none'>OCaml</span></a>, a well-known functional programming language from the ML family of <a href="http://en.wikibooks.org/w/index.php?title=Computer_programming/Functional_programming"><span style='color:windowtext;text-decoration:none'>functional programming languages</span></a>. Some of F#'s notable features include type inference, pattern matching, interactive scripting and debugging, higher order functions, and a well-developed object model which allows programmers to mix object-oriented and functional programming styles seamlessly.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				A Brief History of F#
			</h2>
			<p class="TextBody">
				<span lang="EN-US">There are three dominant programming paradigms used today: functional, imperative, and object-oriented programming. Functional programming is the oldest of the three, beginning with Information Processing Language in 1956 and made popular with the appearance of Lisp in 1958. Of course, in the highly competitive world of programming languages in the early decades of computing, imperative programming established itself as the industry norm and preferred choice of scientific researchers and businesses with the arrival of Fortran in 1957 and COBOL in 1959.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">While imperative languages became popular with businesses, functional programming languages continued to be developed primarily as highly specialized niche languages. For example, the APL programming language, developed in 1962, was developed to provide a consistent, mathematical notation for processing arrays. In 1973, Robin Milner at the University of Edinburgh developed the ML programming language to develop proof tactics for the LCF Theorem prover. Lisp continued to be used for years as the favored language of AI researchers.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">ML stands out among other functional programming languages; its polymorphic functions made it a very expressive language, while its strong typing and immutable data structures made it possible to compile ML into very efficient machine code. ML's relative success spawned an entire family of ML-derived languages, including Standard ML, Caml, and its most famous dialect called OCaml which unifies functional programming with object-oriented and imperative styles.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">F# was developed in 2005 at Microsoft Research<a href="http://research.microsoft.com"><span style='color:windowtext; text-decoration:none'>[0]</span></a>. In many ways, F# is essentially a .Net implementation of OCaml, combining the power and expressive syntax of functional programming with the tens of thousands of classes which make up the .NET class library.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Why Learn F#?
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Functional programming is often regarded as the best-kept secret of scientific modelers, mathematicians, artificial intelligence researchers, financial institutions, graphic designers, CPU designers, compiler programmers, and telecommunications engineers. Understandably, functional programming languages tend to be used in settings that perform heavy number crunching, abstract symbolic processing, or theorem proving. Of course, while F# is abstract enough to satisfy the needs of some highly technical niches, its simple and expressive syntax makes it suitable for CRUD apps, web pages, GUIs, games, and general-purpose programming.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Programming languages are becoming more functional every year. Features such as generic programming, type inference, list comprehensions, functions as values, and anonymous types, which have traditionally existed as staples of functional programming, have quickly become mainstream features of Java, C#, Delphi and even Fortran. We can expect next-generation programming languages to continue this trend in the future, providing a hybrid of both functional and imperative approaches that meet the evolving needs of modern programming.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">F# is valuable to programmers at any skill level; it combines many of the best features of functional and object-oriented programming styles into a uniquely productive language.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h1 class="HeadingArticle">
				Getting Set Up
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Getting Set Up</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Windows
			</h2>
			<p class="TextBody">
				<span lang="EN-US">At the time of this writing, its possible to run F# code through Visual Studio, through its interactive top-level F# Interactive (fsi), and compiling from the command line. This book will assume that users will compile code through Visual Studio or F# Interactive by default, unless specifically directed to compile from the command line.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Setup Procedure
			</h3>
			<p class="TextBody">
				<span lang="EN-US">F# can integrate with existing installations of Visual Studio 2008 and is included with Visual Studio 2010. Alternatively, users can <a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=40646580-97FA-4698-B65F-620D4B4B1ED7&amp;displaylang=en"><span style='color:windowtext;text-decoration:none'>download Visual Studio Shell</span></a> for free, which will provide an F# pioneer with everything she needs to get started, including interactive debugging, breakpoints, watches, Intellisense, and support for F# projects. Make sure all instances of Visual Studio and Visual Studio Shell are closed before continuing.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">To get started, users should download and install the latest version of the .NET Framework from Microsoft. Afterwards, <a href="http://research.microsoft.com/fsharp/release.aspx"><span style='color:windowtext;text-decoration:none'>download the latest version of F#</span></a> from the F# homepage on Microsoft Research, then execute the installation wizard. Users should also consider downloading and installing the <a href="http://fsharppowerpack.codeplex.com/"><span style='color:windowtext; text-decoration:none'>F# PowerPack</span></a>, which contains handy extensions to the F# core library.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">After successful installation, users will notice an additional folder in their start menu, "Microsoft F# 2.0.X.X." Additionally, users will notice that an entry for "F# Projects" has been added to the project types menu in Visual Studio. From here, users can create and run new F# projects.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">It is a good idea to add the executable location (<em>e.g.</em></span> <span class="Teletyped"><span lang="EN-US" style=''>c:\fsharp\bin\</span></span><span lang="EN-US">) to the</span> <span class="Teletyped"><span lang="EN-US" style=''>%PATH%</span></span> <span lang="EN-US">environment variable, so you can access the compiler and the F# interactive environment (FSI) from any location.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Testing the Install</span>
			</h3>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h4 class="Heading3">
				<span lang="EN-US">Hello World executable</span>
			</h4>
			<p class="TextBody">
				<span lang="EN-US">Lets create the Hello World standalone application.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Create a text file called</span> <span class="Teletyped"><span lang="EN-US" style=''>hello.fs</span></span> <span lang="EN-US">containing the following code:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">(* filename: hello.fs *)<br>
				let _ = printf "Hello world"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Save and close the file and then compile this file:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">fsc -o hello.exe hello.fs</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Now you can run</span> <span class="Teletyped"><span lang="EN-US" style=''>hello.exe</span></span> <span lang="EN-US">to produce the expected output.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h4 class="Heading3">
				<span lang="EN-US">F# Interactive Environment</span>
			</h4>
			<p class="TextBody">
				<span lang="EN-US">Open a command-line console (hit the "Start" button, click on the "Run" icon and type</span> <span class="Teletyped"><span lang="EN-US" style=''>cmd</span></span> <span lang="EN-US">and hit ENTER).</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Type</span> <span class="Teletyped"><span lang="EN-US" style=''>fsi</span></span> <span lang="EN-US">and hit ENTER. You will see the interactive console:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Microsoft F# Interactive, (c) Microsoft Corporation, All Rights Reserved<br>
				F# Version 1.9.6.2, compiling for .NET Framework Version v2.0.50727<br>
				<br>
				Please send bug reports to fsbugs@microsoft.com<br>
				For help type #help;;<br>
				<br>
				&gt;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can try some basic F# variable assignment (and some basic maths).</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let x = 5;;<br>
				val x : int<br>
				&nbsp;<br>
				&gt; let y = 20;;<br>
				val y : int<br>
				<br>
				&gt; y + x;;<br>
				val it : int = 25</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Finally we quit out of the interactive environment</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; #quit;;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Misc.</span>
			</h3>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h4 class="Heading3">
				<span lang="EN-US">Adding to the PATH Environment Variable</span>
			</h4>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Go to the Control Panel and choose System.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 2.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">The System Properties dialog will appear. Select the Advanced tab and click the "Environment Variables...".</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 3.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">In the System Variables section, select the Path variable from the list and click the "Edit..." button.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 4.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">In the Edit System Variable text box append a semicolon (;) followed by the executable path (e.g.</span> <span class="Teletyped"><span lang="EN-US" style=''>;C:\fsharp\bin\</span></span><span lang="EN-US">)</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 5.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Click on the "OK" button</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 6.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Click on the "OK" button</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 7.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Click on the "Apply" button</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Now any command-line console will check in this location when you type</span> <span class="Teletyped"><span lang="EN-US" style=''>fsc</span></span> <span lang="EN-US">or</span> <span class="Teletyped"><span lang="EN-US" style=''>fsi</span></span><span lang="EN-US">.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Mac OSX, Linux and UNIX</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">F# runs on Mac OSX, Linux and other Unix versions with the latest <a href="http://www.mono-project.com/"><span style='color:windowtext;text-decoration:none'>Mono</span></a>. This is supported by the F# community group called the <a href="http://fsharp.org/"><span style='color:windowtext;text-decoration:none'>F# Software Foundation</span></a>.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Installing interpreter and compiler</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">The <a href="http://fsharp.org/"><span style='color:windowtext;text-decoration:none'>F# Software Foundation</span></a> give latest instructions on getting started with F# on Linux and Mac. Once built and/or installed, you can use the "fsharpi" command to use the command-line interpreter, and "fsharpc" for the command-line compiler.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">MonoDevelop add-in</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">The <a href="http://fsharp.org/"><span style='color:windowtext;text-decoration:none'>F# Software Foundation</span></a> also give instructions for installing the Monodevelop support for F#. This comes with project build system, code completion, and syntax highlighting support.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Emacs mode and other editors</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">The <a href="http://fsharp.org/"><span style='color:windowtext;text-decoration:none'>F# Software Foundation</span></a> also give instructions for using F# with other editors. An <a href="http://laurent.le-brun.eu/site/index.php/2010/06/25/58-new-fsharp-mode-for-emacs"><span style='color:windowtext;text-decoration:none'>emacs mode for F#</span></a> is also available on <a href="http://sourceforge.net/projects/fsharp-mode/"><span style='color:windowtext;text-decoration:none'>SourceForge</span></a>.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Basic Concepts
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Basic Concepts</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">Now that we have a working installation of F# we can explore the syntax of F# and the basics of functional programming. We'll start off in the Interactive F Sharp environment as this gives us some very valuable type information, which helps get to grips with what is actually going on in F#. Open F# interactive from the start menu, or open a command-line prompt and type</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>fsi</span></span><span lang="EN-US">.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Major Features</span>
			</h2>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Fundamental Data Types and Type System</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">In computer programming, every piece of data has a <em>type</em>, which, predictably, describes the type of data a programmer is working with. In F#, the fundamental data types are:</span>
			</p>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# Type</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">.NET Type</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Size</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Range</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Example</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Represents</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="576" colspan="6" valign="top" style='width:432.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Integral Types</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>sbyte</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.SByte</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">1 byte</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">-128 to 127</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>42y</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>-11y</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">8-bit signed integer</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>byte</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Byte</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">1 byte</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">0 to 255</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>42uy</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>200uy</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">8-bit unsigned integer</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>int16</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Int16</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">2 bytes</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">-32768 to 32767</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>42s</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>-11s</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">16-bit signed integer</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>uint16</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.UInt16</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">2 bytes</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">0 to 65,535</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>42us</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>200us</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">16-bit unsigned integer</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>int</span></span><span lang="EN-US">/</span><span class="Teletyped"><span lang="EN-US" style=''>int32</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Int32</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">4 bytes</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">-2,147,483,648 to 2,147,483,647</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>42</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>-11</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">32-bit signed integer</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>uint32</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.UInt32</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">4 bytes</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">0 to 4,294,967,295</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>42u</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>200u</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">32-bit unsigned integer</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>int64</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Int64</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">8 bytes</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>42L</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>-11L</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">64-bit signed integer</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>uint64</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.UInt64</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">8 bytes</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">0 to 18,446,744,073,709,551,615</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>42UL</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>200UL</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">64-bit unsigned integer</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>bigint</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Numerics.BigInteger</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">At least 4 bytes</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">any integer</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>42I</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>14999999999999999999999999999999I</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">arbitrary precision integer</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="576" colspan="6" valign="top" style='width:432.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Floating Point Types</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>float32</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Single</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">4 bytes</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&plusmn;1.5e-45 to &plusmn;3.4e38</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>42.0F</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>-11.0F</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">32-bit signed floating point number (7 significant digits)</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>float</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Double</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">8 bytes</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&plusmn;5.0e-324 to &plusmn;1.7e308</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>42.0</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>-11.0</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">64-bit signed floating point number (15-16 significant digits)</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>decimal</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Decimal</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">16 bytes</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&plusmn;1.0e-28 to &plusmn;7.9e28</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>42.0M</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>-11.0M</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">128-bit signed floating point number (28-29 significant digits)</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>BigRational</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Microsoft.FSharp.Math.BigRational</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">At least 4 bytes</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Any rational number.</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>42N</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>-11N</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Arbitrary precision rational number. Using this type requires a reference to FSharp.PowerPack.dll.</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="576" colspan="6" valign="top" style='width:432.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Text Types</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>char</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Char</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">2 bytes</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">U+0000 to U+ffff</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>'x'</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>'\t'</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Single unicode characters</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>string</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.String</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">20 + (2 * string's length) bytes</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">0 to about 2 billion characters</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>"Hello"</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>"World"</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Unicode text</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="576" colspan="6" valign="top" style='width:432.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Other Types</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>bool</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Boolean</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">1 byte</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Only two possible values,</span> <span class="Teletyped"><span lang="EN-US" style=''>true</span></span> <span lang="EN-US">or</span> <span class="Teletyped"><span lang="EN-US" style=''>false</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>true</span></span><span lang="EN-US"><br></span> <span class="Teletyped"><span lang="EN-US" style=''>false</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Stores boolean values</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">F# is a fully object-oriented language, using an object model based on the .NET Common Language Infrastructure (CLI). As such, it has a single-inheritance, multiple interface object model, and allows programmers to declare classes, interfaces, and abstract classes. Notably, it has full support for generic class, interface, and function definitions; however, it lacks some OO features found in other languages, such as mixins and multiple inheritance.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">F# also provides a unique array of data structures built directly into the syntax of the language, which include:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Unit, the datatype with only one value, equivalent to</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>void</span></span> <span lang="EN-US">in C-style languages.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Tuples_and_Records"><span style='color:windowtext;text-decoration:none'>Tuple types</span></a>, which are ad hoc data structures that programmers can use to group related values into a single object.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Tuples_and_Records%23Defining_Records"><span style='color:windowtext;text-decoration:none'>Record types</span></a>, which are similar to tuples, but provide named fields to access data held by the record object.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Discriminated_Unions"><span style='color:windowtext;text-decoration:none'>Discriminated unions</span></a>, which are used to create very well-defined type hierarchies and hierarchical data structures.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Lists"><span style='color:windowtext;text-decoration:none'>Lists</span></a>, <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Sets_and_Maps%23Maps"><span style='color:windowtext;text-decoration:none'>Maps</span></a>, and <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Sets_and_Maps"><span style='color:windowtext;text-decoration:none'>Sets</span></a>, which represent immutable versions of a stack, hashtable, and set data structures, respectively.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Sequences"><span style='color:windowtext;text-decoration:none'>Sequences</span></a>, which represent a lazy list of items computed on-demand.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Computation_Expressions"><span style='color:windowtext;text-decoration:none'>Computation expressions</span></a>, which serve the same purpose as monads in Haskell, allowing programmers to write continuation-style code in an imperative style.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">All of these features will be further enumerated and explained in later chapters of this book.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">F# is a statically typed language, meaning that the compiler knows the datatype of variables and functions at compile time. F# is also strongly typed, meaning that a variable bound to</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span><span lang="EN-US">s cannot be rebound to</span> <span class="Teletyped"><span lang="EN-US" style=''>string</span></span><span lang="EN-US">s at some later point; an</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">variable is forever tied to</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">data.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Unlike C# and VB.Net, F# does not perform implicit casts, not even safe conversions (such as converting an</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">to a</span> <span class="Teletyped"><span lang="EN-US" style=''>int64</span></span><span lang="EN-US">). F# requires explicit casts to convert between datatypes, for example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let x = 5;;<br>
				<br>
				val x : int = 5<br>
				<br>
				&gt; let y = 6L;;<br>
				<br>
				val y : int64 = 6L<br>
				<br>
				&gt; let z = x + y;;<br>
				<br>
				&nbsp; let z = x + y;;<br>
				&nbsp; ------------^<br>
				<br>
				stdin(5,13): error FS0001: The type 'int64' does not match the type 'int'<br>
				&gt; let z = (int64 x) + y;;<br>
				<br>
				val z : int64 = 11L</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The mathematical operators</span> <span class="Teletyped"><span lang="EN-US" style=''>+, -, /, *,</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>%</span></span> <span lang="EN-US">are overloaded to work with different datatypes, but they require arguments on each side of the operator to have the same datatype. We get an error trying to add an</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">to an</span> <span class="Teletyped"><span lang="EN-US" style=''>int64</span></span><span lang="EN-US">, so we have to cast one of our variables above to the other's datatype before the program will successfully compile.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Type Inference</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Unlike many other strongly typed languages, F# often does not require programmers to use type annotations when declaring functions and variables. Instead, F# attempts to work out the types for you, based on the way that variables are used in code.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">For example, let's take this function:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let average a b = (a + b) / 2.0</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We have not used any type annotations: that is, we have not explicitly told the compiler the data type of</span> <span class="Teletyped"><span lang="EN-US" style=''>a</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>b</span></span><span lang="EN-US">, nor have we indicated the type of the function's return value. If F# is a strongly, statically typed language, how does the compiler know the datatype of anything beforehand? That's easy, it uses simple deduction:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>+</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>/</span></span> <span lang="EN-US">operators are overloaded to work on different datatypes, but it defaults to integer addition and integer division without any extra information.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Teletyped"><span lang="EN-US" style=''>(a + b) /</span></span> <span class="Bold"><span lang="EN-US">2.0</span></span><span lang="EN-US">, the value in bold has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>float</span></span><span lang="EN-US">. Since F# doesn't perform implicit casts, and it requires arguments on both sides of a math operator to have the same datatype, the value</span> <span class="Teletyped"><span lang="EN-US" style=''>(a + b)</span></span> <span lang="EN-US">must return a</span> <span class="Teletyped"><span lang="EN-US" style=''>float</span></span> <span lang="EN-US">as well.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>+</span></span> <span lang="EN-US">operator only returns</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>float</span></span> <span lang="EN-US">when both arguments on each side of the operator are</span> <span class="Teletyped"><span lang="EN-US" style=''>float</span></span><span lang="EN-US">s, so</span> <span class="Teletyped"><span lang="EN-US" style=''>a</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>b</span></span> <span lang="EN-US">must be</span> <span class="Teletyped"><span lang="EN-US" style=''>float</span></span><span lang="EN-US">s as well.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Finally, since the return value of</span> <span class="Teletyped"><span lang="EN-US" style=''>float / float</span></span> <span lang="EN-US">is</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>float</span></span><span lang="EN-US">, the</span> <span class="Teletyped"><span lang="EN-US" style=''>average</span></span><span lang="EN-US">function must return a float.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This process is called type-inference. On most occasions, F# will be able to work out the types of data on its own without requiring the programmer to explicitly write out type annotations. This works just as well for small programs as large programs, and it can be a tremendous time-saver.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">On those occasions where F# cannot work out the types correctly, the programmer can provide explicit annotations to guide F# in the right direction. For example, as mentioned above, math operators default to operations on integers:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let add x y = x + y;;<br>
				val add : int -&gt; int -&gt; int</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In absence of other information, F# determines that</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>add</span></span> <span lang="EN-US">takes two integer and returns another integer. If we wanted to use</span> <span class="Teletyped"><span lang="EN-US" style=''>float</span></span><span lang="EN-US">s instead, we'd write:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let add (x : float) (y : float) = x + y;;<br>
				val add : float -&gt; float -&gt; float</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Pattern Matching</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">F#'s pattern matching is <em>similar</em> to an</span> <span class="Teletyped"><span lang="EN-US" style=''>if... then</span></span> <span lang="EN-US">or</span> <span class="Teletyped"><span lang="EN-US" style=''>switch</span></span><span lang="EN-US">construct in other languages, but is much more powerful. Pattern matching allows a programmer to decompose data structures into their component parts. It matches values based on the <em>shape</em> of the data structure, for example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Proposition =<br>
				&nbsp;&nbsp;&nbsp; | True<br>
				&nbsp;&nbsp;&nbsp; | Not of Proposition<br>
				&nbsp;&nbsp;&nbsp; | And of Proposition * Proposition<br>
				&nbsp;&nbsp;&nbsp; | Or of Proposition * Proposition<br>
				&nbsp;&nbsp;&nbsp;<br>
				let rec eval x =<br>
				&nbsp;&nbsp;&nbsp; match x with<br>
				&nbsp;&nbsp;&nbsp; | True -&gt; true<br>
				&nbsp;&nbsp;&nbsp; | Not(prop) -&gt; not (eval prop)<br>
				&nbsp;&nbsp;&nbsp; | And(prop1, prop2) -&gt; (eval prop1) &amp;&amp; (eval prop2)<br>
				&nbsp;&nbsp;&nbsp; | Or(prop1, prop2) -&gt; (eval prop1) || (eval prop2)<br>
				&nbsp;&nbsp;&nbsp;<br>
				let shouldBeFalse = And(Not True, Not True)<br>
				&nbsp;&nbsp;&nbsp;<br>
				let shouldBeTrue = Or(True, Not True)<br>
				&nbsp;&nbsp;&nbsp;<br>
				let complexLogic =<br>
				&nbsp;&nbsp;&nbsp; And(And(True,Or(Not(True),True)),<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Or(And(True, Not(True)), Not(True)) )<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				printfn "shouldBeFalse: %b" (eval shouldBeFalse)&nbsp;&nbsp;&nbsp; // prints False<br>
				printfn "shouldBeTrue: %b" (eval shouldBeTrue)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // prints True<br>
				printfn "complexLogic: %b" (eval complexLogic)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // prints False</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>eval</span></span> <span lang="EN-US">method uses pattern matching to recursively traverse and evaluate the abstract syntax tree. The</span> <span class="Teletyped"><span lang="EN-US" style=''>rec</span></span> <span lang="EN-US">keyword marks the function as recursive. Pattern matching will be explained in more detail in later chapters of this book.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Functional Programming Contrasted with Imperative Programming</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">F# is a mixed-paradigm language: it supports imperative, object-oriented, and functional styles of writing code, with heaviest emphasis on the latter.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Immutable Values vs Variables</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">The first mistake a newcomer to functional programming makes is thinking that the <em>let</em> construct is equivalent to assignment. Consider the following code:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let a = 1<br>
				(* a is now 1 *)<br>
				let a = a + 1<br>
				(* in F# this throws an error:&nbsp; Duplicate definition of value 'a' *)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">On the surface, this looks exactly like the familiar imperative pseudocode:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">a = 1 // a is 1 a = a + 1 // a is 2</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">However, the nature of the F# code is very different. Every <em>let</em> construct introduces a new scope, and binds symbols to values in that scope. If execution escapes this introduced scope, the symbols are restored to their original meanings. This is clearly not identical to variable state mutation with assignment.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">To clarify, let us desugar the F# code:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let a = 1 in&nbsp;<br>
				&nbsp; ((* a stands for 1 here *);<br>
				&nbsp;&nbsp; (let a = (* a still stands for 1 here *) a + 1 in (* a stands for 2 here *));<br>
				&nbsp;&nbsp; (* a stands for 1 here, again *))</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Indeed the code</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let a = 1 in&nbsp;<br>
				&nbsp; (printfn "%i" a;<br>
				&nbsp;&nbsp; (let a = a + 1 in printfn "%i" a);<br>
				&nbsp;&nbsp; printfn "%i" a)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">prints out</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">1&nbsp; 2 1</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Once symbols are bound to values, they cannot be assigned a new value. The only way to do change the meaning of a bound symbol is to <em>shadow</em> it by introducing a new binding for this symbol (for example, with a <em>let</em> construct, as in</span> <span class="Teletyped"><span lang="EN-US" style=''>let a = a + 1</span></span><span lang="EN-US">), but this shadowing will only have a localized effect: it will only affect the newly introduced scope. F# uses so-called 'lexical scoping', which simply means that one can identify the scope of a binding by simply looking at the code. Thus the scope of the</span> <span class="Teletyped"><span lang="EN-US" style=''>let a = a + 1</span></span> <span lang="EN-US">binding in</span> <span class="Teletyped"><span lang="EN-US" style=''>(let a = a + 1 in ..)</span></span><span lang="EN-US">is limited by the parentheses. With lexical scoping, there is no way for a piece of code to change the value of a bound symbol outside of itself, such as in the code that has called it.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Immutability is a great concept. Immutability allows programmers to pass values to functions without worrying that the function will change the value's state in unpredictable ways. Additionally, since value can't be mutated, programmers can process data shared across many threads without fear that the data will be mutated by another process; as a result, programmers can write multithreaded code without locks, and a whole class of errors related to race conditions and dead locking can be eliminated.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Functional programmers generally simulate state by passing extra parameters to functions; objects are "mutated" by creating an entirely new instance of an object with the desired changes and letting the garbage collector throw away the old instances if they are not needed. The resource overheads this style implies are dealt with by sharing structure. For example, changing the head of a singly-linked list of 1000 integers can be achieved by allocating a single new integer, reusing the tail of the original list (of length 999).</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">For the rare cases when mutation is really needed (for example, in number-crunching code which is a performance bottleneck), F# offers reference types and .NET mutable collections (such as arrays).</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Recursion or Loops?</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Imperative programming languages tend to iterate through collections with loops:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">void ProcessItems(Item[] items)<br>
				{<br>
				&nbsp;&nbsp;&nbsp; for(int i = 0; i &lt; items.Length; i++)<br>
				&nbsp;&nbsp;&nbsp; {<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Item myItem = items[i];<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc(myItem); // process myItem<br>
				&nbsp;&nbsp;&nbsp; }<br>
				}</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This admits a direct translation to F# (type annotations for</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>i</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>item</span></span> <span lang="EN-US">are omitted because F# can infer them):</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let processItems (items : Item []) =<br>
				&nbsp; for i in 0 .. items.Length do<br>
				&nbsp;&nbsp;&nbsp; let item = items.[i] in<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc item</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">However, the above code is clearly not written in a functional style. One problem with it is that it traverses an array of items. For many purposes including enumeration, functional programmers would use a different data structure, a singly linked list. Here is an example of iterating over this data structure with pattern matching:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let rec processItems = function<br>
				&nbsp; | []&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; ()<br>
				&nbsp; | hd :: tl -&gt;<br>
				&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;proc hd;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; processItems tl // recursively enumerate list</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">It is important to note that because the recursive call to</span> <span class="Teletyped"><span lang="EN-US" style=''>processItems</span></span> <span lang="EN-US">appears as the last expression in the function, this is an example of so-called <em>tail recursion</em>. The F# compiler recognizes this pattern and compiles</span> <span class="Teletyped"><span lang="EN-US" style=''>processItems</span></span> <span lang="EN-US">to a loop. The</span> <span class="Teletyped"><span lang="EN-US" style=''>processItems</span></span> <span lang="EN-US">function therefore runs in constant space and does not cause stack overflows.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">F# programmers rely on tail recursion to structure their programs whenever this technique contributes to code clarity.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">A careful reader has noticed that in the above example</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>proc</span></span> <span lang="EN-US">function was coming from the environment. The code can be improved and made more general by parameterizing it by this function (making</span> <span class="Teletyped"><span lang="EN-US" style=''>proc</span></span> <span lang="EN-US">a parameter):</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let rec processItems proc = function<br>
				&nbsp; | []&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; ()<br>
				&nbsp; | hd :: tl -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc hd;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; processItems proc tl // recursively enumerate list</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This</span> <span class="Teletyped"><span lang="EN-US" style=''>processItems</span></span><span lang="EN-US">function is indeed so useful that it has made it into the standard library under the name of</span> <span class="Teletyped"><span lang="EN-US" style=''>List.iter</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">For the sake of completeness it must be mentioned that F# includes generic versions of</span> <span class="Teletyped"><span lang="EN-US" style=''>List.iter</span></span><span lang="EN-US">called</span> <span class="Teletyped"><span lang="EN-US" style=''>Seq.iter</span></span> <span lang="EN-US">(other List.* functions usually have Seq.* counterparts as well) that works on lists, arrays, and all other collections. F# also includes a looping construct that works for all collections implementing the</span> <span class="Teletyped"><span lang="EN-US" style=''>System.Collections.Generic.IEnumerable</span></span><span lang="EN-US">:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">for item in collection do<br>
				&nbsp; process item</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Function Composition Rather than Inheritance</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Traditional OO uses <em>implementation inheritance</em> extensively; in other words, programmers create base classes with partial implementation, then build up object hierarchies from the base classes while overriding members as needed. This style has proven to be remarkably effective since the early 1990s, however this style is not contiguous with functional programming.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Functional programming aims to build simple, composable abstractions. Since traditional OO can only make an object's interface more complex, not simpler, inheritance is rarely used at all in F#. As a result, F# libraries tend to have fewer classes and very "flat" object hierarchies, as opposed to very deep and complex hierarchies found in equivalent Java or C# applications.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">F# tends to rely more on object composition and delegation rather than inheritance to share snippets of implementation across modules.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Functions as First-Order Types</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">F# is a functional programming language, meaning that functions are first-order data types: they can be declared and used in exactly the same way that any other variable can be used.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In an imperative language like Visual Basic there is a fundamental difference between variables and functions.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Dim myVal as Integer<br>
				Dim myParam as Integer<br>
				myParam = 2<br>
				Public Function MyFunc(Dim param as Integer)<br>
				&nbsp;&nbsp;&nbsp; MyFunc = (param * 2) + 7<br>
				End Function<br>
				myVal = MyFunc(myParam)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice the difference in syntax between defining and evaluating a function and defining and assigning a variable. In the preceding Visual Basic code we could perform a number of different actions with a variable we can:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">create a token (the variable name) and associate it with a type</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">assign it a value</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">interrogate its value</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">pass it into a function or sub-routine (which is essentially a function that returns no value)</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">return it from a function</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Functional programming makes no distinction between values and functions, so we can consider functions to be equal to all other data types. That means that we can:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">create a token (the function variable name) and associate it with a type</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">assign it a value (the actual calculation)</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">interrogate its value (perform the calculation)</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">pass a function as a parameter of another function or sub-routine</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">return a function as the result of another function</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Structure of F# Programs</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">A simple, non-trivial F# program has the following parts:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				&nbsp;<br>
				(* This is a<br>
				multi-line comment *)<br>
				&nbsp;<br>
				// This is a single-line comment<br>
				&nbsp;<br>
				let rec fib = function<br>
				&nbsp;&nbsp;&nbsp; | 0 -&gt; 1<br>
				&nbsp;&nbsp;&nbsp; | 1 -&gt; 1<br>
				&nbsp;&nbsp;&nbsp; | n -&gt; fib (n - 1) + fib (n - 2)<br>
				&nbsp;<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; Console.WriteLine("fib 5: {0}", (fib 5))<br>
				&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Most F# code files begin with a number of</span> <span class="Teletyped"><span lang="EN-US" style=''>open</span></span> <span lang="EN-US">statements used to import namespaces, allowing programmers to reference classes in namespaces without having to write fully qualified type declarations. This keyword is functionally equivalent to the</span> <span class="Teletyped"><span lang="EN-US" style=''>using</span></span> <span lang="EN-US">directive in C# and</span> <span class="Teletyped"><span lang="EN-US" style=''>Imports</span></span> <span lang="EN-US">directive in VB.Net. For example, the</span> <span class="Teletyped"><span lang="EN-US" style=''>Console</span></span> <span lang="EN-US">class is found under the</span> <span class="Teletyped"><span lang="EN-US" style=''>System</span></span> <span lang="EN-US">namespace; without importing the namespace, a programmer would need to access the</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Console</span></span> <span lang="EN-US">class through its fully qualified name,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Console</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The body of the F# file usually contains functions to implement the business logic in an application.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Finally, many F# application exhibit this pattern:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let main() =<br>
				&nbsp;&nbsp;&nbsp; (*<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This is the main loop.<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
				&nbsp;&nbsp;&nbsp; *)<br>
				<br>
				main()<br>
				(*<br>
				&nbsp;&nbsp; This is a top-level statement because it's<br>
				&nbsp;&nbsp; not nested in any other functions. This calls<br>
				&nbsp;&nbsp; into the main method to run the main loop.<br>
				*)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In general, there is no explicit entry point in an F# application. Rather, when an F# application is compiled, the last file passed to the compiler is assumed to be the entry point, and the compiler executes all top-level statements in the file from top to bottom. While its possible to have any number of top-level statements in the entry point of a F# program, well-written F# only has a single top-level statement which calls the main loop of the application.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Values and Functions
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Declaring Values and Functions</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">Compared to other .NET languages such as C# and VB.Net, F# has a somewhat terse and minimalistic syntax. To follow along in this tutorial, open F# Interactive (fsi) or Visual Studio and run the examples.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Declaring Variables</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">The most ubiquitous, familiar keyword in F# is the</span> <span class="Teletyped"><span lang="EN-US" style=''>let</span></span> <span lang="EN-US">keyword, which allows programmers to declare functions and variables in their applications.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">For example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let x = 5</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This declares a variable called</span> <span class="Teletyped"><span lang="EN-US" style=''>x</span></span> <span lang="EN-US">and assigns it the value</span> <span class="Teletyped"><span lang="EN-US" style=''>5</span></span><span lang="EN-US">. Naturally, we can write the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let x = 5<br>
				let y = 10<br>
				let z = x + y</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>z</span></span> <span lang="EN-US">now holds the value 15.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">A complete program looks like this:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let x = 5<br>
				let y = 10<br>
				let z = x + y<br>
				<br>
				printfn "x: %i" x<br>
				printfn "y: %i" y<br>
				printfn "z: %i" z</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The statement</span> <span class="Teletyped"><span lang="EN-US" style=''>printfn</span></span><span lang="EN-US">prints text out to the console window. As you might have guessed, the code above prints out the values of</span> <span class="Teletyped"><span lang="EN-US" style=''>x</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>y</span></span><span lang="EN-US">, and</span> <span class="Teletyped"><span lang="EN-US" style=''>z</span></span><span lang="EN-US">. This program results in the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">x: 5<br>
				y: 10<br>
				z: 15</span>
			</p>
			<p class="Blockquote">
				<span lang="EN-US">Note to F# Interactive users: all statements in F# Interactive are terminated by</span> <span class="Teletyped"><span lang="EN-US" style=''>;;</span></span> <span lang="EN-US">(two semicolons). To run the program above in fsi, copy and paste the text above into the fsi window, type</span> <span class="Teletyped"><span lang="EN-US" style=''>;;</span></span><span lang="EN-US">, then hit enter.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Values, Not Variables</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">In F#, "variable" is a misnomer. In reality, all "variables" in F# are immutable; in other words, once you bind a "variable" to a value, it's stuck with that value forever. For that reason, most F# programmers prefer to use "value" rather than "variable" to describe</span> <span class="Teletyped"><span lang="EN-US" style=''>x</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>y</span></span><span lang="EN-US">, and</span> <span class="Teletyped"><span lang="EN-US" style=''>z</span></span> <span lang="EN-US">above. Behind the scenes, F# actually compiles the "variables" above as static read-only properties.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Declaring Functions</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">There is little distinction between functions and values in F#. You use the same syntax to write a function as you use to declare a value:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let add x y = x + y</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>add</span></span> <span lang="EN-US">is the name of the function, and it takes two parameters,</span> <span class="Teletyped"><span lang="EN-US" style=''>x</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>y</span></span><span lang="EN-US">. Notice that each distinct argument in the functional declaration is separated by a space. Similarly, when you execute this function, successive arguments are separated by a space:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let z = add 5 10</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This assigns</span> <span class="Teletyped"><span lang="EN-US" style=''>z</span></span> <span lang="EN-US">the return value of this function, which in this case happens to be</span> <span class="Teletyped"><span lang="EN-US" style=''>15</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Naturally, we can pass the return value of functions directly into other functions, for example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let add x y = x + y<br>
				<br>
				let sub x y = x - y<br>
				<br>
				let printThreeNumbers num1 num2 num3 =<br>
				&nbsp;&nbsp; &nbsp;printfn "num1: %i" num1<br>
				&nbsp;&nbsp;&nbsp; printfn "num2: %i" num2<br>
				&nbsp;&nbsp;&nbsp; printfn "num3: %i" num3<br>
				<br>
				printThreeNumbers 5 (add 10 7) (sub 20 8)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">num1: 5num2: 17num3: 12</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice that I have to surround the calls to</span> <span class="Teletyped"><span lang="EN-US" style=''>add</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>sub</span></span> <span lang="EN-US">functions with parentheses; this tells F# to treat the value in parentheses as a single argument.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Otherwise, if we wrote</span> <span class="Teletyped"><span lang="EN-US" style=''>printThreeNumbers 5 add 10 7 sub 20 8</span></span><span lang="EN-US">, its not only incredibly difficult to read, but it actually passes 7 parameters to the function, which is obviously incorrect.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Function Return Values</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Unlike many other languages, F# functions do not have an explicit keyword to return a value. Instead, the return value of a function is simply the value of the last statement executed in the function. For example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let sign num =<br>
				&nbsp;&nbsp;&nbsp; if num &gt; 0 then "positive"<br>
				&nbsp;&nbsp;&nbsp; elif num &lt; 0 then "negative"<br>
				&nbsp;&nbsp;&nbsp; else "zero"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This function takes an integer parameter and returns a string. As you can imagine, the F# function above is equivalent to the following C# code:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">string Sign(int num)<br>
				{<br>
				&nbsp;&nbsp;&nbsp; if (num &gt; 0) return "positive";<br>
				&nbsp;&nbsp;&nbsp; else if (num &lt; 0) return "negative";<br>
				&nbsp;&nbsp;&nbsp; else return "zero";<br>
				}</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Just like C#, F# is a strongly typed language. A function can only return one datatype; for example, the following F# code will not compile:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let sign num =<br>
				&nbsp;&nbsp;&nbsp; if num &gt; 0 then "positive"<br>
				&nbsp;&nbsp;&nbsp; elif num &lt; 0 then "negative"<br>
				&nbsp;&nbsp;&nbsp; else 0</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">If you run this code in fsi, you get the following error message:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let sign num =<br>
				&nbsp;&nbsp;&nbsp; if num &gt; 0 then "positive"<br>
				&nbsp;&nbsp;&nbsp; elif num &lt; 0 then "negative"<br>
				&nbsp;&nbsp;&nbsp; else 0;;<br>
				<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else 0;;<br>
				&nbsp; ---------^</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">stdin(7,10): error FS0001: This expression was expected to have type&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp; but here has type&nbsp;&nbsp;&nbsp; int</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The error message is quite explicit: F# has determined that this function returns a</span> <span class="Teletyped"><span lang="EN-US" style=''>string</span></span><span lang="EN-US">, but the last line of the function returns an</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span><span lang="EN-US">, which is an error.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Interestingly, <em>every</em> function in F# has a return value; of course, programmers don't always write functions that return useful values. F# has a special datatype called</span> <span class="Teletyped"><span lang="EN-US" style=''>unit</span></span><span lang="EN-US">, which has just one possible value:</span> <span class="Teletyped"><span lang="EN-US" style=''>()</span></span><span lang="EN-US">. Functions return</span> <span class="Teletyped"><span lang="EN-US" style=''>unit</span></span> <span lang="EN-US">when they don't need to return any value to the programmer. For example, a function that prints a string to the console obviously doesn't have a return value:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let helloWorld = printfn "hello world"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This function takes no parameters and returns</span> <span class="Teletyped"><span lang="EN-US" style=''>()</span></span><span lang="EN-US">. You can think of</span> <span class="Teletyped"><span lang="EN-US" style=''>unit</span></span> <span lang="EN-US">as the equivalent to</span> <span class="Teletyped"><span lang="EN-US" style=''>void</span></span> <span lang="EN-US">in C-style languages.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">How To Read Arrow Notation</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">All functions and values in F# have a data type. Open F# Interactive and type the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let addAndMakeString x y = (x + y).ToString();;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">F# reports the data type using chained arrow notation as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">val addAndMakeString : int -&gt; int -&gt; string</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Data types are read from left to right. Before muddying the waters with a more accurate description of how F# functions are built, consider the basic concept of Arrow Notation: starting from the left, our function takes two</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">inputs and returns a</span> <span class="Teletyped"><span lang="EN-US" style=''>string</span></span><span lang="EN-US">. A function only has one return type, which is represented by the rightmost data type in chained arrow notation.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can read the following data types as follows:</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">int -&gt; string</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">takes one</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">input, returns a</span> <span class="Teletyped"><span lang="EN-US" style=''>string</span></span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">float -&gt; float -&gt; float</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">takes two</span> <span class="Teletyped"><span lang="EN-US" style=''>float</span></span><span lang="EN-US">inputs, returns another</span> <span class="Teletyped"><span lang="EN-US" style=''>float</span></span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">int -&gt; string -&gt; float</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">takes an</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">and a</span> <span class="Teletyped"><span lang="EN-US" style=''>string</span></span> <span lang="EN-US">input, returns a</span> <span class="Teletyped"><span lang="EN-US" style=''>float</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This description is a good introductory way to understand Arrow Notation for a beginner--and if you are new to F# feel free to stop here until you get your feet wet. For those who feel comfortable with this concept as described, the actual way in which F# is implementing these calls is via <span class="Bold">currying</span> the function.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Partial Function Application</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">While the above description of Arrow Notation is intuitive, it is not entirely accurate due to the fact that <span class="Bold">F# implicitly</span> <a href="http://en.wikipedia.org/wiki/Currying"><span class="Bold"><span style='color:windowtext;text-decoration:none'>curries</span></span></a> <span class="Bold">functions</span>. This means that a function only ever has a single argument and a single return type, quite at odds with the previous description of Arrow Notation above where in the second and third example two arguments are passed to a function. In reality, a function in F# <span class="Bold">only ever</span> has a single argument and a single return type. How can this be? Consider this type:</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">float -&gt; float -&gt; float</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">since a function of this type is implicitly curried by F#, there is a two step process to resolve the function when called with two arguments</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">a function is called with the first argument that <span class="Bold">returns a function</span> that takes a float and returns a float. To help clarify currying, lets call this function <span class="Bold">funX</span> (note that this naming is just for illustration purposes--the function that gets created by the runtime is anonymous).</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 2.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">the second function ('<span class="Bold">funX</span>' from step 1 above) is called with the second argument, returning a float</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">So, if you provide two floats, the result appears as if the function takes two arguments, though this is not actually how the runtime behaves. The concept of currying will probably strike a developer not steeped in functional concepts as very strange and non-intuitive--even needlessly redundant and inefficient, so before attempting a further explanation, consider <em>the benefits of curried functions</em> via an example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let addTwoNumbers x y = x + y</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">this type has the signature of</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">int -&gt; int -&gt; int</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">then this function:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let add5ToNumber = addTwoNumbers 5</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">with the type signature of <span class="Bold">(int -&gt; int)</span>. Note that the body of</span> <span class="Teletyped"><span lang="EN-US" style=''>add5ToNumber</span></span><span lang="EN-US">calls</span> <span class="Teletyped"><span lang="EN-US" style=''>addTwoNumbers</span></span> <span lang="EN-US">with only one argument--not two. It <span class="Bold">returns a function</span> that takes an int and returns an int. In other words,</span> <span class="Teletyped"><span lang="EN-US" style=''>add5toNumber</span></span> <span lang="EN-US"><span class="Bold">partially applies</span> the</span> <span class="Teletyped"><span lang="EN-US" style=''>addTwoNumbers</span></span> <span lang="EN-US">function.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let z = add5ToNumber 6;;<br>
				<br>
				val z : int = 11</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This partial application of a function with multiple argument exemplifies the power of curried functions. It allows <span class="Bold">deferred application</span> of the function, allowing for more modular development and code re-use--we can re-use the</span> <span class="Teletyped"><span lang="EN-US" style=''>addTwoNumbers</span></span> <span lang="EN-US">function to create a new function via partial application. From this, you can glean the power of function currying: it is always breaking down function application to the smallest possible elements, facilitating greater chances for code-reuse and modularity.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Take another example, illustrating the use of partially applied functions as a bookkeeping technique. Note the type signature of</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>holdOn</span></span> <span lang="EN-US">is a function (int -&gt; int) since it is the partial application of</span> <span class="Teletyped"><span lang="EN-US" style=''>addTwoNumbers</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let holdOn = addTwoNumbers 7;;<br>
				<br>
				val holdOn : (int -&gt; int)<br>
				<br>
				&gt; let okDone = holdOn 8;;<br>
				<br>
				val okDone : int = 15</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here we define a new function</span> <span class="Teletyped"><span lang="EN-US" style=''>holdOn</span></span> <span lang="EN-US">on the fly just to keep track of the first value to add. Then later we apply this new 'temp' function</span> <span class="Teletyped"><span lang="EN-US" style=''>holdOn</span></span> <span lang="EN-US">with another value which returns an int. Partially applied functions--enabled by currying--is a very powerful means of controlling complexity in F#. In short, the reason for the indirection resulting from currying function calls affords partial function application and all the benefits it supplies. In other words, the goal of partial function application is enabled by implicit currying.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">So while the Arrow Notation is a good shorthand for understanding the type signature of a function, it does so at the price of oversimplification, for a function with the type signature of</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">f : int -&gt; int -&gt; int</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">is actually (when taking into consideration the implicit currying):</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">// curried version pseudo-code<br>
				f: int -&gt; (int -&gt; int)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In other words, f is a function that takes an int and returns a function that takes an int and returns an int. Moreover,</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">f: int -&gt; int -&gt; int -&gt; int</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">is a simplified shorthand for</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">// curried version pseudo-code<br>
				f: int -&gt; (int -&gt; (int -&gt; int))</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">or, in very difficult to decode English: f is a function that takes an int and returns a function that takes an int that returns a function that takes an int and returns an int. Yikes!</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Nested Functions</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">F# allows programmers to nest functions inside other functions. Nested functions have a number of applications, such as hiding the complexity of inner loops:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let sumOfDivisors n =<br>
				&nbsp;&nbsp;&nbsp; let rec loop current max acc =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if current &gt; max then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acc<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;if n % current = 0 then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop (current + 1) max (acc + current)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop (current + 1) max acc<br>
				&nbsp;&nbsp;&nbsp; let start = 2<br>
				&nbsp;&nbsp;&nbsp; let max = n / 2&nbsp;&nbsp;&nbsp;&nbsp; (* largest factor, apart from n, cannot be &gt; n / 2 *)<br>
				&nbsp;&nbsp;&nbsp; let minSum = 1 + n&nbsp; (* 1 and n are already factors of n *)<br>
				&nbsp;&nbsp;&nbsp; loop start max minSum<br>
				<br>
				printfn "%d" (sumOfDivisors 10)<br>
				(* prints 18, because the sum of 10's divisors is 1 + 2 + 5 + 10 = 18 *)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The outer function</span> <span class="Teletyped"><span lang="EN-US" style=''>sumOfDivisors</span></span> <span lang="EN-US">makes a call to the inner function</span> <span class="Teletyped"><span lang="EN-US" style=''>loop</span></span><span lang="EN-US">. Programmers can have an arbitrary level of nested functions as need requires.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Generic Functions</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">In programming, a generic function is a function that returns an indeterminate type</span> <span class="Teletyped"><span lang="EN-US" style=''>t</span></span> <span lang="EN-US">without sacrificing type safety. A generic type is different from a concrete type such as an</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">or a</span> <span class="Teletyped"><span lang="EN-US" style=''>string</span></span><span lang="EN-US">; a generic type represents a <em>type to be specified later</em>. Generic functions are useful because they can be generalized over many different types.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Let's examine the following function:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let giveMeAThree x = 3</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">F# derives type information of variables from the way variables are used in an application, but F# can't constrain the value</span> <span class="Teletyped"><span lang="EN-US" style=''>x</span></span> <span lang="EN-US">to any particular concrete type, so F# generalizes</span> <span class="Teletyped"><span lang="EN-US" style=''>x</span></span> <span lang="EN-US">to the generic type</span> <span class="Teletyped"><span lang="EN-US" style=''>'a</span></span><span lang="EN-US">:</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>'a -&gt; int</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">this function takes a generic type</span> <span class="Teletyped"><span lang="EN-US" style=''>'a</span></span> <span lang="EN-US">and returns an</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">When you call a generic function, the compiler substitutes a function's generic type's with the data types of the values passed to the function. As a demonstration, let's use the following function:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let throwAwayFirstInput x y = y</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Which has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>'a -&gt; 'b -&gt; 'b</span></span><span lang="EN-US">, meaning that the function takes a generic</span> <span class="Teletyped"><span lang="EN-US" style=''>'a</span></span> <span lang="EN-US">and a generic</span> <span class="Teletyped"><span lang="EN-US" style=''>'b</span></span> <span lang="EN-US">and returns a</span> <span class="Teletyped"><span lang="EN-US" style=''>'b</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here are some sample inputs and outputs in F# interactive:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let throwAwayFirstInput x y = y;;<br>
				<br>
				val throwAwayFirstInput : 'a -&gt; 'b -&gt; 'b<br>
				<br>
				&gt; throwAwayFirstInput 5 "value";;<br>
				val it : string = "value"<br>
				<br>
				&gt; throwAwayFirstInput "thrownAway" 10.0;;<br>
				val it : float = 10.0<br>
				<br>
				&gt; throwAwayFirstInput 5 30;;<br>
				val it : int = 30</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>throwAwayFirstInput 5 "value"</span></span> <span lang="EN-US">calls the function with an</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">and a</span> <span class="Teletyped"><span lang="EN-US" style=''>string</span></span><span lang="EN-US">, which substitutes</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>int</span></span> <span lang="EN-US">for</span> <span class="Teletyped"><span lang="EN-US" style=''>'a</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>string</span></span> <span lang="EN-US">for</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>'b</span></span><span lang="EN-US">. This changes the data type of</span> <span class="Teletyped"><span lang="EN-US" style=''>throwAwayFirstInput</span></span> <span lang="EN-US">to</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>int -&gt; string -&gt; string</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>throwAwayFirstInput "thrownAway" 10.0</span></span> <span lang="EN-US">calls the function with a</span> <span class="Teletyped"><span lang="EN-US" style=''>string</span></span> <span lang="EN-US">and a</span> <span class="Teletyped"><span lang="EN-US" style=''>float</span></span><span lang="EN-US">, so the function's data type changes to</span> <span class="Teletyped"><span lang="EN-US" style=''>string -&gt; float -&gt; float</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>throwAwayFirstInput 5 30</span></span> <span lang="EN-US">just happens to call the function with two</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span><span lang="EN-US">s, so the function's data type is incidentally</span> <span class="Teletyped"><span lang="EN-US" style=''>int -&gt; int -&gt; int</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Generic functions are strongly typed. For example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let throwAwayFirstInput x y = y<br>
				let add x y = x + y<br>
				<br>
				let z = add 10 (throwAwayFirstInput "this is a string" 5)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The generic function</span> <span class="Teletyped"><span lang="EN-US" style=''>throwAwayFirstInput</span></span> <span lang="EN-US">is defined again, then the</span> <span class="Teletyped"><span lang="EN-US" style=''>add</span></span> <span lang="EN-US">function is defined and it has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>int -&gt; int -&gt; int</span></span><span lang="EN-US">, meaning that this function must be called with two</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">parameters.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Then</span> <span class="Teletyped"><span lang="EN-US" style=''>throwAwayFirstInput</span></span> <span lang="EN-US">is called, as a parameter to</span> <span class="Teletyped"><span lang="EN-US" style=''>add</span></span><span lang="EN-US">, with two parameters on itself, the first one of type string and the second of type int. This call to</span> <span class="Teletyped"><span lang="EN-US" style=''>throwAwayFirstInput</span></span><span lang="EN-US">ends up having the type</span> <span class="Teletyped"><span lang="EN-US" style=''>string -&gt; int -&gt; int</span></span><span lang="EN-US">. Since this function has the return type</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span><span lang="EN-US">, the code works as expected:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; add 10 (throwAwayFirstInput "this is a string" 5);;<br>
				val it : int = 15</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">However, we get an error when we reverse the order of the parameters to</span> <span class="Teletyped"><span lang="EN-US" style=''>throwAwayFirstInput</span></span><span lang="EN-US">:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; add 10 (throwAwayFirstInput 5 "this is a string");;<br>
				<br>
				&nbsp; add 10 (throwAwayFirstInput 5 "this is a string");;<br>
				&nbsp; ------------------------------^^^^^^^^^^^^^^^^^^^<br>
				<br>
				stdin(13,31): error FS0001: This expression has type<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string<br>
				but is here used with type<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The error message is very explicit: The</span> <span class="Teletyped"><span lang="EN-US" style=''>add</span></span> <span lang="EN-US">function takes two</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">parameters, but</span> <span class="Teletyped"><span lang="EN-US" style=''>throwAwayFirstInput 5 "this is a string"</span></span> <span lang="EN-US">has the return type</span> <span class="Teletyped"><span lang="EN-US" style=''>string</span></span><span lang="EN-US">, so we have a type mismatch.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Later chapters will demonstrate how to use generics in creative and interesting ways.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Pattern Matching Basics
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Pattern Matching Basics</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Pattern matching</span></span> <span lang="EN-US">is used for control flow; it allows programmers to look at a value, test it against a series of conditions, and perform certain computations depending on whether that condition is met. While pattern matching is conceptually similar to a series of</span> <span class="Teletyped"><span lang="EN-US" style=''>if ... then</span></span><span lang="EN-US">statements in other languages, F#'s pattern matching is much more flexible and powerful.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Pattern Matching Syntax</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">In high level terms, pattern matching resembles this:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">match expr with<br>
				| pat1 -&gt; result1<br>
				| pat2 -&gt; result2<br>
				| pat3 when expr2 -&gt; result3<br>
				| _ -&gt; defaultResult</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Each</span> <span class="Teletyped"><span lang="EN-US" style=''>|</span></span> <span lang="EN-US">defines a condition, the</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>-&gt;</span></span> <span lang="EN-US">means "if the condition is true, return this value...". The</span> <span class="Teletyped"><span lang="EN-US" style=''>_</span></span> <span lang="EN-US">is the <em>default pattern</em>, meaning that it matches anything, sort of like a wildcard.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Using a real example, it's easy to calculate the <span class="Bold">nth</span> Fibonacci number using pattern matching syntax:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let rec fib n =<br>
				&nbsp;&nbsp;&nbsp; match n with<br>
				&nbsp;&nbsp;&nbsp; | 0 -&gt; 0<br>
				&nbsp;&nbsp;&nbsp; | 1 -&gt; 1<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt; fib (n - 1) + fib (n - 2)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can experiment with this function in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">fib 1;;<br>
				val it : int = 1<br>
				&gt; fib 2;;<br>
				val it : int = 1<br>
				&gt; fib 5;;<br>
				val it : int = 5<br>
				&gt; fib 10;;<br>
				val it : int = 55</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">It's possible to chain together multiple conditions which return the same value. For example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let greeting name =<br>
				&nbsp;&nbsp;&nbsp; match name with<br>
				&nbsp;&nbsp;&nbsp; | "Steve" | "Kristina" | "Matt" -&gt; "Hello!"<br>
				&nbsp;&nbsp;&nbsp; | "Carlos" | "Maria" -&gt; "Hola!"<br>
				&nbsp;&nbsp;&nbsp; | "Worf" -&gt; "nuqneH!"<br>
				&nbsp;&nbsp;&nbsp; | "Pierre" | "Monique" -&gt; "Bonjour!"<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt; "DOES NOT COMPUTE!";;<br>
				<br>
				val greeting : string -&gt; string<br>
				<br>
				&gt; greeting "Monique";;<br>
				val it : string = "Bonjour!"<br>
				&gt; greeting "Pierre";;<br>
				val it : string = "Bonjour!"<br>
				&gt; greeting "Kristina";;<br>
				val it : string = "Hello!"<br>
				&gt; greeting "Sakura";;<br>
				val it : string = "DOES NOT COMPUTE!"</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Alternative Pattern Matching Syntax</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Pattern matching is such a fundamental feature that F# has a shorthand syntax for writing pattern matching functions using the</span> <span class="Teletyped"><span lang="EN-US" style=''>function</span></span> <span lang="EN-US">keyword:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let something = function<br>
				&nbsp;&nbsp;&nbsp; | test1 -&gt; value1<br>
				&nbsp;&nbsp;&nbsp; | test2 -&gt; value2<br>
				&nbsp;&nbsp;&nbsp; | test3 -&gt; value3</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">It may not be obvious, but a function defined in this way actually takes a single input. Here's a trivial example of the alternative syntax:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let getPrice = function<br>
				&nbsp;&nbsp;&nbsp; | "banana" -&gt; 0.79<br>
				&nbsp;&nbsp;&nbsp; | "watermelon" -&gt; 3.49<br>
				&nbsp;&nbsp;&nbsp; | "tofu" -&gt; 1.09<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt; nan (* nan is a special value meaning "not a number" *)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Although it doesn't appear as if the function takes any parameters, it actually has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>string -&gt; float</span></span><span lang="EN-US">, so it takes a single</span> <span class="Teletyped"><span lang="EN-US" style=''>string</span></span><span lang="EN-US">parameter and returns a</span> <span class="Teletyped"><span lang="EN-US" style=''>float</span></span><span lang="EN-US">. You call this function in exactly the same way that you'd call any other function:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; getPrice "tofu";;<br>
				val it : float = 1.09<br>
				<br>
				&gt; getPrice "banana";;<br>
				val it : float = 0.79<br>
				<br>
				&gt; getPrice "apple";;<br>
				val it : float = nan</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Comparison To Other Languages</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">F#'s pattern matching syntax is subtly different from "switch statement" structures in imperative languages, because each case in a pattern has a return value. For example, the</span> <span class="Teletyped"><span lang="EN-US" style=''>fib</span></span> <span lang="EN-US">function is equivalent to the following C#:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">int fib(int n)<br>
				{<br>
				&nbsp;&nbsp;&nbsp; switch(n)<br>
				&nbsp;&nbsp;&nbsp; {<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0: return 0;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1: return 1;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default: return fib(n - 1) + fib(n - 2);<br>
				&nbsp;&nbsp;&nbsp; }<br>
				}</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Like all functions, pattern matches can only have one return type.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Binding Variables with Pattern Matching</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Pattern matching is not a fancy syntax for a</span> <span class="Teletyped"><span lang="EN-US" style=''>switch</span></span> <span lang="EN-US">structure found in other languages, because it does not necessarily match against <em>values</em>, it matches against the <em>shape</em> of data.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">F# can automatically bind values to identifiers if they match certain patterns. This can be especially useful when using the alternative pattern matching syntax, for example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let rec factorial = function<br>
				&nbsp;&nbsp;&nbsp; | 0 | 1 -&gt; 1<br>
				&nbsp;&nbsp;&nbsp; | n -&gt; n * factorial (n - 1)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The variable</span> <span class="Teletyped"><span lang="EN-US" style=''>n</span></span> <span lang="EN-US">is a <em>pattern</em>. If the</span> <span class="Teletyped"><span lang="EN-US" style=''>factorial</span></span> <span lang="EN-US">function is called with a</span> <span class="Teletyped"><span lang="EN-US" style=''>5</span></span><span lang="EN-US">, the</span> <span class="Teletyped"><span lang="EN-US" style=''>0</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>1</span></span> <span lang="EN-US">patterns will fail, but the last pattern will match and bind the value to the identifier</span> <span class="Teletyped"><span lang="EN-US" style=''>n</span></span><span lang="EN-US">.</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <em><span lang="EN-US">Note to beginners:</span></em> <span lang="EN-US">variable binding in pattern matching often looks strange to beginners, however it is probably the most powerful and useful feature of F#. Variable binding is used to decompose data structures into component parts and allow programmers to examine each part; however, data structure decomposition is too advanced for most F# beginners, and the concept is difficult to express using simple types like</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span><span lang="EN-US">s and</span> <span class="Teletyped"><span lang="EN-US" style=''>string</span></span><span lang="EN-US">s. This book will discuss how to decompose data structures using pattern matching in later chapters.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Using Guards within Patterns</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Occasionally, it's not enough to match an input against a particular value; we can add filters, or guards, to patterns using the</span> <span class="Teletyped"><span lang="EN-US" style=''>when</span></span> <span lang="EN-US">keyword:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let sign = function<br>
				&nbsp;&nbsp;&nbsp; | 0 -&gt; 0<br>
				&nbsp;&nbsp;&nbsp; | x when x &lt; 0 -&gt; -1<br>
				&nbsp;&nbsp;&nbsp; | x when x &gt; 0 -&gt; 1</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The function above returns the sign of a number: -1 for negative numbers, +1 for positive numbers, and '0' for 0:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; sign -55;;<br>
				val it : int = -1<br>
				<br>
				&gt; sign 108;;<br>
				val it : int = 1<br>
				<br>
				&gt; sign 0;;<br>
				val it : int = 0</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Variable binding is useful because it's often required to implement guards.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Pay Attention to F# Warnings</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Note that F#'s pattern matching works from top to bottom: it tests a value against each pattern, and returns the value of the first pattern which matches. It is possible for programmers to make mistakes, such as placing a general case above a specific (which would prevent the specific case from ever being matched), or writing a pattern which doesn't match all possible inputs. F# is smart enough to notify the programmer of these types of errors.</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Example With Incomplete Pattern Matches</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let getCityFromZipcode zip =<br>
				&nbsp; &nbsp;&nbsp;match zip with<br>
				&nbsp;&nbsp;&nbsp; | 68528 -&gt; "Lincoln, Nebraska"<br>
				&nbsp;&nbsp;&nbsp; | 90210 -&gt; "Beverly Hills, California";;<br>
				<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match zip with<br>
				&nbsp; ----------^^^^<br>
				<br>
				stdin(12,11): warning FS0025: Incomplete pattern matches on this expression.<br>
				For example, the value '0' will not be matched<br>
				<br>
				val getCityFromZipcode : int -&gt; string</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">While this code is valid, F# informs the programmer of the possible error. F# warns us for a reason:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; getCityFromZipcode 68528;;<br>
				val it : string = "Lincoln, Nebraska"<br>
				&gt; getCityFromZipcode 32566;;<br>
				Microsoft.FSharp.Core.MatchFailureException:<br>
				Exception of type 'Microsoft.FSharp.Core.MatchFailureException' was thrown.<br>
				&nbsp;&nbsp; at FSI_0018.getCityFromZipcode(Int32 zip)<br>
				&nbsp;&nbsp; at &lt;StartupCode$FSI_0020&gt;.$FSI_0020._main()<br>
				stopped due to error</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">F# will throw an exception if a pattern isn't matched. The obvious solution to this problem is to write patterns which are complete.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">On occasions when a function genuinely has a limited range of inputs, its best to adopt this style:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let apartmentPrices numberOfRooms =<br>
				&nbsp;&nbsp;&nbsp; match numberOfRooms with<br>
				&nbsp;&nbsp;&nbsp; | 1 -&gt; 500.0<br>
				&nbsp;&nbsp;&nbsp; | 2 -&gt; 650.0<br>
				&nbsp;&nbsp;&nbsp; | 3 -&gt; 700.0<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt; failwith "Only 1-, 2-, and 3- bedroom apartments available at this complex"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This function now matches any possible input, and will fail with an explanatory informative error message on invalid inputs (this makes sense, because who would rent a negative 42 bedroom apartment?).</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Example With Unmatched Patterns</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let greeting name =<br>
				&nbsp;&nbsp;&nbsp; match name with<br>
				&nbsp;&nbsp;&nbsp; | "Steve" -&gt; "Hello!"<br>
				&nbsp;&nbsp;&nbsp; | "Carlos" -&gt; "Hola!"<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt; "DOES NOT COMPUTE!"<br>
				&nbsp;&nbsp;&nbsp; | "Pierre" -&gt; "Bonjour";;<br>
				<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | "Pierre" -&gt; "Bonjour";;<br>
				&nbsp; ------^^^^^^^^^<br>
				<br>
				stdin(22,7): warning FS0026: This rule will never be matched.<br>
				<br>
				val greeting : string -&gt; string</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Since the pattern</span> <span class="Teletyped"><span lang="EN-US" style=''>_</span></span> <span lang="EN-US">matches anything, and since F# evaluates patterns from top to bottom, its not possible for the code to ever reach the pattern</span> <span class="Teletyped"><span lang="EN-US" style=''>"Pierre"</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here is a demonstration of this code in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; greeting "Steve";;<br>
				val it : string = "Hello!"<br>
				&gt; greeting "Ino";;<br>
				val it : string = "DOES NOT COMPUTE!"<br>
				&gt; greeting "Pierre";;<br>
				val it : string = "DOES NOT COMPUTE!"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The first two lines return the correct output, because we've defined a pattern for</span> <span class="Teletyped"><span lang="EN-US" style=''>"Steve"</span></span> <span lang="EN-US">and nothing for</span> <span class="Teletyped"><span lang="EN-US" style=''>"Ino"</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">However, the third line is wrong. We have an entry for</span> <span class="Teletyped"><span lang="EN-US" style=''>"Pierre"</span></span><span lang="EN-US">, but F# never reaches it. The best solution to this problem is to deliberately arrange the order of conditions from most specific to most general.</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <em><span lang="EN-US">Note to beginners:</span></em> <span lang="EN-US">The code above contains an error, but it will not throw an exception. These are the worst kinds of errors to have, much worse than an error which throws an exception and crashes an app, because this error puts our program in an invalid state and silently continues on its way. An error like this might occur early in a program's life cycle, but may not show its effects for a long time (it could take minutes, days, or weeks before someone notices the buggy behavior). Ideally, we want buggy behavior to be as "close" to its source as possible, so if a program enters an invalid state, it <em>should</em> throw an exception immediately.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Recursion
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Recursion and Recursive Functions Solutions</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Faster Fib Function</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">The following function calculates the <em>nth</em> number in the Fibonacci sequence:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let rec fib = function<br>
				&nbsp;&nbsp;&nbsp; | n when n=0I -&gt; 0I<br>
				&nbsp;&nbsp;&nbsp; | n when n=1I -&gt; 1I<br>
				&nbsp;&nbsp;&nbsp; | n -&gt; fib(n - 1I) + fib(n - 2I)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The function above is neither tail-recursive nor particularly efficient with a computational complexity <em>O(2</em><span class="Sup">n</span><em>)</em>. The tail-recursive form of this function has a computational complexity of <em>O(n)</em>. Re-write the function above so that its tail recursive.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">You can verify the correctness of your function using the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">fib(0) = 0fib(1) = 1fib(2) = 1fib(3) = 2fib(4) = 3fib(5) = 5fib(10) = 55fib(100) = 354224848179261915075</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Solution</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Examine the first 10 numbers in the Fibonacci sequence:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">n: fib(n)--------- 0: 0 1: 1 2: 1 3: 2 4: 3 5: 5 6: 8 7: 13 8: 21 9: 3410: 55</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Each number in the sequence is the sum of two numbers above it. If we hold the values of the previous two fib numbers in accumulating parameters, then we can calculate then next fib number very easily.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let fib n =<br>
				&nbsp;&nbsp;&nbsp; let rec loop acc1 acc2 = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | n when n = 0I -&gt; acc1<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | n -&gt; loop acc2 (acc1 + acc2) (n - 1I)<br>
				&nbsp;&nbsp;&nbsp; loop 0I 1I n</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The accumulator variables</span> <span class="Teletyped"><span lang="EN-US" style=''>acc1</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>acc2</span></span> <span lang="EN-US">correspond to</span> <span class="Teletyped"><span lang="EN-US" style=''>fib(n - 1)</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>fib(n - 2)</span></span> <span lang="EN-US">respectively.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can test this function in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let fib n =<br>
				&nbsp;&nbsp;&nbsp; let rec loop acc1 acc2 = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | n when n = 0I -&gt; acc1<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | n -&gt; loop acc2 (acc1 + acc2) (n - 1I)<br>
				&nbsp;&nbsp;&nbsp; loop 0I 1I n;;<br>
				<br>
				val fib : Numerics.BigInteger -&gt; Numerics.BigInteger<br>
				<br>
				&gt; [0I .. 10I] |&gt; Seq.iter (fun x -&gt; printfn "fib(%O) = %O" x (fib x));;<br>
				fib(0) = 0<br>
				fib(1) = 1<br>
				fib(2) = 1<br>
				fib(3) = 2<br>
				fib(4) = 3<br>
				fib(5) = 5<br>
				fib(6) = 8<br>
				fib(7) = 13<br>
				fib(8) = 21<br>
				fib(9) = 34<br>
				fib(10) = 55<br>
				val it : unit = ()<br>
				<br>
				&gt; fib 100I;;<br>
				val it : Numerics.BigInteger = 354224848179261915075I<br>
				<br>
				&gt; fib 1000I;;<br>
				val it : Numerics.BigInteger<br>
				= 434665576869374564356885276750406258025646605173717<br>
				80402481729089536555417949051890403879840079255169295<br>
				92259308032263477520968962323987332247116164299644090<br>
				6533187938298969649928516003704476137795166849228875I</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Higher Order Functions
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Higher Order Functions</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">A higher-order function is a function that takes another function as a parameter, or a function that returns another function as a value, or a function which does both.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Familiar Higher Order Functions</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">To put higher order functions in perspective, if you've ever taken a first-semester course on calculus, you're undoubtedly familiar with two functions: the limit function and the derivative function.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The limit function is defined as follows:</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The limit function,</span> <span class="Teletyped"><span lang="EN-US" style=''>lim</span></span><span lang="EN-US">, takes another function</span> <span class="Teletyped"><span lang="EN-US" style=''>f(x)</span></span> <span lang="EN-US">as a parameter, and it returns a value</span> <span class="Teletyped"><span lang="EN-US" style=''>L</span></span> <span lang="EN-US">to represent the limit.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Similarly, the derivative function is defined as follows:</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The derivative function,</span> <span class="Teletyped"><span lang="EN-US" style=''>deriv</span></span><span lang="EN-US">, takes a function</span> <span class="Teletyped"><span lang="EN-US" style=''>f(x)</span></span> <span lang="EN-US">as a parameter, and it returns a completely different function</span> <span class="Teletyped"><span lang="EN-US" style=''>f'(x)</span></span> <span lang="EN-US">as a result.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In this respect, we can correctly assume the limit and derivative functions are higher-order functions. If we have a good understanding of higher-order functions in mathematics, then we can apply the same principles in F# code.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In F#, we can pass a function to another function just as if it was a literal value, and we call it just like we call any other function. For example, here's a very trivial function:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let passFive f = (f 5)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In F# notation,</span> <span class="Teletyped"><span lang="EN-US" style=''>passFive</span></span> <span lang="EN-US">has the following type:</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Teletyped"><span style=''>val passFive : (int -&gt; 'a) -&gt; 'a</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In other words,</span> <span class="Teletyped"><span lang="EN-US" style=''>passFive</span></span> <span lang="EN-US">takes a function</span> <span class="Teletyped"><span lang="EN-US" style=''>f</span></span><span lang="EN-US">, where</span> <span class="Teletyped"><span lang="EN-US" style=''>f</span></span> <span lang="EN-US">must take an</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">and return any generic type</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>'a</span></span><span lang="EN-US">. Our function</span> <span class="Teletyped"><span lang="EN-US" style=''>passFive</span></span> <span lang="EN-US">has the return type</span> <span class="Teletyped"><span lang="EN-US" style=''>'a</span></span> <span lang="EN-US">because we don't know the return type of</span> <span class="Teletyped"><span lang="EN-US" style=''>f 5</span></span> <span lang="EN-US">in advance.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let square x = x * x&nbsp;&nbsp;&nbsp;<br>
				<br>
				let cube x = x * x * x<br>
				<br>
				let sign x =<br>
				&nbsp;&nbsp;&nbsp; if x &gt; 0 then "positive"<br>
				&nbsp;&nbsp;&nbsp; else if x &lt; 0 then "negative"<br>
				&nbsp;&nbsp;&nbsp; else "zero"<br>
				<br>
				let passFive f = (f 5)<br>
				<br>
				printfn "%A" (passFive square)&nbsp; // 25<br>
				printfn "%A" (passFive cube)&nbsp;&nbsp;&nbsp; // 125<br>
				printfn "%A" (passFive sign)&nbsp;&nbsp;&nbsp; // "positive"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">These functions have the following types:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">val square : int -&gt; int<br>
				val cube : int -&gt; int<br>
				val sign : int -&gt; string<br>
				val passFive : (int -&gt; 'a) -&gt; 'a</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Unlike many other languages, F# makes no distinction between functions and values. We pass functions to other functions in the exact same way that we pass ints, strings, and other values.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Creating a Map Function</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">A map function converts one type of data to another type of data. A simple map function in F# looks like this:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let map item converter = converter item</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>val map : 'a -&gt; ('a -&gt; 'b) -&gt; 'b</span></span><span lang="EN-US">. In other words,</span> <span class="Teletyped"><span lang="EN-US" style=''>map</span></span> <span lang="EN-US">takes a two parameters: an item 'a, and a function that takes an</span> <span class="Teletyped"><span lang="EN-US" style=''>'a</span></span> <span lang="EN-US">and returns a</span> <span class="Teletyped"><span lang="EN-US" style=''>'b</span></span><span lang="EN-US">; map returns a</span> <span class="Teletyped"><span lang="EN-US" style=''>'b</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Let's examine the following code:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let map x f = f x<br>
				<br>
				let square x = x * x<br>
				<br>
				let cubeAndConvertToString x =<br>
				&nbsp;&nbsp;&nbsp; let temp = x * x * x<br>
				&nbsp;&nbsp;&nbsp; temp.ToString()<br>
				&nbsp;&nbsp;&nbsp;<br>
				let answer x =<br>
				&nbsp;&nbsp;&nbsp; if x = true then "yes"<br>
				&nbsp;&nbsp;&nbsp; else "no"<br>
				<br>
				let first = map 5 square<br>
				let second = map 5 cubeAndConvertToString<br>
				let third = map true answer</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">These functions have the following signatures:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">val map : 'a -&gt; ('a -&gt; 'b) -&gt; 'b<br>
				<br>
				val square : int -&gt; int<br>
				val cubeAndConvertToString : int -&gt; string<br>
				val answer : bool -&gt; string<br>
				<br>
				val first : int<br>
				val second : string<br>
				val third : string</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>first</span></span><span lang="EN-US">function passes a datatype</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">and a function with the signature</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>(int -&gt; int)</span></span><span lang="EN-US">; this means the placeholders</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>'a</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>'b</span></span> <span lang="EN-US">in the map function both become</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span><span lang="EN-US">s.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>second</span></span><span lang="EN-US">function passes a datatype</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">and a function</span> <span class="Teletyped"><span lang="EN-US" style=''>(int -&gt; string)</span></span><span lang="EN-US">, and</span> <span class="Teletyped"><span lang="EN-US" style=''>map</span></span> <span lang="EN-US">predictably returns a</span> <span class="Teletyped"><span lang="EN-US" style=''>string</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>third</span></span><span lang="EN-US">function passes a datatype</span> <span class="Teletyped"><span lang="EN-US" style=''>bool</span></span> <span lang="EN-US">and a function</span> <span class="Teletyped"><span lang="EN-US" style=''>(bool -&gt; string)</span></span><span lang="EN-US">, and</span> <span class="Teletyped"><span lang="EN-US" style=''>map</span></span> <span lang="EN-US">returns a</span> <span class="Teletyped"><span lang="EN-US" style=''>string</span></span> <span lang="EN-US">just as we expect.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Since our generic code is typesafe, we would get an error if we wrote:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let fourth = map true square</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Because the</span> <span class="Teletyped"><span lang="EN-US" style=''>true</span></span><span lang="EN-US">constrains our function to a type</span> <span class="Teletyped"><span lang="EN-US" style=''>(bool -&gt; 'b)</span></span><span lang="EN-US">, but the</span> <span class="Teletyped"><span lang="EN-US" style=''>square</span></span> <span lang="EN-US">function has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>(int -&gt; int)</span></span><span lang="EN-US">, so it's obviously incorrect.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">The Composition Function (&lt;&lt; operator)</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">In algebra, the composition function is defined as</span> <span class="Teletyped"><span lang="EN-US" style=''>compose(f, g, x) = f(g(x))</span></span><span lang="EN-US">, denoted <em>f</em> <span class="Small">o</span> <em>g</em>. In F#, the composition function is defined as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let inline (&lt;&lt;) f g x = f (g x)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Which has the somewhat cumbersome signature</span> <span class="Teletyped"><span lang="EN-US" style=''>val &lt;&lt; : ('b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'a -&gt; 'c</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">If I had two functions:</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> f(x) = x^2
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> g(x) = -x/2 + 5
			</p>
			<p class="TextBody">
				<span lang="EN-US">And I wanted to model <em>f</em> <span class="Small">o</span> <em>g</em>, I could write:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let f x = x*x<br>
				let g x = -x/2.0 + 5.0<br>
				<br>
				let fog = f &lt;&lt; g<br>
				<br>
				Console.WriteLine(fog 0.0) // 25<br>
				Console.WriteLine(fog 1.0) // 20.25<br>
				Console.WriteLine(fog 2.0) // 16<br>
				Console.WriteLine(fog 3.0) // 12.25<br>
				Console.WriteLine(fog 4.0) // 9<br>
				Console.WriteLine(fog 5.0) // 6.25</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Note that</span> <span class="Teletyped"><span lang="EN-US" style=''>fog</span></span> <span lang="EN-US">doesn't return a value, it returns another function whose signature is</span> <span class="Teletyped"><span lang="EN-US" style=''>(float -&gt; float)</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Of course, there's no reason why the compose function needs to be limited to numbers; since it's generic, it can work with any datatype, such as</span> <span class="Teletyped"><span lang="EN-US" style=''>int array</span></span><span lang="EN-US">s,</span> <span class="Teletyped"><span lang="EN-US" style=''>tuple</span></span><span lang="EN-US">s,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>string</span></span><span lang="EN-US">s, and so on.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">There also exists the</span> <span class="Teletyped"><span lang="EN-US" style=''>&gt;&gt;</span></span> <span lang="EN-US">operator, which similarly performs function composition, but in reverse order. It is defined as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let inline (&gt;&gt;) f g x = g (f x)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This operator's signature is as follows:</span> <span class="Teletyped"><span lang="EN-US" style=''>val &gt;&gt; : ('a -&gt; 'b) -&gt; ('b -&gt; 'c) -&gt; 'a -&gt; 'c</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The advantage of doing composition using the</span> <span class="Teletyped"><span lang="EN-US" style=''>&gt;&gt;</span></span> <span lang="EN-US">operator is that the functions in the composition are listed in the order in which they are called.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let gof = f &gt;&gt; g</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This will first apply</span> <span class="Teletyped"><span lang="EN-US" style=''>f</span></span> <span lang="EN-US">and then apply</span> <span class="Teletyped"><span lang="EN-US" style=''>g</span></span> <span lang="EN-US">on the result.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">The |&gt; Operator</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">The pipeline operator,</span> <span class="Teletyped"><span lang="EN-US" style=''>|&gt;</span></span><span lang="EN-US">, is one of the most important operators in F#. The definition of the pipeline operator is remarkably simple:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let inline (|&gt;) x f = f x</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Let's take 3 functions:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let square x = x * x<br>
				let add x y = x + y<br>
				let toString x = x.ToString()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Let's also say we had a complicated function which squared a number, added five to it, and converted it to a string? Normally, we'd write this:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let complexFunction x =<br>
				&nbsp;&nbsp;&nbsp; toString (add 5 (square x))</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can improve the readability of this function somewhat using the pipeline operator:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let complexFunction x =<br>
				&nbsp;&nbsp;&nbsp; x |&gt; square |&gt; add 5 |&gt; toString</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>x</span></span> <span lang="EN-US">is piped to the</span> <span class="Teletyped"><span lang="EN-US" style=''>square</span></span> <span lang="EN-US">function, which is piped to</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>add 5</span></span> <span lang="EN-US">method, and finally to the</span> <span class="Teletyped"><span lang="EN-US" style=''>toString</span></span> <span lang="EN-US">method.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Anonymous Functions</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Until now, all functions shown in this book have been named. For example, the function above is named</span> <span class="Teletyped"><span lang="EN-US" style=''>add</span></span><span lang="EN-US">. F# allows programmers to declare nameless, or anonymous functions using the</span> <span class="Teletyped"><span lang="EN-US" style=''>fun</span></span> <span lang="EN-US">keyword.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let complexFunction =<br>
				&nbsp;&nbsp;&nbsp; 2 |&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* 2 *)<br>
				&nbsp;&nbsp;&nbsp; ( fun x -&gt; x + 5) |&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* 2 + 5 = 7 *)<br>
				&nbsp;&nbsp;&nbsp; ( fun x -&gt; x * x) |&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* 7 * 7 = 49 *)<br>
				&nbsp;&nbsp; &nbsp;( fun x -&gt; x.ToString() ) (* 49.ToString = "49" *)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Anonymous functions are convenient and find a use in a surprising number of places.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">A Timer Function</span>
			</h3>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let duration f =<br>
				&nbsp;&nbsp;&nbsp; let timer = new System.Diagnostics.Stopwatch()<br>
				&nbsp;&nbsp;&nbsp; timer.Start()<br>
				&nbsp;&nbsp;&nbsp; let returnValue = f()<br>
				&nbsp;&nbsp;&nbsp; printfn "Elapsed Time: %i" timer.ElapsedMilliseconds<br>
				&nbsp;&nbsp;&nbsp; returnValue<br>
				&nbsp;&nbsp;&nbsp;<br>
				let rec fib = function<br>
				&nbsp;&nbsp;&nbsp; | 0 -&gt; 0<br>
				&nbsp;&nbsp;&nbsp; | 1 -&gt; 1<br>
				&nbsp;&nbsp;&nbsp; | n -&gt; fib (n - 1) + fib (n - 2)<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; printfn "fib 5: %i" (duration ( fun() -&gt; fib 5 ))<br>
				&nbsp;&nbsp;&nbsp; printfn "fib 30: %i" (duration ( fun() -&gt; fib 30 ))<br>
				<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>duration</span></span><span lang="EN-US">function has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>val duration : (unit -&gt; 'a) -&gt; 'a</span></span><span lang="EN-US">. This program prints:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				Duration (ms): 0.976500fib 5: 5Duration (ms): 24.412500fib 30: 832040
			</p>
			<p class="TextBody">
				&nbsp;
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <em><span lang="EN-US">Note</span></em><span lang="EN-US">: the actual duration to execute these functions will vary from machine to machine.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Currying and Partial Functions</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">A fascinating feature in F# is called "currying", which means that F# does not require programmers to provide all of the arguments when calling a function. For example, lets say we have a function:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let add x y = x + y</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>add</span></span> <span lang="EN-US">takes two integers and returns another integer. In F# notation, this is written as</span> <span class="Teletyped"><span lang="EN-US" style=''>val add : int -&gt; int -&gt; int</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can define another function as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let addFive = add 5</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>addFive</span></span><span lang="EN-US">calls the</span> <span class="Teletyped"><span lang="EN-US" style=''>add</span></span> <span lang="EN-US">function with one its parameters, so what is the return value of this function? That's easy:</span> <span class="Teletyped"><span lang="EN-US" style=''>addFive</span></span> <span lang="EN-US">returns another function which is waiting for the rest of its arguments. In this case, addFive returns a function that takes an</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">and returns another</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span><span lang="EN-US">, denoted in F# notation as</span> <span class="Teletyped"><span lang="EN-US" style=''>val addFive : (int -&gt; int)</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">You call</span> <span class="Teletyped"><span lang="EN-US" style=''>addFive</span></span> <span lang="EN-US">just in the same way that you call other functions:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let add x y = x + y<br>
				<br>
				let addFive = add 5<br>
				<br>
				Console.WriteLine(addFive 12) // prints 17</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">How Currying Works</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">The function</span> <span class="Teletyped"><span lang="EN-US" style=''>let add x y = x + y</span></span> <span lang="EN-US">has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>val add : int -&gt; int -&gt; int</span></span><span lang="EN-US">. F# use the slightly unconventional arrow notation to denote function signatures for a reason: arrows notation is intrinsically connected to currying and anonymous functions. Currying works because, behind the scenes, F# converts function parameters to a style that looks like this:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let add = (fun x -&gt; (fun y -&gt; x + y) )</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The type</span> <span class="Teletyped"><span lang="EN-US" style=''>int -&gt; int -&gt; int</span></span> <span lang="EN-US">is semantically equivalent to</span> <span class="Teletyped"><span lang="EN-US" style=''>(int -&gt; (int -&gt; int))</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">When you call</span> <span class="Teletyped"><span lang="EN-US" style=''>add</span></span> <span lang="EN-US">with no arguments, it returns</span> <span class="Teletyped"><span lang="EN-US" style=''>fun x -&gt; fun y -&gt; x + y</span></span> <span lang="EN-US">(or equivalently</span> <span class="Teletyped"><span lang="EN-US" style=''>fun x y -&gt; x + y</span></span><span lang="EN-US">), another function waiting for the rest of its arguments. Likewise, when you supply one argument to the function above, say 5, it returns</span> <span class="Teletyped"><span lang="EN-US" style=''>fun y -&gt; 5 + y</span></span><span lang="EN-US">, another function waiting for the rest of its arguments, with all occurrences of x being replaced by the argument 5.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Currying is built on the principle that each argument actually returns a separate function, which is why calling a function with only part of its parameters returns another function. The familiar F# syntax that we've seen so far,</span> <span class="Teletyped"><span lang="EN-US" style=''>let add x y = x + y</span></span><span lang="EN-US">, is actually a kind of syntatic sugar for the explicit currying style shown above.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Two Pattern Matching Syntaxes</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">You may have wondered why there are two pattern matching syntaxes:</span>
			</p>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Traditional Syntax</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Shortcut Syntax</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
						<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
							<span lang="EN-US">let getPrice food =<br>
							&nbsp;&nbsp;&nbsp; match food with<br>
							&nbsp;&nbsp;&nbsp; | "banana" -&gt; 0.79<br>
							&nbsp;&nbsp;&nbsp; | "watermelon" -&gt; 3.49<br>
							&nbsp;&nbsp;&nbsp; | "tofu" -&gt; 1.09<br>
							&nbsp;&nbsp;&nbsp; | _ -&gt; nan</span>
						</p>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
						<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
							<span lang="EN-US">let getPrice2 = function<br>
							&nbsp;&nbsp;&nbsp; | "banana" -&gt; 0.79<br>
							&nbsp;&nbsp;&nbsp; | "watermelon" -&gt; 3.49<br>
							&nbsp;&nbsp;&nbsp; | "tofu" -&gt; 1.09<br>
							&nbsp;&nbsp;&nbsp; | _ -&gt; nan</span>
						</p>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">Both snippets of code are identical, but why does the shortcut syntax allow programmers to omit the</span> <span class="Teletyped"><span lang="EN-US" style=''>food</span></span> <span lang="EN-US">parameter in the function definition? The answer is related to currying: behind the scenes, the F# compiler converts the</span> <span class="Teletyped"><span lang="EN-US" style=''>function</span></span> <span lang="EN-US">keyword into the following construct:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let getPrice2 =<br>
				&nbsp;&nbsp;&nbsp; (fun x -&gt;<br>
				&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match x with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | "banana" -&gt; 0.79<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | "watermelon" -&gt; 3.49<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | "tofu" -&gt; 1.09<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | _ -&gt; nan)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In other words, F# treats the</span> <span class="Teletyped"><span lang="EN-US" style=''>function</span></span> <span lang="EN-US">keyword as an anonymous function that takes one parameter and returns one value. The</span> <span class="Teletyped"><span lang="EN-US" style=''>getPrice2</span></span> <span lang="EN-US">function actually returns an anonymous function; arguments passed to</span> <span class="Teletyped"><span lang="EN-US" style=''>getPrice2</span></span> <span lang="EN-US">are actually applied and evaluated by the anonymous function instead.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Option Types
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Option Types</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">An <span class="Bold">option type</span> can hold two possible values:</span> <span class="Teletyped"><span lang="EN-US" style=''>Some(x)</span></span> <span lang="EN-US">or</span> <span class="Teletyped"><span lang="EN-US" style=''>None</span></span><span lang="EN-US">. Option types are frequently used to represent optional values in calculations, or to indicate whether a particular computation has succeeded or failed.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Using Option Types</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Let's say we have a function that divides two integers. Normally, we'd write the function as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let div x y = x / y</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This function works just fine, but it's not safe: it's possible to pass an invalid value into this function which results in a runtime error. Here is a demonstration in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let div x y = x / y;;<br>
				<br>
				val div : int -&gt; int -&gt; int<br>
				<br>
				&gt; div 10 5;;<br>
				val it : int = 2<br>
				<br>
				&gt; div 10 0;;<br>
				System.DivideByZeroException: Attempted to divide by zero.<br>
				&nbsp;&nbsp; at &lt;StartupCode$FSI_0035&gt;.$FSI_0035._main()<br>
				stopped due to error</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>div 10 5</span></span> <span lang="EN-US">executes just fine, but</span> <span class="Teletyped"><span lang="EN-US" style=''>div 10 0</span></span> <span lang="EN-US">throws a division by zero exception.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Using option types, we can return</span> <span class="Teletyped"><span lang="EN-US" style=''>Some(value)</span></span> <span lang="EN-US">on a successful calculation, or</span> <span class="Teletyped"><span lang="EN-US" style=''>None</span></span> <span lang="EN-US">if the calculation fails:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let safediv x y =<br>
				&nbsp;&nbsp;&nbsp; match y with<br>
				&nbsp;&nbsp;&nbsp; | 0 -&gt; None<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt; Some(x/y);;<br>
				<br>
				val safediv : int -&gt; int -&gt; int option<br>
				<br>
				&gt; safediv 10 5;;<br>
				val it : int option = Some 2<br>
				<br>
				&gt; safediv 10 0;;<br>
				val it : int option = None</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice an important difference between our</span> <span class="Teletyped"><span lang="EN-US" style=''>div</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>safediv</span></span> <span lang="EN-US">functions:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">val div : int -&gt; int -&gt; int<br>
				val safediv : int -&gt; int -&gt; int option</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>div</span></span> <span lang="EN-US">returns an</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span><span lang="EN-US">, while</span> <span class="Teletyped"><span lang="EN-US" style=''>safediv</span></span> <span lang="EN-US">returns an</span> <span class="Teletyped"><span lang="EN-US" style=''>int option</span></span><span lang="EN-US">. Since our</span> <span class="Teletyped"><span lang="EN-US" style=''>safediv</span></span> <span lang="EN-US">function returns a different data type, it informs clients of our function that the application has entered an invalid state.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Option types are conceptually similar to nullable types in languages like C#, however F# option types do not use the CLR</span> <span class="Teletyped"><span lang="EN-US" style=''>System.Nullable&lt;T&gt;</span></span> <span lang="EN-US">representation in IL due to differences in semantics.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Pattern Matching Option Types</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Pattern matching option types is as easy as creating them: the same syntax used to declare an option type is used to match option types:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let isFortyTwo = function<br>
				&nbsp;&nbsp;&nbsp; | Some(42) -&gt; true<br>
				&nbsp;&nbsp;&nbsp; | Some(_) | None -&gt; false;;<br>
				<br>
				val isFortyTwo : int option -&gt; bool<br>
				<br>
				&gt; isFortyTwo (Some(43));;<br>
				val it : bool = false<br>
				<br>
				&gt; isFortyTwo (Some(42));;<br>
				val it : bool = true<br>
				<br>
				&gt; isFortyTwo None;;<br>
				val it : bool = false</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Other Functions in the Option Module</span>
			</h2>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val get : 'a option -&gt; 'a</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Returns the value of a</span> <span class="Teletyped"><span lang="EN-US" style=''>Some</span></span> <span lang="EN-US">option.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val isNone : 'a option -&gt; bool</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Returns</span> <span class="Teletyped"><span lang="EN-US" style=''>true</span></span> <span lang="EN-US">for a</span> <span class="Teletyped"><span lang="EN-US" style=''>None</span></span> <span lang="EN-US">option,</span> <span class="Teletyped"><span lang="EN-US" style=''>false</span></span> <span lang="EN-US">otherwise.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val isSome : 'a option -&gt; bool</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Returns</span> <span class="Teletyped"><span lang="EN-US" style=''>true</span></span> <span lang="EN-US">for a</span> <span class="Teletyped"><span lang="EN-US" style=''>Some</span></span> <span lang="EN-US">option,</span> <span class="Teletyped"><span lang="EN-US" style=''>false</span></span> <span lang="EN-US">otherwise.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val map : ('a -&gt; 'b) -&gt; 'a option -&gt; 'b option</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Given</span> <span class="Teletyped"><span lang="EN-US" style=''>None</span></span><span lang="EN-US">, returns</span> <span class="Teletyped"><span lang="EN-US" style=''>None</span></span><span lang="EN-US">. Given</span> <span class="Teletyped"><span lang="EN-US" style=''>Some(x)</span></span><span lang="EN-US">, returns</span> <span class="Teletyped"><span lang="EN-US" style=''>Some(f x)</span></span><span lang="EN-US">, where</span> <span class="Teletyped"><span lang="EN-US" style=''>f</span></span> <span lang="EN-US">is the given mapping function.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val iter : ('a -&gt; unit) -&gt; 'a option -&gt; unit</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Applies the given function to the value of a</span> <span class="Teletyped"><span lang="EN-US" style=''>Some</span></span> <span lang="EN-US">option, does nothing otherwise.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Tuples and Records
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Tuples and Records</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Defining Tuples
			</h2>
			<p class="TextBody">
				<span lang="EN-US">A tuple (rhymes with "couple") is defined as a comma separated collection of values. For example,</span> <span class="Teletyped"><span lang="EN-US" style=''>(10, "hello")</span></span> <span lang="EN-US">is a 2-tuple with the type</span> <span class="Teletyped"><span lang="EN-US" style=''>(int * string)</span></span><span lang="EN-US">. Tuples are extremely useful for creating ad hoc data structures which group together related values.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let average (a, b) =<br>
				&nbsp;&nbsp;&nbsp; (a + b) / 2.0</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This function has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>float * float -&gt; float</span></span><span lang="EN-US">, it takes a</span> <span class="Teletyped"><span lang="EN-US" style=''>float * float</span></span> <span lang="EN-US">tuple and returns another</span> <span class="Teletyped"><span lang="EN-US" style=''>float</span></span><span lang="EN-US">.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let average (a, b) =<br>
				&nbsp;&nbsp;&nbsp; let sum = a + b<br>
				&nbsp;&nbsp;&nbsp; sum / 2.0;;<br>
				<br>
				val average : float * float -&gt; float<br>
				<br>
				&gt; average (10.0, 20.0);;<br>
				val it : float = 15.0</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice that a tuple is considered a single argument. As a result, tuples can be used to return multiple values:</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Example 1</span></span> <span lang="EN-US">- a function which multiples a 3-tuple by a scalar value to return another 3-tuple.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let scalarMultiply (s : float) (a, b, c) = (a * s, b * s, c * s);;<br>
				<br>
				val scalarMultiply : float -&gt; float * float * float -&gt; float * float * float<br>
				<br>
				&gt; scalarMultiply 5.0 (6.0, 10.0, 20.0);;<br>
				val it : float * float * float = (30.0, 50.0, 100.0)</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Example 2</span></span> <span lang="EN-US">- a function which reverses the input of whatever is passed into the function.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let swap (a, b) = (b, a);;<br>
				val swap : 'a * 'b -&gt; 'b * 'a<br>
				<br>
				&gt; swap ("Web", 2.0);;<br>
				val it : float * string = (2.0, "Web")<br>
				<br>
				&gt; swap (20, 30);;<br>
				val it : int * int = (30, 20)</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Example 3</span></span> <span lang="EN-US">- a function which divides two numbers and returns the remainder simultaneously.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let divrem x y =<br>
				&nbsp;&nbsp;&nbsp; match y with<br>
				&nbsp;&nbsp;&nbsp; | 0 -&gt; None<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt; Some(x / y, x % y);;<br>
				<br>
				val divrem : int -&gt; int -&gt; (int * int) option<br>
				<br>
				&gt; divrem 100 20;; (* 100 / 20 = 5 remainder 0 *)<br>
				val it : (int * int) option = Some (5, 0)<br>
				<br>
				&gt; divrem 6 4;; (* 6 / 4 = 1 remainder 2 *)<br>
				val it : (int * int) option = Some (1, 2)<br>
				<br>
				&gt; divrem 7 0;; (* 7 / 0 throws a DivisionByZero exception *)<br>
				val it : (int * int) option = None</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Every tuple has a property called <span class="Bold">arity</span>, which is the number of arguments used to define a tuple. For example, an</span> <span class="Teletyped"><span lang="EN-US" style=''>int * string</span></span> <span lang="EN-US">tuple is made up of two parts, so it has an arity of 2, a</span> <span class="Teletyped"><span lang="EN-US" style=''>string * string * float</span></span> <span lang="EN-US">has an arity of 3, and so on.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Pattern Matching Tuples</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Pattern matching on tuples is easy, because the same syntax used to declare tuple types is also used to match tuples.</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Example 1</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Let's say that we have a function</span> <span class="Teletyped"><span lang="EN-US" style=''>greeting</span></span> <span lang="EN-US">that prints out a custom greeting based on the specified name and/or language.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let greeting (name, language) =<br>
				&nbsp;&nbsp;&nbsp; match (name, language) with<br>
				&nbsp;&nbsp;&nbsp; | ("Steve", _) -&gt; "Howdy, Steve"<br>
				&nbsp;&nbsp;&nbsp; | (name, "English") -&gt; "Hello, " + name<br>
				&nbsp;&nbsp;&nbsp; | (name, _) when language.StartsWith("Span") -&gt; "Hola, " + name<br>
				&nbsp;&nbsp;&nbsp; | (_, "French") -&gt; "Bonjour!"<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt; "DOES NOT COMPUTE"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This function has type</span> <span class="Teletyped"><span lang="EN-US" style=''>string * string -&gt; string</span></span><span lang="EN-US">, meaning that it takes a 2-tuple and returns a string. We can test this function in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; greeting ("Steve", "English");;<br>
				val it : string = "Howdy, Steve"<br>
				&gt; greeting ("Pierre", "French");;<br>
				val it : string = "Bonjour!"<br>
				&gt; greeting ("Maria", "Spanish");;<br>
				val it : string = "Hola, Maria"<br>
				&gt; greeting ("Rocko", "Esperanto");;<br>
				val it : string = "DOES NOT COMPUTE"</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Example 2</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can conveniently match against the <em>shape</em> of a tuple using the alternative pattern matching syntax:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let getLocation = function<br>
				&nbsp;&nbsp;&nbsp; | (0, 0) -&gt; "origin"<br>
				&nbsp;&nbsp;&nbsp; | (0, y) -&gt; "on the y-axis at y=" + y.ToString()<br>
				&nbsp;&nbsp;&nbsp; | (x, 0) -&gt; "on the x-axis at x=" + x.ToString()<br>
				&nbsp;&nbsp;&nbsp; | (x, y) -&gt; "at x=" + x.ToString() + ", y=" + y.ToString() ;;<br>
				<br>
				val getLocation : int * int -&gt; string<br>
				<br>
				&gt; getLocation (0, 0);;<br>
				val it : string = "origin"<br>
				&gt; getLocation (0, -1);;<br>
				val it : string = "on the y-axis at y=-1"<br>
				&gt; getLocation (5, -10);;<br>
				val it : string = "at x=5, y=-10"<br>
				&gt; getLocation (7, 0);;<br>
				val it : string = "on the x-axis at x=7"</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">fst and snd</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">F# has two built-in functions,</span> <span class="Teletyped"><span lang="EN-US" style=''>fst</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>snd</span></span><span lang="EN-US">, which return the first and second items in a 2-tuple. These functions are defined as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let fst (a, b) = a<br>
				let snd (a, b) = b</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">They have the following types:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">val fst : 'a * 'b -&gt; 'a<br>
				val snd : 'a * 'b -&gt; 'b</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here are a few examples in FSI:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; fst (1, 10);;<br>
				val it : int = 1<br>
				&gt; snd (1, 10);;<br>
				val it : int = 10<br>
				&gt; fst ("hello", "world");;<br>
				val it : string = "hello"<br>
				&gt; snd ("hello", "world");;<br>
				val it : string = "world"<br>
				&gt; fst ("Web", 2.0);;<br>
				val it : string = "Web"<br>
				&gt; snd (50, 100);;<br>
				val it : int = 100</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Assigning Multiple Variables Simultaneously</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Tuples can be used to assign multiple values simultaneously. The syntax for doing so is:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let val1, val2, ... valN = (expr1, expr2, ... exprN)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In other words, you assign a comma-separated list of <em>N</em> values to an <em>N</em>-tuple. Here's an example in FSI:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let x, y = (1, 2);;<br>
				<br>
				val y : int<br>
				val x : int<br>
				<br>
				&gt; x;;<br>
				val it : int = 1<br>
				<br>
				&gt; y;;<br>
				val it : int = 2</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The number of values being assigned must match the arity of tuple returned from the function, otherwise F# will raise an exception:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let x, y = (1, 2, 3);;<br>
				<br>
				&nbsp; let x, y = (1, 2, 3);;<br>
				&nbsp; ------------^^^^^^^^<br>
				<br>
				stdin(18,13): error FS0001: Type mismatch. Expecting a<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'a * 'b<br>
				but given a<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'a * 'b * 'c.<br>
				The tuples have differing lengths of 2 and 3.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Tuples and the .NET Framework</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">From a point of view F#, all methods in the .NET Base Class Library take a single argument, which is a tuple of varying types and arity. For example:</span>
			</p>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Class</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">C# Function Signature</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# Function Signature</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.String</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>String Join(String separator, String[] value)</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>val Join : (string * string array) -&gt; string</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Net.WebClient</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>void DownloadFile(String uri, String fileName)</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>val DownloadFile : (string * string) -&gt; unit</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Convert</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>String ToString(int value, int toBase)</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>val ToString : (int * int) -&gt; string</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Math</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>int DivRem(int a, int b, out int remainder)</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>val DivRem : (int * int * int byref) -&gt; int</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Int32</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>bool TryParse(String value, out int result)</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>val TryParse : (string * int byref) -&gt; bool</span></span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">Some methods, such as the</span> <span class="Teletyped"><span lang="EN-US" style=''>System.Math.DivRem</span></span> <span lang="EN-US">shown above, and others such as</span> <span class="Teletyped"><span lang="EN-US" style=''>System.Int32.TryParse</span></span> <span lang="EN-US">return multiple through <em>output variables</em>. F# allows programmers to omit an output variable; using this calling convention, F# will return results of a function as a tuple, for example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; System.Int32.TryParse("3");;<br>
				val it : bool * int = (true, 3)<br>
				<br>
				&gt; System.Math.DivRem(10, 7);;<br>
				val it : int * int = (1, 3)</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Defining Records</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">A record is similar to a tuple, except it contains named fields. A record is defined using the syntax:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type recordName =<br>
				&nbsp;&nbsp;&nbsp; { [ fieldName : dataType ] + }</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Teletyped"><span lang="EN-US" style=''>+</span></span> <span lang="EN-US">means the element must occur one or more times.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here's a simple record:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type website =<br>
				&nbsp;&nbsp;&nbsp; { Title : string;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Url : string }</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Unlike a tuple, a record is explicitly defined as its own type using the</span> <span class="Teletyped"><span lang="EN-US" style=''>type</span></span> <span lang="EN-US">keyword, and record fields are defined as a semicolon-separated list. (In many ways, a record can be thought of as a simple <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Classes"><span style='color:windowtext;text-decoration:none'>class</span></a>.)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">A</span> <span class="Teletyped"><span lang="EN-US" style=''>website</span></span><span lang="EN-US">record is created by specifying the record's fields as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let homepage = { Title = "Google"; Url = "http://www.google.com" };;<br>
				val homepage : website</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Note that F# determines a records type by the name and type of its fields, not the order that fields are used. For example, while the record above is defined with</span> <span class="Teletyped"><span lang="EN-US" style=''>Title</span></span> <span lang="EN-US">first and</span> <span class="Teletyped"><span lang="EN-US" style=''>Url</span></span> <span lang="EN-US">second, it's perfectly legitimate to write:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; { Url = "http://www.microsoft.com/"; Title = "Microsoft Corporation" };;<br>
				val it : website = {Title = "Microsoft Corporation";<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Url = "http://www.microsoft.com/";}</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">It's easy to access a record's properties using dot notation:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let homepage = { Title = "Wikibooks"; Url = "http://www.wikibooks.org/" };;<br>
				<br>
				val homepage : website<br>
				<br>
				&gt; homepage.Title;;<br>
				val it : string = "Wikibooks"<br>
				<br>
				&gt; homepage.Url;;<br>
				val it : string = "http://www.wikibooks.org/"</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Cloning Records</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Records are immutable types, which means that instances of records cannot be modified. However, records can be cloned conveniently using the clone syntax:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type coords = { X : float; Y : float }<br>
				<br>
				let setX item newX =<br>
				&nbsp;&nbsp;&nbsp; { item with X = newX }</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The method</span> <span class="Teletyped"><span lang="EN-US" style=''>setX</span></span> <span lang="EN-US">has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>coords -&gt; float -&gt; coords</span></span><span lang="EN-US">. The</span> <span class="Teletyped"><span lang="EN-US" style=''>with</span></span> <span lang="EN-US">keyword creates a clone of</span> <span class="Teletyped"><span lang="EN-US" style=''>item</span></span> <span lang="EN-US">and set its</span> <span class="Teletyped"><span lang="EN-US" style=''>X</span></span> <span lang="EN-US">property to</span> <span class="Teletyped"><span lang="EN-US" style=''>newX</span></span><span lang="EN-US">.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let start = { X = 1.0; Y = 2.0 };;<br>
				val start : coords<br>
				<br>
				&gt; let finish = setX start 15.5;;<br>
				val finish : coords<br>
				<br>
				&gt; start;;<br>
				val it : coords = {X = 1.0;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y = 2.0;}<br>
				&gt; finish;;<br>
				val it : coords = {X = 15.5;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y = 2.0;}</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice that the</span> <span class="Teletyped"><span lang="EN-US" style=''>setX</span></span> <span lang="EN-US">creates a copy of the record, it doesn't actually mutate the original record instance.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here's a more complete program:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type TransactionItem =<br>
				&nbsp;&nbsp;&nbsp; { Name : string;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID : int;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessedText : string;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsProcessed : bool }<br>
				<br>
				let getItem name id =<br>
				&nbsp;&nbsp;&nbsp; { Name = name; ID = id; ProcessedText = null; IsProcessed = false }<br>
				<br>
				let processItem item =<br>
				&nbsp;&nbsp;&nbsp; { item with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;ProcessedText = "Done";<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsProcessed = true }<br>
				&nbsp;&nbsp;&nbsp;<br>
				let printItem msg item =<br>
				&nbsp;&nbsp;&nbsp; printfn "%s: %A" msg item&nbsp;&nbsp;<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let preProcessedItem = getItem "Steve" 5<br>
				&nbsp;&nbsp;&nbsp; let postProcessedItem = processItem preProcessedItem<br>
				<br>
				&nbsp;&nbsp;&nbsp; printItem "preProcessed" preProcessedItem<br>
				&nbsp;&nbsp;&nbsp; printItem "postProcessed" postProcessedItem<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program processes an instance of the</span> <span class="Teletyped"><span lang="EN-US" style=''>TransactionItem</span></span> <span lang="EN-US">class and prints the results. This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">preProcessed: {Name = "Steve"; ID = 5; ProcessedText = null; IsProcessed = false;}postProcessed: {Name = "Steve"; ID = 5; ProcessedText = "Done"; IsProcessed = true;}</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Pattern Matching Records</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">We can pattern match on records just as easily as tuples:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				type coords = { X : float; Y : float }<br>
				&nbsp;<br>
				let getQuadrant = function<br>
				&nbsp;&nbsp;&nbsp; | { X = 0.0; Y = 0.0 } -&gt; "Origin"<br>
				&nbsp;&nbsp;&nbsp; | item when item.X &gt;= 0.0 &amp;&amp; item.Y &gt;= 0.0 -&gt; "I"<br>
				&nbsp;&nbsp;&nbsp; | item when item.X &lt;= 0.0 &amp;&amp; item.Y &gt;= 0.0 -&gt; "II"<br>
				&nbsp;&nbsp;&nbsp; | item when item.X &lt;= 0.0 &amp;&amp; item.Y &lt;= 0.0 -&gt; "III"<br>
				&nbsp;&nbsp;&nbsp; | item when item.X &gt;= 0.0 &amp;&amp; item.Y &lt;= 0.0 -&gt; "IV"<br>
				&nbsp;<br>
				let testCoords (x, y) =<br>
				&nbsp;&nbsp;&nbsp; let item = { X = x; Y = y }<br>
				&nbsp;&nbsp;&nbsp; printfn "(%f, %f) is in quadrant %s" x y (getQuadrant item)<br>
				&nbsp;<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; testCoords(0.0, 0.0)<br>
				&nbsp;&nbsp;&nbsp; testCoords(1.0, 1.0)<br>
				&nbsp;&nbsp;&nbsp; testCoords(-1.0, 1.0)<br>
				&nbsp;&nbsp;&nbsp; testCoords(-1.0, -1.0)<br>
				&nbsp;&nbsp;&nbsp; testCoords(1.0, -1.0)<br>
				&nbsp;&nbsp;&nbsp; Console.ReadKey(true) |&gt; ignore<br>
				&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Note that pattern cases are defined with the same syntax used to create a record (as shown in the first case), or using guards (as shown in the remaining cases). Unfortunately, programmers cannot use the clone syntax in pattern cases, so a case such as</span> <span class="Teletyped"><span lang="EN-US" style=''>| { item with X = 0 } -&gt; "y-axis"</span></span> <span lang="EN-US">will not compile.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The program above outputs:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">(0.000000, 0.000000) is in quadrant Origin(1.000000, 1.000000) is in quadrant I(-1.000000, 1.000000) is in quadrant II(-1.000000, -1.000000) is in quadrant III(1.000000, -1.000000) is in quadrant IV</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Lists
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Lists</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">A <span class="Bold">list</span> is an ordered collection of related values, and is roughly equivalent to a linked list data structure used in many other languages. F# provides a module,</span> <span class="Teletyped"><span lang="EN-US" style=''>Microsoft.FSharp.Collections.List</span></span><span lang="EN-US">, for common operations on lists; this module is imported automatically by F#, so the</span> <span class="Teletyped"><span lang="EN-US" style=''>List</span></span> <span lang="EN-US">module is already accessible from every F# application.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Creating Lists</span>
			</h2>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Using List Literals</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">There are a variety of ways to create lists in F#, the most straightforward method being a semicolon-delimited sequence of values. Here's a list of numbers in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let numbers = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10];;<br>
				val numbers : int list<br>
				<br>
				&gt; numbers;;<br>
				val it : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice that all values in a list must have the same type:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; [1; 2; 3; 4; "cat"; 6; 7];;<br>
				<br>
				&nbsp; -------------^^^^^^<br>
				<br>
				stdin(120,14): error FS0001: This expression has type<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string<br>
				but is here used with type<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Using the :: ("cons") Operator</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">It is very common to build lists up by prepending or consing a value to an existing list using the</span> <span class="Teletyped"><span lang="EN-US" style=''>::</span></span> <span lang="EN-US">operator:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; 1 :: 2 :: 3 :: [];;<br>
				val it : int list = [1; 2; 3]
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <em><span lang="EN-US">Note</span></em><span lang="EN-US">: the</span> <span class="Teletyped"><span lang="EN-US" style=''>[]</span></span> <span lang="EN-US">is an empty list. By itself, it has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>'T list</span></span><span lang="EN-US">; since its used with</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span><span lang="EN-US">s, it has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>int list</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>::</span></span> <span lang="EN-US">operator prepends items to a list, returning a new list. It is a right-associative operator with the following type:</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Teletyped"><span style=''>val inline (::) : 'T -&gt; 'T list -&gt; 'T list</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This operator does not actually mutate lists, it creates an entirely new list with the prepended element in the front. Here's an example in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let x = 1 :: 2 :: 3 :: 4 :: [];;<br>
				val x : int list<br>
				<br>
				&gt; let y = 12 :: x;;<br>
				val y : int list<br>
				<br>
				&gt; x;;<br>
				val it : int list = [1; 2; 3; 4]<br>
				<br>
				&gt; y;;<br>
				val it : int list = [12; 1; 2; 3; 4]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Consing creates a new list, reusing nodes from the old list, so consing a list is an O(n) operation and should not be used in deep recursive calls or long loops.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Using List.init</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>List</span></span> <span lang="EN-US">module contains a useful method,</span> <span class="Teletyped"><span lang="EN-US" style=''>List.init</span></span><span lang="EN-US">, which has the type</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Teletyped"><span style=''>val init : int -&gt; (int -&gt; 'T) -&gt; 'T list</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The first argument is the desired length of the new list, and the second argument is an initializer function which generates items in the list.</span> <span class="Teletyped"><span lang="EN-US" style=''>List.init</span></span> <span lang="EN-US">is used as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; List.init 5 (fun index -&gt; index * 3);;<br>
				val it : int list = [0; 3; 6; 9; 12]<br>
				<br>
				&gt; List.init 5 (fun index -&gt; (index, index * index, index * index * index));;<br>
				val it : (int * int * int) list<br>
				= [(0, 0, 0); (1, 1, 1); (2, 4, 8); (3, 9, 27); (4, 16, 64)]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">F# calls the initializer function</span> <span class="Teletyped"><span lang="EN-US" style=''>5</span></span> <span lang="EN-US">times with the index of each item in the list, starting at index</span> <span class="Teletyped"><span lang="EN-US" style=''>0</span></span><span lang="EN-US">.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Using List Comprehensions</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">List comprehensions refers to special syntactic constructs in some languages used for generating lists. F# has an expressive list comprehension syntax, which comes in two forms, ranges and generators.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Ranges have the constructs</span> <span class="Teletyped"><span lang="EN-US" style=''>[start .. end]</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>[start .. step .. end]</span></span><span lang="EN-US">. For example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; [1 .. 10];;<br>
				val it : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]<br>
				<br>
				&gt; [1 .. 2 .. 10];;<br>
				val it : int list = [1; 3; 5; 7; 9]<br>
				<br>
				&gt; ['a' .. 's'];;<br>
				val it : char list<br>
				= ['a'; 'b'; 'c'; 'd'; 'e'; 'f'; 'g'; 'h'; 'i'; 'j'; 'k'; 'l'; 'm'; 'n'; 'o';<br>
				&nbsp;&nbsp; 'p'; 'q'; 'r'; 's']</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Generators have the construct</span> <span class="Teletyped"><span lang="EN-US" style=''>[for x in collection do ... yield expr]</span></span><span lang="EN-US">, and they are much more flexible than ranges. For example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; [ for a in 1 .. 10 do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield (a * a) ];;<br>
				val it : int list = [1; 4; 9; 16; 25; 36; 49; 64; 81; 100]<br>
				<br>
				&gt; [ for a in 1 .. 3 do<br>
				&nbsp;&nbsp;&nbsp; for b in 3 .. 7 do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield (a, b) ];;<br>
				val it : (int * int) list<br>
				= [(1, 3); (1, 4); (1, 5); (1, 6); (1, 7); (2, 3); (2, 4); (2, 5); (2, 6);<br>
				&nbsp;&nbsp; (2, 7); (3, 3); (3, 4); (3, 5); (3, 6); (3, 7)]<br>
				<br>
				&gt; [ for a in 1 .. 100 do<br>
				&nbsp;&nbsp;&nbsp; if a % 3 = 0 &amp;&amp; a % 5 = 0 then yield a];;<br>
				val it : int list = [15; 30; 45; 60; 75; 90]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Its possible to loop over any collection, not just numbers. This example loops over a</span> <span class="Teletyped"><span lang="EN-US" style=''>char list</span></span><span lang="EN-US">:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let x = [ 'a' .. 'f' ];;<br>
				<br>
				val x : char list<br>
				<br>
				&gt; [for a in x do yield [a; a; a] ];;<br>
				val it : char list list<br>
				= [['a'; 'a'; 'a']; ['b'; 'b'; 'b']; ['c'; 'c'; 'c']; ['d'; 'd'; 'd'];<br>
				&nbsp;&nbsp; ['e'; 'e'; 'e']; ['f'; 'f'; 'f']]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Note that the</span> <span class="Teletyped"><span lang="EN-US" style=''>yield</span></span><span lang="EN-US">keyword pushes a single value into a list. Another keyword,</span> <span class="Teletyped"><span lang="EN-US" style=''>yield!</span></span><span lang="EN-US">, pushes a collection of values into the list. The</span> <span class="Teletyped"><span lang="EN-US" style=''>yield!</span></span> <span lang="EN-US">keyword is used as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; [for a in 1 .. 5 do<br>
				&nbsp;&nbsp;&nbsp; yield! [ a .. a + 3 ] ];;<br>
				val it : int list<br>
				= [1; 2; 3; 4; 2; 3; 4; 5; 3; 4; 5; 6; 4; 5; 6; 7; 5; 6; 7; 8]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Its possible to mix the</span> <span class="Teletyped"><span lang="EN-US" style=''>yield</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>yield!</span></span> <span lang="EN-US">keywords:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; [for a in 1 .. 5 do<br>
				&nbsp;&nbsp;&nbsp; match a with<br>
				&nbsp;&nbsp;&nbsp; | 3 -&gt; yield! ["hello"; "world"]<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt; yield a.ToString() ];;<br>
				val it : string list = ["1"; "2"; "hello"; "world"; "4"; "5"]</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h4 class="Heading3">
				<span lang="EN-US">Alternative List Comprehension Syntax</span>
			</h4>
			<p class="TextBody">
				<span lang="EN-US">The samples above use the</span> <span class="Teletyped"><span lang="EN-US" style=''>yield</span></span> <span lang="EN-US">keyword explicitly, however F# provides a slightly different arrow-based syntax for list comprehensions:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; [ for a in 1 .. 5 -&gt; a * a];;<br>
				val it : int list = [1; 4; 9; 16; 25]<br>
				<br>
				&gt; [ for a in 1 .. 5 do<br>
				&nbsp;&nbsp;&nbsp; for b in 1 .. 3 -&gt; a, b];;<br>
				val it : (int * int) list<br>
				= [(1, 1); (1, 2); (1, 3); (2, 1); (2, 2); (2, 3); (3, 1); (3, 2); (3, 3);<br>
				&nbsp;&nbsp; (4, 1); (4, 2); (4, 3); (5, 1); (5, 2); (5, 3)]<br>
				<br>
				&gt; [ for a in 1 .. 5 -&gt;&gt; [1 .. 3] ];;<br>
				val it : int list = [1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3]</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>-&gt;</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>-&gt;&gt;</span></span> <span lang="EN-US">are equivalent to the</span> <span class="Teletyped"><span lang="EN-US" style=''>yield</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>yield!</span></span> <span lang="EN-US">operators respectively. While its still common to see list comprehensions expressed using</span> <span class="Teletyped"><span lang="EN-US" style=''>-&gt;</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>-&gt;&gt;</span></span><span lang="EN-US">, those constructs will not be emphasized in this book since they have been deprecated in favor of</span> <span class="Teletyped"><span lang="EN-US" style=''>yield</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>yield!</span></span><span lang="EN-US">.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Pattern Matching Lists</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">You use the same syntax to match against lists that you use to create lists. Here's a simple program:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let rec sum total = function<br>
				&nbsp;&nbsp;&nbsp; | [] -&gt; total<br>
				&nbsp;&nbsp;&nbsp; | hd :: tl -&gt; sum (hd + total) tl<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let numbers = [ 1 .. 5 ]<br>
				&nbsp;&nbsp;&nbsp; let sumOfNumbers = sum 0 numbers<br>
				&nbsp;&nbsp;&nbsp; printfn "sumOfNumbers: %i" sumOfNumbers<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>sum</span></span> <span lang="EN-US">method has the type</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>val sum : int -&gt; int list -&gt; int</span></span><span lang="EN-US">. It recursively enumerates through the list, adding each item in the list to the value</span> <span class="Teletyped"><span lang="EN-US" style=''>total</span></span><span lang="EN-US">. Step by step, the function works as follows:</span>
			</p>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">total</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">input</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">hd :: tl</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">sum (hd + total) tl</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">0</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[1; 2; 3; 4; 5]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">1 :: [2; 3; 4; 5]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">sum (1 + 0 = 1) [2; 3; 4; 5]</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">1</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[2; 3; 4; 5]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">2 :: [3; 4; 5]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">sum (2 + 1 = 3) [3; 4; 5]</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">3</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[3; 4; 5]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">3 :: [4; 5]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">sum (3 + 3 = 6) [4; 5]</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">6</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[4; 5]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">4 :: [5]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">sum (4 + 6 = 10) [5]</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">10</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[5]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">5 :: []</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">sum (5 + 10 = 15) []</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">15</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">n/a</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">returns total</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Reverse A List
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Frequently, we use recursion and pattern matching to generate new lists from existing lists. A simple example is reversing a list:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let reverse l =<br>
				&nbsp;&nbsp;&nbsp; let rec loop acc = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | [] -&gt; acc<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | hd :: tl -&gt; loop (hd :: acc) tl<br>
				&nbsp;&nbsp;&nbsp; loop [] l</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <em><span lang="EN-US">Note to beginners:</span></em> <span lang="EN-US">the pattern seen above is very common. Often, when we iterate through lists, we want to build up a new list. To do this recursively, we use an <em>accumulating parameter</em> (which is called</span> <span class="Teletyped"><span lang="EN-US" style=''>acc</span></span> <span lang="EN-US">above) which holds our new list as we generate it. Its also very common to use a nested function, usually named</span> <span class="Teletyped"><span lang="EN-US" style=''>innerXXXXX</span></span><span lang="EN-US">or</span> <span class="Teletyped"><span lang="EN-US" style=''>loop</span></span><span lang="EN-US">, to hide the implementation details of the function from clients (in other words, clients should not have to pass in their own accumulating parameter).</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>reverse</span></span> <span lang="EN-US">has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>val reverse : 'a list -&gt; 'a list</span></span><span lang="EN-US">. You'd use this function as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; reverse [1 .. 5];;<br>
				val it : int list = [5; 4; 3; 2; 1]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This simple function works because items are always prepended to the accumulating parameter</span> <span class="Teletyped"><span lang="EN-US" style=''>acc</span></span><span lang="EN-US">, resulting in series of recursive calls as follows:</span>
			</p>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">acc</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">input</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">loop (hd :: acc) tl</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[1; 2; 3; 4; 5]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">loop (1 :: []) [2; 3; 4; 5]</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[1]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[2; 3; 4; 5]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">loop (2 :: [1]) [3; 4; 5]</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[2; 1]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[3; 4; 5]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">loop (3 :: [2; 1]) [4; 5]</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[3; 2; 1]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[4; 5]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">loop (4 :: [3; 2; 1]) [5]</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[4; 3; 2; 1]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[5]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">loop (5 :: [4; 3; 2; 1]) []</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[5; 4; 3; 2; 1]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">[]</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">returns acc</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>List.rev</span></span> <span lang="EN-US">is a built-in function for reversing a list:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; List.rev [1 .. 5];;<br>
				val it : int list = [5; 4; 3; 2; 1]</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Filter A List</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Oftentimes, we want to filter a list for certain values. We can write a filter function as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let rec filter predicate = function<br>
				&nbsp;&nbsp;&nbsp; | [] -&gt; []<br>
				&nbsp;&nbsp;&nbsp; | hd :: tl -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match predicate hd with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | true -&gt; hd::filter predicate tl<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | false -&gt; filter predicate tl<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let filteredNumbers = [1 .. 10] |&gt; filter (fun x -&gt; x % 2 = 0)<br>
				&nbsp;&nbsp;&nbsp; printfn "filteredNumbers: %A" filteredNumbers<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>filter</span></span><span lang="EN-US">method has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>val filter : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list</span></span><span lang="EN-US">. The program above outputs:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">filteredNumbers: [2; 4; 6; 8; 10]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can make the</span> <span class="Teletyped"><span lang="EN-US" style=''>filter</span></span> <span lang="EN-US">above tail-recursive with a slight modification:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let filter predicate l =<br>
				&nbsp;&nbsp;&nbsp; let rec loop acc = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | [] -&gt; acc<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | hd :: tl -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match predicate hd with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | true -&gt; loop (hd :: acc) tl<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | false -&gt; loop (acc) tl<br>
				&nbsp;&nbsp;&nbsp; List.rev (loop [] l)</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <em><span lang="EN-US">Note:</span></em> <span lang="EN-US">Since accumulating parameters often build up lists in reverse order, its very common to see</span> <span class="Teletyped"><span lang="EN-US" style=''>List.rev</span></span> <span lang="EN-US">called immediately before returning a list from a function to put it in correct order.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Mapping Lists</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">We can write a function which maps a list to another list:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let rec map converter = function<br>
				&nbsp;&nbsp;&nbsp; | [] -&gt; []<br>
				&nbsp;&nbsp;&nbsp; | hd :: tl -&gt; converter hd::map converter tl<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let mappedNumbers = [1 .. 10] |&gt; map ( fun x -&gt; (x * x).ToString() )<br>
				&nbsp;&nbsp;&nbsp; printfn "mappedNumbers: %A" mappedNumbers<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>map</span></span> <span lang="EN-US">has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list</span></span><span lang="EN-US">. The program above outputs:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">mappedNumbers: ["1"; "4"; "9"; "16"; "25"; "36"; "49"; "64"; "81"; "100"]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">A tail-recursive map function can be written as:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let map converter l =<br>
				&nbsp;&nbsp;&nbsp; let rec loop acc = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | [] -&gt; acc<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | hd :: tl -&gt; loop (converter hd :: acc) tl<br>
				&nbsp;&nbsp;&nbsp; List.rev (loop [] l)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Like the example above, we use the accumulating-param-and-reverse pattern to make the function tail recursive.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Using the List Module</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Although a reverse, filter, and map method were implemented above, its much more convenient to use F#'s built-in functions:</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>List.rev</span></span> <span lang="EN-US">reverses a list:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; List.rev [1 .. 5];;<br>
				val it : int list = [5; 4; 3; 2; 1]</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>List.filter</span></span> <span lang="EN-US">filters a list:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; [1 .. 10] |&gt; List.filter (fun x -&gt; x % 2 = 0);;<br>
				val it : int list = [2; 4; 6; 8; 10]</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>List.map</span></span> <span lang="EN-US">maps a list from one type to another:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; [1 .. 10] |&gt; List.map (fun x -&gt; (x * x).ToString());;<br>
				val it : string list<br>
				= ["1"; "4"; "9"; "16"; "25"; "36"; "49"; "64"; "81"; "100"]</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">List.append and the @ Operator</span>
			</h3>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>List.append</span></span> <span lang="EN-US">has the type:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				val append : 'T list -&gt; 'T list -&gt; 'T list
			</p>
			<p class="TextBody">
				<span lang="EN-US">As you can imagine, the</span> <span class="Teletyped"><span lang="EN-US" style=''>append</span></span> <span lang="EN-US">functions appends one list to another. The</span> <span class="Teletyped"><span lang="EN-US" style=''>@</span></span> <span lang="EN-US">operator is an infix operator which performs the same function:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let first&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = [1; 2; 3;]<br>
				let second&nbsp;&nbsp;&nbsp;&nbsp; = [4; 5; 6;]<br>
				let combined1&nbsp; = first @ second&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* returns [1; 2; 3; 4; 5; 6] *)<br>
				let combined2&nbsp; = List.append first second (* returns [1; 2; 3; 4; 5; 6] *)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Since lists are immutable, appending two lists together requires copying all of the elements of the lists to create a brand new list. However, since lists are immutable, its only necessary to copy the elements of the first list; the second list does not need to be copied. Represented in memory, appending two lists can be diagrammed as follows:</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We start with the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">first = 1 :: 2 :: 3 :: []&nbsp;&nbsp; second = 4 :: 5 :: 6 :: []</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Appending the two lists,</span> <span class="Teletyped"><span lang="EN-US" style=''>first @ second</span></span><span lang="EN-US">, results in the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">first = 1 :: 2 :: 3 :: []&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \______&nbsp; ______/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; combined = 1 :: 2 :: 3 :: second&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (copied)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In other words, F# prepends a copy of</span> <span class="Teletyped"><span lang="EN-US" style=''>first</span></span> <span lang="EN-US">to</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>second</span></span> <span lang="EN-US">to create the</span> <span class="Teletyped"><span lang="EN-US" style=''>combined</span></span> <span lang="EN-US">list. This hypothesis can be verified using the following in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let first = [1; 2; 3;]<br>
				let second = [4; 5; 6;]<br>
				let combined = first @ second<br>
				let secondHalf = List.tail (List.tail (List.tail combined));;<br>
				<br>
				val first : int list<br>
				val second : int list<br>
				val combined : int list<br>
				val secondHalf : int list<br>
				<br>
				&gt; System.Object.ReferenceEquals(second, secondHalf);;<br>
				val it : bool = true</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The two lists</span> <span class="Teletyped"><span lang="EN-US" style=''>second</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>secondHalf</span></span> <span lang="EN-US">are literally the same object in memory, meaning F# reused the nodes from</span> <span class="Teletyped"><span lang="EN-US" style=''>second</span></span> <span lang="EN-US">when constructing the new list</span> <span class="Teletyped"><span lang="EN-US" style=''>combined</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Appending two lists,</span> <span class="Teletyped"><span lang="EN-US" style=''>list1</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>list2</span></span> <span lang="EN-US">has a space and time complexity of O(list1.Length).</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">List.choose</span>
			</h3>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>List.choose</span></span> <span lang="EN-US">has the following definition:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				val choose : ('T -&gt; 'U option) -&gt; 'T list -&gt; 'U list
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>choose</span></span><span lang="EN-US">method is clever because it filters and maps a list simultaneously:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; [1 .. 10] |&gt; List.choose (fun x -&gt;<br>
				&nbsp;&nbsp;&nbsp; match x % 2 with<br>
				&nbsp;&nbsp;&nbsp; | 0 -&gt; Some(x, x*x, x*x*x)<br>
				&nbsp; &nbsp;&nbsp;| _ -&gt; None);;<br>
				val it : (int * int * int) list<br>
				= [(2, 4, 8); (4, 16, 64); (6, 36, 216); (8, 64, 512); (10, 100, 1000)]</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>choose</span></span> <span lang="EN-US">filters for items that return</span> <span class="Teletyped"><span lang="EN-US" style=''>Some</span></span> <span lang="EN-US">and maps them to another value in a single step.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">List.fold and List.foldBack</span>
			</h3>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>List.fold</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>List.foldBack</span></span> <span lang="EN-US">have the following definitions:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">val fold : ('State -&gt; 'T -&gt; 'State) -&gt; 'State -&gt; 'T list -&gt; 'State<br>
				val foldBack : ('T -&gt; 'State -&gt; 'State) -&gt; 'T list -&gt; 'State -&gt; 'State</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">A "fold" operation applies a function to each element in a list, aggregates the result of the function in an accumulator variable, and returns the accumulator as the result of the fold operation. This description makes fold operations sound more complicated, but the implementation is actually very simple:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">(* List.fold implementation *)<br>
				let rec fold (f : 'State -&gt; 'T -&gt; 'State) (seed : 'State) = function<br>
				&nbsp;&nbsp;&nbsp; | [] -&gt; seed<br>
				&nbsp;&nbsp;&nbsp; | hd :: tl -&gt; fold f (f seed hd) tl<br>
				&nbsp;&nbsp;&nbsp;<br>
				(* List.foldBack implementation *)<br>
				let rec foldBack (f : 'T -&gt; 'State -&gt; 'State) (items : 'T list) (seed : 'State) =<br>
				&nbsp;&nbsp;&nbsp; match items with<br>
				&nbsp;&nbsp;&nbsp; | [] -&gt; seed<br>
				&nbsp;&nbsp;&nbsp; | hd :: tl -&gt; f hd (foldBack f tl seed)</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>fold</span></span> <span lang="EN-US">applies a function to each element in the from left to right, while</span> <span class="Teletyped"><span lang="EN-US" style=''>foldBack</span></span> <span lang="EN-US">applies a function to each element from right to left. Let's examine the fold functions in more technical detail using the following example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let input = [ 2; 4; 6; 8; 10 ]<br>
				let f accumulator input = accumulator * input<br>
				let seed = 1<br>
				let output = List.fold f seed input</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The value of</span> <span class="Teletyped"><span lang="EN-US" style=''>output</span></span> <span lang="EN-US">is</span> <span class="Teletyped"><span lang="EN-US" style=''>3840</span></span><span lang="EN-US">. This table demonstrates how</span> <span class="Teletyped"><span lang="EN-US" style=''>output</span></span> <span lang="EN-US">was calculated:</span>
			</p>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">accumulator</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">input</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">f accumulator input = accumulator * input</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">1 (seed)</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">2</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">1 * 2 = 2</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">2</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">4</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">2 * 4 = 8</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">8</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">6</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">8 * 6 = 48</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">48</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">8</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">48 * 8 = 384</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">384</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">10</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">384 * 10 = 3840 (return value)</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>List.fold</span></span> <span lang="EN-US">passes an accumulator with an item from the list into a function. The output of the function is passed as the accumulator for the next item.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">As shown above, the</span> <span class="Teletyped"><span lang="EN-US" style=''>fold</span></span> <span lang="EN-US">function processes the list from the first item to the last item in the list, or left to right. As you can imagine,</span> <span class="Teletyped"><span lang="EN-US" style=''>List.foldBack</span></span> <span lang="EN-US">works the same way, but it operates on lists from right to left. Given a fold function</span> <span class="Teletyped"><span lang="EN-US" style=''>f</span></span> <span lang="EN-US">and a list</span> <span class="Teletyped"><span lang="EN-US" style=''>[1; 2; 3; 4; 5]</span></span><span lang="EN-US">, the fold methods transform our lists in the following ways:</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Teletyped"><span lang="EN-US" style=''>fold</span></span><span lang="EN-US">:</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>f (f (f (f (f (f seed 1) 2) 3) 4) 5</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Teletyped"><span lang="EN-US" style=''>foldBack</span></span><span lang="EN-US">:</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>f 1 (f 2 (f 3(f 4(f 5 seed))))</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">There are several other functions in the</span> <span class="Teletyped"><span lang="EN-US" style=''>List</span></span> <span lang="EN-US">module related to folding:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Teletyped"><span lang="EN-US" style=''>fold2</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>foldBack2</span></span><span lang="EN-US">: folds two lists together simultaneously.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Teletyped"><span lang="EN-US" style=''>reduce</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>reduceBack</span></span><span lang="EN-US">: same as</span> <span class="Teletyped"><span lang="EN-US" style=''>fold</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>foldBack</span></span><span lang="EN-US">, except it uses the first (or last) element in the list as the seed value.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Teletyped"><span lang="EN-US" style=''>scan</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>scanBack</span></span><span lang="EN-US">: similar to</span> <span class="Teletyped"><span lang="EN-US" style=''>fold</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>foldBack</span></span><span lang="EN-US">, except it returns all of the intermediate values as a list rather than the final accumulated value.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Fold functions can be surprisingly useful:</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Summing the numbers 1 - 100</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let x = [ 1 .. 100 ] |&gt; List.fold ( + ) 0 (* returns 5050 *)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In F#, mathematical operators are no different from functions. As shown above, we can actually pass the addition operator to the</span> <span class="Teletyped"><span lang="EN-US" style=''>fold</span></span> <span lang="EN-US">function, because the</span> <span class="Teletyped"><span lang="EN-US" style=''>+</span></span> <span lang="EN-US">operator has the definition</span> <span class="Teletyped"><span lang="EN-US" style=''>int -&gt; int -&gt; int</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Computing a factorial</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let factorial n = [ 1I .. n ] |&gt; List.fold ( * ) 1I<br>
				let x = factorial 13I (* returns 6227020800I *)</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Computing population standard deviation</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let stddev (input : float list) =<br>
				&nbsp;&nbsp;&nbsp; let sampleSize = float input.Length<br>
				&nbsp;&nbsp;&nbsp; let mean = (input |&gt; List.fold ( + ) 0.0) / sampleSize<br>
				&nbsp;&nbsp;&nbsp; let differenceOfSquares =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; input |&gt; List.fold<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( fun sum item -&gt; sum + Math.Pow(item - mean, 2.0) ) 0.0<br>
				&nbsp;&nbsp;&nbsp; let variance = differenceOfSquares / sampleSize<br>
				&nbsp;&nbsp;&nbsp; Math.Sqrt(variance)<br>
				<br>
				let x = stddev [ 5.0; 6.0; 8.0; 9.0 ] (* returns 1.58113883 *)</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">List.find and List.tryFind</span>
			</h3>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>List.find</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>List.tryfind</span></span> <span lang="EN-US">have the following types:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">val find : ('T -&gt; bool) -&gt; 'T list -&gt; 'T<br>
				val tryFind : ('T -&gt; bool) -&gt; 'T list -&gt; 'T option</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>find</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>tryFind</span></span> <span lang="EN-US">methods return the first item in the list for which the search function returns</span> <span class="Teletyped"><span lang="EN-US" style=''>true</span></span><span lang="EN-US">. They only differ as follows: if no items are found that meet the search function,</span> <span class="Teletyped"><span lang="EN-US" style=''>find</span></span> <span lang="EN-US">throws a</span> <span class="Teletyped"><span lang="EN-US" style=''>KeyNotFoundException</span></span><span lang="EN-US">, while</span> <span class="Teletyped"><span lang="EN-US" style=''>tryfind</span></span> <span lang="EN-US">returns</span> <span class="Teletyped"><span lang="EN-US" style=''>None</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The two functions are used as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let cities = ["Bellevue"; "Omaha"; "Lincoln"; "Papillion"; "Fremont"];;<br>
				<br>
				val cities : string list =<br>
				&nbsp; ["Bellevue"; "Omaha"; "Lincoln"; "Papillion"; "Fremont"]<br>
				<br>
				&gt; let findStringContaining text (items : string list) =<br>
				&nbsp;&nbsp;&nbsp; items |&gt; List.find(fun item -&gt; item.Contains(text));;<br>
				<br>
				val findStringContaining : string -&gt; string list -&gt; string<br>
				<br>
				&gt; let findStringContaining2 text (items : string list) =<br>
				&nbsp;&nbsp;&nbsp; items |&gt; List.tryFind(fun item -&gt; item.Contains(text));;<br>
				<br>
				val findStringContaining2 : string -&gt; string list -&gt; string option<br>
				<br>
				&gt; findStringContaining "Papi" cities;;<br>
				val it : string = "Papillion"<br>
				<br>
				&gt; findStringContaining "Hastings" cities;;<br>
				System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.<br>
				&nbsp;&nbsp; at Microsoft.FSharp.Collections.ListModule.find[T](FastFunc`2 predicate, FSharpList`1 list)<br>
				&nbsp;&nbsp; at &lt;StartupCode$FSI_0007&gt;.$FSI_0007.main@()<br>
				stopped due to error<br>
				<br>
				&gt; findStringContaining2 "Hastings" cities;;<br>
				val it : string option = None</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Exercises</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Solutions/Lists"><span style='color:windowtext;text-decoration:none'>Solutions</span></a>.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Pair and Unpair</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Write two functions with the following definitions:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">val pair : 'a list -&gt; ('a * 'a) list<br>
				val unpair : ('a * 'a) list -&gt; 'a list</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>pair</span></span><span lang="EN-US">function should convert a list into a list of pairs as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">pair [ 1 .. 10 ] = [(1, 2); (3, 4); (5, 6); (7, 8); (9, 10)]<br>
				pair [ "one"; "two"; "three"; "four"; "five" ] = [("one", "two"); ("three", "four")]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>unpair</span></span><span lang="EN-US">function should convert a list of pairs back into a traditional list as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">unpair [(1, 2); (3, 4); (5, 6)] =&nbsp; [1; 2; 3; 4; 5; 6]<br>
				unpair [("one", "two"); ("three", "four")] = ["one"; "two"; "three"; "four"]</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Expand a List</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Write a function with the following type definition:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">val expand : 'a list -&gt; 'a list list</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>expand</span></span><span lang="EN-US">function should expand a list as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">expand [ 1 .. 5 ] = [ [1; 2; 3; 4; 5]; [2; 3; 4; 5]; [3; 4; 5]; [4; 5]; [5] ]<br>
				expand [ "monkey"; "kitty"; "bunny"; "rat" ] =<br>
				&nbsp;&nbsp;&nbsp; [ ["monkey"; "kitty"; "bunny"; "rat"];<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ["kitty"; "bunny"; "rat"];<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ["bunny"; "rat"];<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ["rat"] ]</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Sequences
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Sequences</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Sequences</span></span><span lang="EN-US">, commonly called <span class="Bold">sequence expressions</span>, are similar to lists: both data structures are used to represent an ordered collection of values. However, unlike lists, elements in a sequence are computed <em>as they are needed</em> (or "lazily"), rather than computed all at once. This gives sequences some interesting properties, such as the capacity to represent infinite data structures.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Defining Sequences</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Sequences are defined using the syntax:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">seq { expr }</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Similar to lists, sequences can be constructed using ranges and comprehensions:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; seq { 1 .. 10 };; (* seq ranges *)<br>
				val it : seq&lt;int&gt; = seq [1; 2; 3; 4; ...]<br>
				<br>
				&gt; seq { 1 .. 2 .. 10 };; (* seq ranges *)<br>
				val it : seq&lt;int&gt; = seq [1; 3; 5; 7; ...]<br>
				<br>
				&gt; seq {10 .. -1 .. 0};; (* descending *)<br>
				val it : seq&lt;int&gt; = seq [10; 9; 8; 7; ...]<br>
				<br>
				&gt; seq { for a in 1 .. 10 do yield a, a*a, a*a*a };; (* seq comprehensions *)<br>
				val it : seq&lt;int * int * int&gt;<br>
				= seq [(1, 1, 1); (2, 4, 8); (3, 9, 27); (4, 16, 64); ...]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Sequences have an interesting property which sets them apart from lists: elements in the sequence are <em>lazily evaluated</em>, meaning that F# does not compute values in a sequence until the values are actually needed. This is in contrast to lists, where F# computes the value of all elements in a list on declaration. As a demonstration, compare the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let intList =<br>
				&nbsp;&nbsp;&nbsp; [ for a in 1 .. 10 do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "intList: %i" a<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield a ]<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let intSeq =<br>
				&nbsp;&nbsp;&nbsp; seq { for a in 1 .. 10 do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "intSeq: %i" a<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield a };;<br>
				<br>
				val intList : int list<br>
				val intSeq : seq&lt;int&gt;<br>
				<br>
				intList: 1<br>
				intList: 2<br>
				intList: 3<br>
				intList: 4<br>
				intList: 5<br>
				intList: 6<br>
				intList: 7<br>
				intList: 8<br>
				intList: 9<br>
				intList: 10<br>
				<br>
				&gt; Seq.nth 3 intSeq;;<br>
				intSeq: 1<br>
				intSeq: 2<br>
				intSeq: 3<br>
				intSeq: 4<br>
				val it : int = 4<br>
				<br>
				&gt; Seq.nth 7 intSeq;;<br>
				intSeq: 1<br>
				intSeq: 2<br>
				intSeq: 3<br>
				intSeq: 4<br>
				intSeq: 5<br>
				intSeq: 6<br>
				intSeq: 7<br>
				intSeq: 8<br>
				val it : int = 8</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The list is created on declaration, but elements in the sequence are created as they are needed.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">As a result, sequences are able to represent a data structure with an arbitrary number of elements:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; seq { 1I .. 1000000000000I };;<br>
				val it : seq&lt;bigint&gt; = seq [1I; 2I; 3I; 4I; ...]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The sequence above represents a list with one trillion elements in it. That does not mean the sequence actually contains one trillion elements, but it can <em>potentially</em> hold one trillion elements. By comparison, it would not be possible to create a list</span> <span class="Teletyped"><span lang="EN-US" style=''>[ 1I .. 1000000000000I ]</span></span> <span lang="EN-US">since the .NET runtime would attempt to create all one trillion elements up front, which would certainly consume all of the available memory on a system before the operation completed.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Additionally, sequences can represent an infinite number of elements:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let allEvens =<br>
				&nbsp;&nbsp;&nbsp; let rec loop x = seq { yield x; yield! loop (x + 2) }<br>
				&nbsp;&nbsp;&nbsp; loop 0;;<br>
				<br>
				&gt; for a in (Seq.take 5 allEvens) do<br>
				&nbsp;&nbsp;&nbsp; printfn "%i" a;;<br>
				0<br>
				2<br>
				4<br>
				6<br>
				8</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice the definition of</span> <span class="Teletyped"><span lang="EN-US" style=''>allEvens</span></span> <span lang="EN-US">does not terminate. The function</span> <span class="Teletyped"><span lang="EN-US" style=''>Seq.take</span></span><span lang="EN-US">returns the first</span> <span class="Teletyped"><span lang="EN-US" style=''>n</span></span> <span lang="EN-US">elements of elements of the sequence. If we attempted to loop through all of the elements, fsi would print indefinitely.</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US">Note:</span></span> <span lang="EN-US">sequences are implemented as state machines by the F# compiler. In reality, they manage state interally and hold only the last generated item in memory at a time. Memory usage is constant for creating and traversing sequences of any length.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Iterating Through Sequences Manually</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">The .NET Base Class Library (BCL) contains two interfaces in the</span> <span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/system.collections.generic.aspx"><span style='color:windowtext;text-decoration:none'>System.Collections.Generic</span></a></span></span> <span lang="EN-US">namespace:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type IEnumerable&lt;'a&gt; =<br>
				&nbsp; interface<br>
				&nbsp;&nbsp; (* Returns an enumerator that iterates through a collection *)<br>
				&nbsp;&nbsp;&nbsp; member GetEnumerator&lt;'a&gt; : unit -&gt; IEnumerator&lt;'a&gt;<br>
				&nbsp; end<br>
				<br>
				type IEnumerator&lt;'a&gt; =<br>
				&nbsp; interface<br>
				&nbsp;&nbsp; (* Advances to the next element in the sequences. Returns true if<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the enumerator was successfully advanced to the next element; false<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if the enumerator has passed the end of the collection. *)<br>
				&nbsp;&nbsp;&nbsp; member MoveNext : unit -&gt; bool<br>
				<br>
				&nbsp;&nbsp;&nbsp; (* Gets the current element in the collection. *)<br>
				&nbsp;&nbsp;&nbsp; member Current : 'a<br>
				<br>
				&nbsp;&nbsp; &nbsp;(* Sets the enumerator to its initial position, which is<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; before the first element in the collection. *)<br>
				&nbsp;&nbsp;&nbsp; member Reset : unit -&gt; unit<br>
				&nbsp; end</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>seq</span></span> <span lang="EN-US">type is defined as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type seq&lt;'a&gt; = System.Collections.Generic.IEnumerable&lt;'a&gt;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">As you can see,</span> <span class="Teletyped"><span lang="EN-US" style=''>seq</span></span> <span lang="EN-US">is not a unique F# type, but rather another name for the built-in</span> <span class="Teletyped"><span lang="EN-US" style=''>System.Collections.Generic.IEnumerable</span></span> <span lang="EN-US">interface. Since</span> <span class="Teletyped"><span lang="EN-US" style=''>seq</span></span><span lang="EN-US">/</span><span class="Teletyped"><span lang="EN-US" style=''>IEnumerable</span></span> <span lang="EN-US">is a native .NET type, it was designed to be used in a more imperative style, which can be demonstrated as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				open System.Collections<br>
				<br>
				let evens = seq { 0 .. 2 .. 10 } (* returns IEnumerable&lt;int&gt; *)<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let evensEnumerator = evens.GetEnumerator() (* returns IEnumerator&lt;int&gt; *)<br>
				&nbsp;&nbsp;&nbsp; while evensEnumerator.MoveNext() do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "evensEnumerator.Current: %i" evensEnumerator.Current<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; Console.ReadKey(true) |&gt; ignore<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">evensEnumerator.Current: 0evensEnumerator.Current: 2evensEnumerator.Current: 4evensEnumerator.Current: 6evensEnumerator.Current: 8evensEnumerator.Current: 10</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Behind the scenes, .NET converts every</span> <span class="Teletyped"><span lang="EN-US" style=''>for</span></span> <span lang="EN-US">loop over a collection into an explicit while loop. In other words, the following two pieces of code compile down to the same bytecode:</span>
			</p>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
						<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
							<span lang="EN-US">let x = [1 .. 10]<br>
							for num in x do<br>
							&nbsp;&nbsp;&nbsp; printfn "%i" num</span>
						</p>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
						<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
							<span lang="EN-US">let x = [1 .. 10]<br>
							let enumerator = x.GetEnumerator()<br>
							while enumerator.MoveNext() do<br>
							&nbsp;&nbsp;&nbsp; let num = enumerator.Current<br>
							&nbsp;&nbsp;&nbsp; printfn "%i" num</span>
						</p>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">All collections which can be used with the</span> <span class="Teletyped"><span lang="EN-US" style=''>for</span></span> <span lang="EN-US">keyword implement the</span> <span class="Teletyped"><span lang="EN-US" style=''>IEnumerable&lt;'a&gt;</span></span> <span lang="EN-US"><a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Interfaces"><span style='color:windowtext;text-decoration:none'>interface</span></a>, a concept which will be discussed later in this book.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">The Seq Module</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Similar to the List modules, the</span> <span class="Teletyped"><span lang="EN-US" style=''>Seq</span></span> <span lang="EN-US">module contains a number of useful functions for operating on sequences:</span>
			</p>
			<p class="TextBody">
				<span class="Bold">val append : seq&lt;'T&gt; -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T&gt;</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Appends one sequence onto another sequence.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let test = Seq.append (seq{1..3}) (seq{4..7});;<br>
				val it : seq&lt;int&gt; = seq [5; 4]</span>
			</p>
			<p class="TextBody">
				<span class="Bold">val choose : ('T -&gt; 'U option) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'U&gt;</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Filters and maps a sequence to another sequence.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let thisworks = seq { for nm in [ Some("James"); None; Some("John") ] |&gt; Seq.choose id -&gt; nm.Length }<br>
				val it : seq&lt;int&gt; = seq [1; 2; 3; 4; ...]</span>
			</p>
			<p class="TextBody">
				<span class="Bold">val distinct : seq&lt;'T&gt; -&gt; seq&lt;'T&gt;</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Returns a sequence that filters out duplicate entries.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let dist = Seq.distinct (seq[1;2;2;6;3;2])<br>
				val it : seq&lt;int&gt; = seq [1; 2; 6; 3]</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">val exists : ('T -&gt; bool) -&gt; seq&lt;'T&gt; -&gt; bool</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Determines if an element exist in a sequence.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let igualADois x = x=2<br>
				&gt; let existe = Seq.exists igualADois (seq{3..9})<br>
				val igualADois : int -&gt; bool<br>
				val it : bool = false</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">val filter : ('T -&gt; bool) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Builds a new sequence consisting of elements filtered from the input sequence.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; Seq.filter (fun x-&gt; if x%2=0 then true else false) (seq{0..9})<br>
				val it : seq&lt;int&gt; = seq [0; 2; 4; 6; ...]</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">val fold : ('State -&gt; 'T -&gt; 'State) -&gt; 'State -&gt; seq&lt;'T&gt; -&gt; 'State</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Repeatedly applies a function to each element in the sequence from left to right.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let sumSeq sequence1 = Seq.fold (fun acc elem -&gt; acc + elem) 0 sequence1<br>
				Seq.init 10 (fun index -&gt; index * index)<br>
				|&gt; sumSeq<br>
				|&gt; printfn "The sum of the elements is %d."<br>
				&gt;<br>
				The sum of the elements is 285.<br>
				<br></span>val sumSeq : seq&lt;int&gt; -&gt; int
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US">Note:</span></span> <span lang="EN-US">sequences can only be read forward-only manner, so there is no corresponding</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>foldBack</span></span> <span lang="EN-US">function as found in the List and Array modules.</span>
			</p>
			<p class="TextBody">
				<span class="Bold">val initInfinite : (int -&gt; 'T) -&gt; seq&lt;'T&gt;</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Generates a sequence consisting of an infinite number of elements.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; Seq.initInfinite (fun x -&gt; x*x)<br>
				val it : seq&lt;int&gt; = seq [0; 1; 4; 9; ...]
			</p>
			<p class="TextBody">
				<span class="Bold">val map : ('T -&gt; 'U) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'U&gt;</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Maps a sequence of type</span> <span class="Teletyped"><span lang="EN-US" style=''>'a</span></span> <span lang="EN-US">to type</span> <span class="Teletyped"><span lang="EN-US" style=''>'b</span></span><span lang="EN-US">.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; Seq.map (fun x-&gt;x*x+2) (seq[3;5;4;3])<br>
				val it : seq&lt;int&gt; = seq [11; 27; 18; 11]</span>
			</p>
			<p class="TextBody">
				<span class="Bold">val nth : int -&gt; seq&lt;'T&gt; -&gt; 'T</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Returns the <em>nth</em> value of a sequence.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; Seq.nth 3 (seq {for n in 2..9 do yield n})<br>
				val it : int = 5</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">val take : int -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Returns a new sequence consisting of the first <em>n</em> elements of the input sequence.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; Seq.take 3 (seq{1..6})<br>
				val it : seq&lt;int&gt; = seq [1; 2; 3]</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">val takeWhile : ('T -&gt; bool) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return a sequence that, when iterated, yields elements of the underlying sequence while the given predicate returns</span> <span class="Teletyped"><span lang="EN-US" style=''>true</span></span><span lang="EN-US">, and returns no further elements.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let sequenciaMenorqDez = Seq.takeWhile (fun elem -&gt; elem &lt; 10) (seq {for i in 0..20 do yield i+1})<br>
				val sequenciaMenorqDez : seq&lt;int&gt;<br>
				&gt; sequenciaMenorqDez;;<br>
				val it : seq&lt;int&gt; = seq [1; 2; 3; 4; ...]</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">val unfold : ('State -&gt; ('T * 'State) option) -&gt; 'State seed -&gt; seq&lt;'T&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">The opposite of</span> <span class="Teletyped"><span lang="EN-US" style=''>fold</span></span><span lang="EN-US">: this function generates a sequence as long as the generator function returns</span> <span class="Teletyped"><span lang="EN-US" style=''>Some</span></span><span lang="EN-US">.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let fibs = (0I, 1I) |&gt; Seq.unfold (fun (a, b) -&gt; Some(a, (b, a + b) ) );;<br>
				<br>
				val fibs : seq&lt;bigint&gt;<br>
				<br>
				&gt; Seq.iter (fun x -&gt; printf "%O " x) (Seq.take 20 fibs);;<br>
				0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The generator function in</span> <span class="Teletyped"><span lang="EN-US" style=''>unfold</span></span> <span lang="EN-US">expects a return type of</span> <span class="Teletyped"><span lang="EN-US" style=''>('T * 'State) option</span></span><span lang="EN-US">. The first value of the tuple is inserted as an element into the sequence, the second value of the tuple is passed as the accumulator. The</span> <span class="Teletyped"><span lang="EN-US" style=''>fibs</span></span> <span lang="EN-US">function is clever for its brevity, but its hard to understand if you've never seen an unfold function. The following demonstrates</span> <span class="Teletyped"><span lang="EN-US" style=''>unfold</span></span> <span lang="EN-US">in a more straightforward way:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let test = 1 |&gt; Seq.unfold (fun x -&gt;<br>
				&nbsp;&nbsp;&nbsp; if x &lt;= 5 then Some(sprintf "x: %i" x, x + 1)<br>
				&nbsp;&nbsp;&nbsp; else None );;<br>
				<br>
				val test : seq&lt;string&gt;<br>
				<br>
				&gt; Seq.iter (fun x -&gt; printfn "%s" x) test;;<br>
				x: 1<br>
				x: 2<br>
				x: 3<br>
				x: 4<br>
				x: 5</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Often, its preferable to generate sequences using</span> <span class="Teletyped"><span lang="EN-US" style=''>seq</span></span> <span lang="EN-US">comprehensions rather than the</span> <span class="Teletyped"><span lang="EN-US" style=''>unfold</span></span><span lang="EN-US">.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Sets and Maps
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Sets and Maps</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">In addition to lists and sequences, F# provides two related immutable data structures called <span class="Bold">sets</span> and <span class="Bold">maps</span>. Unlike lists, sets and maps are <em>unordered</em> data structures, meaning that these collections do not preserve the order of elements as they are inserted, nor do they permit duplicates.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Sets</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">A set in F# is just a container for items. Sets do not preserve the order in which items are inserted, nor do they allow duplicate entries to be inserted into the collection.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Sets can be created in a variety of ways:</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Adding an item to an empty set</span></span> <span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>Set</span></span> <span lang="EN-US">module contains a useful function</span> <span class="Teletyped"><span lang="EN-US" style=''>Set.empty</span></span> <span lang="EN-US">which returns an empty set to start with.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Conveniently, all instances of sets have an</span> <span class="Teletyped"><span lang="EN-US" style=''>Add</span></span> <span lang="EN-US">function with the type</span> <span class="Teletyped"><span lang="EN-US" style=''>val Add : 'a -&gt; Set&lt;'a&gt;</span></span><span lang="EN-US">. In other words, our</span> <span class="Teletyped"><span lang="EN-US" style=''>Add</span></span> <span lang="EN-US">returns a set containing our new item, which makes it easy to add items together in this fashion:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; Set.empty.Add(1).Add(2).Add(7);;<br>
				val it : Set&lt;int&gt; = set [1; 2; 7]</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Converting lists and sequences into sets</span></span> <span lang="EN-US">Additionally, the we can use</span> <span class="Teletyped"><span lang="EN-US" style=''>Set.ofList</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Set.ofSeq</span></span> <span lang="EN-US">to convert an entire collection into a set:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; Set.ofList ["Mercury"; "Venus"; "Earth"; "Mars"; "Jupiter"; "Saturn"; "Uranus"; "Neptune"];;<br>
				val it : Set&lt;string&gt; = set ["Earth"; "Jupiter"; "Mars"; "Mercury"; ...]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The example above demonstrates the unordered nature of sets.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">The Set Module</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">The <a href="http://msdn.microsoft.com/en-us/library/ee340244.aspx"><span style='color:windowtext;text-decoration:none'>Microsoft.FSharp.Collections.Set</span></a> module contains a variety of useful methods for working with sets.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val add : 'a -&gt; Set&lt;'a&gt; -&gt; Set&lt;'a&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return a new set with an element added to the set. No exception is raised if the set already contains the given element.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val compare : Set&lt;'a&gt; -&gt; Set&lt;'a&gt; -&gt; int</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Compare two sets. Places sets into a total order.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val count : Set&lt;'a&gt; -&gt; int</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span lang="EN-US">Return the number of elements in the set.</span> Same as "size".
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val difference : Set&lt;'a&gt; -&gt; Set&lt;'a&gt; -&gt; Set&lt;'a&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return a new set with the elements of the second set removed from the first.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let a = Set.ofSeq [ 1 .. 10 ]<br>
				let b = Set.ofSeq [ 5 .. 15 ];;<br>
				<br>
				val a : Set&lt;int&gt;<br>
				val b : Set&lt;int&gt;<br>
				<br>
				&gt; Set.difference a b;;<br>
				val it : Set&lt;int&gt; = set [1; 2; 3; 4]<br>
				<br>
				&gt; a - b;; (* The '-' operator is equivalent to Set.difference *)<br>
				val it : Set&lt;int&gt; = set [1; 2; 3; 4]</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val exists : ('a -&gt; bool) -&gt; Set&lt;'a&gt; -&gt; bool</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Test if any element of the collection satisfies the given predicate.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val filter : ('a -&gt; bool) -&gt; Set&lt;'a&gt; -&gt; Set&lt;'a&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return a new collection containing only the elements of the collection for which the given predicate returns "true".</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val intersect : Set&lt;'a&gt; -&gt; Set&lt;'a&gt; -&gt; Set&lt;'a&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Compute the intersection, or overlap, of the two sets.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let a = Set.ofSeq [ 1 .. 10 ]<br>
				let b = Set.ofSeq [ 5 .. 15 ];;<br>
				<br>
				val a : Set&lt;int&gt;<br>
				val b : Set&lt;int&gt;<br>
				<br>
				&gt; Set.iter (fun x -&gt; printf "%O " x) (Set.intersect a b);;<br>
				5 6 7 8 9 10</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val map : ('a -&gt; 'b) -&gt; Set&lt;'a&gt; -&gt; Set&lt;'b&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return a new collection containing the results of applying the given function to each element of the input set.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val contains: 'a -&gt; Set&lt;'a&gt; -&gt; bool</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Evaluates to</span> <span class="Teletyped"><span lang="EN-US" style=''>true</span></span> <span lang="EN-US">if the given element is in the given set.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val remove : 'a -&gt; Set&lt;'a&gt; -&gt; Set&lt;'a&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return a new set with the given element removed. No exception is raised if the set doesn't contain the given element.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val count: Set&lt;'a&gt; -&gt; int</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return the number of elements in the set.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val isSubset : Set&lt;'a&gt; -&gt; Set&lt;'a&gt; -&gt; bool</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Evaluates to "true" if all elements of the first set are in the second.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val isProperSubset : Set&lt;'a&gt; -&gt; Set&lt;'a&gt; -&gt; bool</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Evaluates to "true" if all elements of the first set are in the second, and there at least one element in the second which is not in the first.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let a = Set.ofSeq [ 1 .. 10 ]<br>
				let b = Set.ofSeq [ 5 .. 15 ]<br>
				let c = Set.ofSeq [ 2; 4; 5; 9 ];;<br>
				<br>
				val a : Set&lt;int&gt;<br>
				val b : Set&lt;int&gt;<br>
				val c : Set&lt;int&gt;<br>
				<br>
				&gt; Set.isSubset c a;; (* All elements of 'c' exist in 'a' *)<br>
				val it : bool = true<br>
				<br>
				&gt; Set.isSubset c b;; (* Not all of the elements of 'c' exist in 'b' *);;<br>
				val it : bool = false</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val union : Set&lt;'a&gt; -&gt; Set&lt;'a&gt; -&gt; Set&lt;'a&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Compute the union of the two sets.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let a = Set.ofSeq [ 1 .. 10 ]<br>
				let b = Set.ofSeq [ 5 .. 15 ];;<br>
				<br>
				val a : Set&lt;int&gt;<br>
				val b : Set&lt;int&gt;<br>
				<br>
				&gt; Set.iter (fun x -&gt; printf "%O " x) (Set.union a b);;<br>
				1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 val it : unit = ()<br>
				<br>
				&gt; Set.iter (fun x -&gt; printf "%O " x) (a + b);; (* '+' computes union *)<br>
				1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Examples</span>
			</h3>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let shakespeare = "O Romeo, Romeo! wherefore art thou Romeo?"<br>
				let shakespeareArray =<br>
				&nbsp;&nbsp;&nbsp; shakespeare.Split([| ' '; ','; '!'; '?' |], StringSplitOptions.RemoveEmptyEntries)<br>
				let shakespeareSet = shakespeareArray |&gt; Set.ofSeq<br>
				&nbsp;&nbsp;&nbsp;<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; printfn "shakespeare: %A" shakespeare<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let printCollection msg coll =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "%s:" msg<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Seq.iteri (fun index item -&gt; printfn "&nbsp; %i: %O" index item) coll<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printCollection "shakespeareArray" shakespeareArray<br>
				&nbsp;&nbsp;&nbsp; printCollection "shakespeareSet" shakespeareSet<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; Console.ReadKey(true) |&gt; ignore<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">shakespeare: "O Romeo, Romeo! wherefore art thou Romeo?"shakespeareArray:&nbsp; 0: O&nbsp; 1: Romeo&nbsp; 2: Romeo&nbsp; 3: wherefore&nbsp; 4: art&nbsp; 5: thou&nbsp; 6: RomeoshakespeareSet:&nbsp; 0: O&nbsp; 1: Romeo&nbsp; 2: art&nbsp; 3: thou&nbsp; 4: wherefore</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Maps</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">A map is a special kind of set: it associates <em>keys</em> with <em>values</em>. A map is created in a similar way to sets:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let holidays =<br>
				&nbsp;&nbsp;&nbsp; Map.empty.<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add("Christmas", "Dec. 25").<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add("Halloween", "Oct. 31").<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add("Darwin Day", "Feb. 12").<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add("World Vegan Day", "Nov. 1");; (* Start with empty Map *)<br>
				<br>
				val holidays : Map&lt;string,string&gt;<br>
				<br>
				&gt; let monkeys =<br>
				&nbsp;&nbsp;&nbsp; [ "Squirrel Monkey", "Simia sciureus";<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Marmoset", "Callithrix jacchus";<br>
				&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Macaque", "Macaca mulatta";<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Gibbon", "Hylobates lar";<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Gorilla", "Gorilla gorilla";<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Humans", "Homo sapiens";<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Chimpanzee", "Pan troglodytes" ]<br>
				&nbsp;&nbsp;&nbsp; |&gt; Map.ofList;; (* Convert list to Map *)<br>
				<br>
				val monkeys : Map&lt;string,string&gt;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">You can use the</span> <span class="Teletyped"><span lang="EN-US" style=''>.[key]</span></span> <span lang="EN-US">to access elements in the map:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; holidays.["Christmas"];;<br>
				val it : string = "Dec. 25"<br>
				<br>
				&gt; monkeys.["Marmoset"];;<br>
				val it : string = "Callithrix jacchus"</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">The Map Module</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">The <a href="http://research.microsoft.com/fsharp/manual/FSharp.Core/Microsoft.FSharp.Collections.Map.html"><span style='color:windowtext;text-decoration:none'>Microsoft.FSharp.Collections.Map</span></a> module handles map operations.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val add : 'key -&gt; 'a -&gt; Map&lt;'key,'a&gt; -&gt; Map&lt;'key,'a&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return a new map with the binding added to the given map.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val empty&lt;'key,'a&gt; : Map&lt;'key,'a&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Returns an empty map.
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val exists : ('key -&gt; 'a -&gt; bool) -&gt; Map&lt;'key,'a&gt; -&gt; bool</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return true if the given predicate returns true for one of the bindings in the map.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val filter : ('key -&gt; 'a -&gt; bool) -&gt; Map&lt;'key,'a&gt; -&gt; Map&lt;'key,'a&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Build a new map containing only the bindings for which the given predicate returns</span> <span class="Teletyped"><span lang="EN-US" style=''>true</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val find : 'key -&gt; Map&lt;'key,'a&gt; -&gt; 'a</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Lookup an element in the map, raising</span> <span class="Teletyped"><span lang="EN-US" style=''>KeyNotFoundException</span></span> <span lang="EN-US">if no binding exists in the map.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val containsKey: 'key -&gt; Map&lt;'key,'a&gt; -&gt; bool</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Test if an element is in the domain of the map.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val remove : 'key -&gt; Map&lt;'key,'a&gt; -&gt; Map&lt;'key,'a&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Remove an element from the domain of the map. No exception is raised if the element is not present.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val tryfind : 'key -&gt; Map&lt;'key,'a&gt; -&gt; 'a option</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Lookup an element in the map, returning a</span> <span class="Teletyped"><span lang="EN-US" style=''>Some</span></span> <span lang="EN-US">value if the element is in the domain of the map and</span> <span class="Teletyped"><span lang="EN-US" style=''>None</span></span> <span lang="EN-US">if not.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Examples</span>
			</h3>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let capitals =<br>
				&nbsp;&nbsp;&nbsp; [("Australia", "Canberra"); ("Canada", "Ottawa"); ("China", "Beijing");<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("Denmark", "Copenhagen"); ("Egypt", "Cairo"); ("Finland", "Helsinki");<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("France", "Paris"); ("Germany", "Berlin"); ("India", "New Delhi");<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("Japan", "Tokyo"); ("Mexico", "Mexico City"); ("Russia", "Moscow");<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("Slovenia", "Ljubljana"); ("Spain", "Madrid"); ("Sweden", "Stockholm");<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("Taiwan", "Taipei"); ("USA", "Washington D.C.")]<br>
				&nbsp;&nbsp;&nbsp; |&gt; Map.ofList<br>
				<br>
				let rec main() =<br>
				&nbsp;&nbsp;&nbsp; Console.Write("Find a capital by country (type 'q' to quit): ")<br>
				&nbsp;&nbsp;&nbsp; match Console.ReadLine() with<br>
				&nbsp;&nbsp;&nbsp; | "q" -&gt; Console.WriteLine("Bye bye")<br>
				&nbsp;&nbsp;&nbsp; | country -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match capitals.TryFind(country) with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Some(capital) -&gt; Console.WriteLine("The capital of {0} is {1}\n", country, capital)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | None -&gt; Console.WriteLine("Country not found.\n")<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main() (* loop again *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Find a capital by country (type 'q' to quit): EgyptThe capital of Egypt is CairoFind a capital by country (type 'q' to quit): SloveniaThe capital of Slovenia is LjubljanaFind a capital by country (type 'q' to quit): LatveriaCountry not found.Find a capital by country (type 'q' to quit): USAThe capital of USA is Washington D.C.Find a capital by country (type 'q' to quit): qBye bye</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Set and Map Performance</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">F# sets and maps are implemented as immutable red-black trees, an efficient data structure which forms a self-balancing binary tree. Red-black trees are well-known for their efficiency, in which they can search, insert, and delete elements in the tree in O(log <em>n</em>) time, where <em>n</em> is the number of elements in the tree.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Discriminated Unions
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Discriminated Unions</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Discriminated unions</span></span><span lang="EN-US">, also called <span class="Bold">tagged unions</span>, represent a finite, well-defined set of choices. Discriminated unions are often the tool of choice for building up more complicated data structures including linked lists and a wide range of trees.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Creating Discriminated Unions</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Discriminated unions are defined using the following syntax:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type unionName =<br>
				&nbsp;&nbsp;&nbsp; | Case1<br>
				&nbsp;&nbsp;&nbsp; | Case2 of datatype<br>
				&nbsp;&nbsp;&nbsp; | ...</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">By convention, union names start with a lowercase character, and union cases are written in PascalCase.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Union basics: an On/Off switch</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Let's say we have a light switch. For most of us, a light switch has two possible states: the light switch can be ON, or it can be OFF. We can use an F# union to model our light switch's state as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type switchstate =<br>
				&nbsp;&nbsp;&nbsp; | On<br>
				&nbsp;&nbsp;&nbsp; | Off</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We've defined a union called</span> <span class="Teletyped"><span lang="EN-US" style=''>switchstate</span></span> <span lang="EN-US">which has two cases,</span> <span class="Teletyped"><span lang="EN-US" style=''>On</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>Off</span></span><span lang="EN-US">. You can create and uses instances of</span> <span class="Teletyped"><span lang="EN-US" style=''>switchstate</span></span><span lang="EN-US">as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type switchstate =<br>
				&nbsp;&nbsp;&nbsp; | On<br>
				&nbsp;&nbsp;&nbsp; | Off<br>
				&nbsp;&nbsp;&nbsp;<br>
				let x = On&nbsp;&nbsp;&nbsp; (* creates an instance of switchstate *)<br>
				let y = Off&nbsp;&nbsp; (* creates another instance of switchstate *)<br>
				&nbsp;&nbsp;&nbsp;<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; printfn "x: %A" x<br>
				&nbsp;&nbsp;&nbsp; printfn "y: %A" y<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program has the following types:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type switchstate = On | Off<br>
				val x : switchstate<br>
				val y : switchstate</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">It outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">x: Ony: Off</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice that we create an instance of</span> <span class="Teletyped"><span lang="EN-US" style=''>switchstate</span></span> <span lang="EN-US">simply by using the name of its cases; this is because, in a literal sense, the cases of a union are constructors. As you may have guessed, since we use the same syntax for constructing objects as for matching them, we can pattern match on unions in the following way:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type switchstate =<br>
				&nbsp;&nbsp;&nbsp; | On<br>
				&nbsp;&nbsp;&nbsp; | Off<br>
				&nbsp;&nbsp;&nbsp;<br>
				let toggle = function&nbsp; (* pattern matching input *)<br>
				&nbsp;&nbsp;&nbsp; | On -&gt; Off<br>
				&nbsp;&nbsp;&nbsp; | Off -&gt; On<br>
				&nbsp;&nbsp;&nbsp;<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let x = On<br>
				&nbsp;&nbsp;&nbsp; let y = Off<br>
				&nbsp;&nbsp;&nbsp; let z = toggle y<br>
				&nbsp; &nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printfn "x: %A" x<br>
				&nbsp;&nbsp;&nbsp; printfn "y: %A" y<br>
				&nbsp;&nbsp;&nbsp; printfn "z: %A" z<br>
				&nbsp;&nbsp;&nbsp; printfn "toggle z: %A" (toggle z)<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The function</span> <span class="Teletyped"><span lang="EN-US" style=''>toggle</span></span> <span lang="EN-US">has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>val toggle : switchstate -&gt; switchstate</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program has the following output:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">x: Ony: Offz: Ontoggle z: Off</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Holding Data In Unions: a dimmer switch</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">The example above is kept deliberately simple. In fact, in many ways, the discriminated union defined above doesn't appear much different from an enum value. However, let's say we wanted change our light switch model into a model of a dimmer switch, or in other words a light switch that allow users to adjust a lightbulb's power output from 0% to 100% power.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can modify our union above to accommodate three possible states: On, Off, and an adjustable value between 0 and 100:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type switchstate =<br>
				&nbsp;&nbsp;&nbsp; | On<br>
				&nbsp;&nbsp;&nbsp; | Off<br>
				&nbsp;&nbsp;&nbsp; | Adjustable of float</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We've added a new case,</span> <span class="Teletyped"><span lang="EN-US" style=''>Adjustable of float</span></span><span lang="EN-US">. This case is fundamentally the same as the others, except it takes a single</span> <span class="Teletyped"><span lang="EN-US" style=''>float</span></span> <span lang="EN-US">value in its constructor:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				type switchstate =<br>
				&nbsp;&nbsp;&nbsp; | On<br>
				&nbsp;&nbsp;&nbsp; | Off<br>
				&nbsp;&nbsp;&nbsp; | Adjustable of float<br>
				&nbsp;&nbsp;&nbsp;<br>
				let toggle = function<br>
				&nbsp;&nbsp;&nbsp; | On -&gt; Off<br>
				&nbsp;&nbsp;&nbsp; | Off -&gt; On<br>
				&nbsp;&nbsp;&nbsp; | Adjustable(brightness) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* Matches any switchstate of type Adjustable. Binds<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the value passed into the constructor to the variable<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'brightness'. Toggles dimness around the halfway point. *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let pivot = 0.5<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if brightness &lt;= pivot then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Adjustable(brightness + pivot)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Adjustable(brightness - pivot)<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let x = On<br>
				&nbsp;&nbsp;&nbsp; let y = Off<br>
				&nbsp;&nbsp;&nbsp; let z = Adjustable(0.25) (* takes a float in constructor *)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printfn "x: %A" x<br>
				&nbsp;&nbsp;&nbsp; printfn "y: %A" y<br>
				&nbsp;&nbsp;&nbsp; printfn "z: %A" z<br>
				&nbsp;&nbsp;&nbsp; printfn "toggle z: %A" (toggle z)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; Console.ReadKey(true) |&gt; ignore<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">x: Ony: Offz: Adjustable 0.25toggle z: Adjustable 0.75</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Creating Trees</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Discriminated unions can easily model a wide variety of trees and hierarchical data structures.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">For example, let's consider the following binary tree:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">/\&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; /\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; /\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /\&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 5</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Each node of our tree contains exactly two branches, and each branch can either be a integer or another tree. We can represent this tree as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type tree =<br>
				&nbsp;&nbsp;&nbsp; | Leaf of int<br>
				&nbsp;&nbsp;&nbsp; | Node of tree * tree</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can create an instance of the tree above using the following code:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				type tree =<br>
				&nbsp;&nbsp;&nbsp; | Leaf of int<br>
				&nbsp;&nbsp;&nbsp; | Node of tree * tree<br>
				&nbsp;&nbsp;&nbsp;<br>
				let simpleTree =<br>
				&nbsp;&nbsp;&nbsp; Node(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leaf 1,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leaf 2,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leaf 4,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leaf 5<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ),<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leaf 3<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp;<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; printfn "%A" simpleTree<br>
				&nbsp;&nbsp;&nbsp; Console.ReadKey(true) |&gt; ignore<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Node (Leaf 1,Node (Leaf 2,Node (Node (Leaf 4,Leaf 5),Leaf 3)))</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Very often, we want to recursively enumerate through all of the nodes in a tree structure. For example, if we wanted to count the total number of Leaf nodes in our tree, we can use:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				type tree =<br>
				&nbsp;&nbsp;&nbsp; | Leaf of int<br>
				&nbsp;&nbsp;&nbsp; | Node of tree * tree<br>
				<br>
				let simpleTree =<br>
				&nbsp;&nbsp;&nbsp; Node (Leaf 1, Node (Leaf 2, Node (Node (Leaf 4, Leaf 5), Leaf 3)))<br>
				&nbsp;&nbsp;&nbsp;<br>
				let countLeaves tree =<br>
				&nbsp;&nbsp;&nbsp; let rec loop sum = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Leaf(_) -&gt; sum + 1<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Node(tree1, tree2) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum + (loop 0 tree1) + (loop 0 tree2)<br>
				&nbsp;&nbsp;&nbsp; loop 0 tree<br>
				&nbsp;&nbsp;&nbsp;<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; printfn "countLeaves simpleTree: %i" (countLeaves simpleTree)<br>
				&nbsp;&nbsp;&nbsp; Console.ReadKey(true) |&gt; ignore<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">countLeaves simpleTree: 5</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Generalizing Unions For All Datatypes</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Note that our binary tree above only operates on integers. Its possible to construct unions which are generalized to operate on all possible data types. We can modify the definition of our union to the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type 'a tree =<br>
				&nbsp;&nbsp;&nbsp; | Leaf of 'a<br>
				&nbsp;&nbsp;&nbsp; | Node of 'a tree * 'a tree<br>
				<br>
				(* The syntax above is "OCaml" style. It's common to see<br>
				&nbsp;&nbsp; unions defined using the ".NET" style as follows which<br>
				&nbsp;&nbsp; surrounds the type parameter with &lt;'s and &gt;'s after the<br>
				&nbsp;&nbsp; type name:<br>
				<br>
				type tree&lt;'a&gt; =<br>
				&nbsp;&nbsp;&nbsp; | Leaf of 'a<br>
				&nbsp;&nbsp;&nbsp; | Node of tree&lt;'a&gt; * tree&lt;'a&gt;<br>
				*)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can use the union define above to define a binary tree of any data type:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				type 'a tree =<br>
				&nbsp;&nbsp;&nbsp; | Leaf of 'a<br>
				&nbsp;&nbsp;&nbsp; | Node of 'a tree * 'a tree&nbsp;<br>
				&nbsp;&nbsp;&nbsp;<br>
				let firstTree =<br>
				&nbsp;&nbsp;&nbsp; Node(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leaf 1,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leaf 2,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leaf 4,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leaf 5<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;),<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leaf 3<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp;<br>
				let secondTree =<br>
				&nbsp;&nbsp;&nbsp; Node(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leaf "Red",<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leaf "Orange"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ),<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leaf "Yellow",<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Leaf "Green"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ),<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leaf "Blue",<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Leaf "Violet"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp;<br>
				let prettyPrint tree =<br>
				&nbsp;&nbsp;&nbsp; let rec loop depth tree =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let spacer = new String(' ', depth)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match tree with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Leaf(value) -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "%s |- %A" spacer value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Node(tree1, tree2) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "%s |" spacer<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop (depth + 1) tree1<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop (depth + 1) tree2<br>
				&nbsp;&nbsp;&nbsp; loop 0 tree<br>
				&nbsp;&nbsp;&nbsp;<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; printfn "firstTree:"<br>
				&nbsp;&nbsp;&nbsp; prettyPrint firstTree<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printfn "secondTree:"<br>
				&nbsp;&nbsp;&nbsp; prettyPrint secondTree<br>
				&nbsp;&nbsp;&nbsp; Console.ReadKey(true) |&gt; ignore<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The functions above have the following types:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type 'a tree =<br>
				&nbsp;&nbsp;&nbsp; | Leaf of 'a<br>
				&nbsp;&nbsp;&nbsp; | Node of 'a tree * 'a tree<br>
				<br>
				val firstTree : int tree<br>
				val secondTree : string tree<br>
				val prettyPrint : 'a tree -&gt; unit</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">firstTree: |&nbsp; |- 1&nbsp; |&nbsp;&nbsp; |- 2&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |- 4&nbsp;&nbsp;&nbsp;&nbsp; |- 5&nbsp;&nbsp;&nbsp; |- 3secondTree: |&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |- "Red"&nbsp;&nbsp;&nbsp; |- "Orange"&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |- "Yellow"&nbsp;&nbsp;&nbsp; |- "Green"&nbsp; |&nbsp;&nbsp; |- "Blue"&nbsp;&nbsp; |- "Violet"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Examples</span>
			</h2>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Built-in Union Types</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">F# has several built-in types derived from discriminated unions, some of which have already been introduced in this tutorial. These types include:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type 'a list =<br>
				&nbsp;&nbsp;&nbsp; | Cons of 'a * 'a list<br>
				&nbsp;&nbsp;&nbsp; | Nil<br>
				<br>
				type 'a option =<br>
				&nbsp;&nbsp;&nbsp; | Some of 'a<br>
				&nbsp;&nbsp;&nbsp; | None</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Propositional Logic</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">The ML family of languages, which includes F# and its parent language OCaml, were originally designed for the development of automated theorem provers. Union types allow F# programmers to represent propositional logic remarkably concisely. To keep things simple, lets limit our propositions to four possible cases:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type proposition =<br>
				&nbsp;&nbsp;&nbsp; | True<br>
				&nbsp;&nbsp;&nbsp; | Not of proposition<br>
				&nbsp;&nbsp;&nbsp; | And of proposition * proposition<br>
				&nbsp;&nbsp;&nbsp; | Or of proposition * proposition</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Let's say we had a series of propositions and wanted to determine whether they evaluate to true or false. We can easily write an eval function by recursively enumerating through a propositional statement as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let rec eval = function<br>
				&nbsp;&nbsp;&nbsp; | True -&gt; true<br>
				&nbsp;&nbsp;&nbsp; | Not(prop) -&gt; not (eval(prop))<br>
				&nbsp;&nbsp;&nbsp; | And(prop1, prop2) -&gt; eval(prop1) &amp;&amp; eval(prop2)<br>
				&nbsp;&nbsp;&nbsp; | Or(prop1, prop2) -&gt; eval(prop1) || eval(prop2)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>eval</span></span><span lang="EN-US">function has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>val eval : proposition -&gt; bool</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here is a full program using the eval function:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				&nbsp;<br>
				type proposition =<br>
				&nbsp;&nbsp;&nbsp; | True<br>
				&nbsp;&nbsp;&nbsp; | Not of proposition<br>
				&nbsp;&nbsp;&nbsp; | And of proposition * proposition<br>
				&nbsp;&nbsp;&nbsp; | Or of proposition * proposition<br>
				&nbsp;<br>
				let prop1 =<br>
				&nbsp;&nbsp;&nbsp; (* ~t || ~~t *)<br>
				&nbsp;&nbsp;&nbsp; Or(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Not True,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Not (Not True)<br>
				&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;<br>
				let prop2 =<br>
				&nbsp;&nbsp;&nbsp; (* ~(t &amp;&amp; ~t) || ( (t || t) || ~t) *)<br>
				&nbsp;&nbsp;&nbsp; Or(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Not(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; And(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; True,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Not True<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ),<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Or(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Or(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; True,<br>
				&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ),<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Not True<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;<br>
				let prop3 =<br>
				&nbsp;&nbsp;&nbsp; (* ~~~~~~~t *)<br>
				&nbsp;&nbsp;&nbsp; Not(Not(Not(Not(Not(Not(Not True))))))<br>
				&nbsp;<br>
				let rec eval = function<br>
				&nbsp;&nbsp;&nbsp; | True -&gt; true<br>
				&nbsp;&nbsp;&nbsp; | Not(prop) -&gt; not (eval(prop))<br>
				&nbsp;&nbsp;&nbsp; | And(prop1, prop2) -&gt; eval(prop1) &amp;&amp; eval(prop2)<br>
				&nbsp;&nbsp;&nbsp; | Or(prop1, prop2) -&gt; eval(prop1) || eval(prop2)<br>
				&nbsp;<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let testProp name prop = printfn "%s: %b" name (eval prop)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; testProp "prop1" prop1<br>
				&nbsp;&nbsp;&nbsp; testProp "prop2" prop2<br>
				&nbsp;&nbsp;&nbsp; testProp "prop3" prop3<br>
				&nbsp;<br>
				&nbsp;&nbsp;&nbsp; Console.ReadKey(true) |&gt; ignore<br>
				&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">prop1: trueprop2: trueprop3: false</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Additional Reading</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US"><a href="http://www.cl.cam.ac.uk/~jrh13/atp/index.html"><span style='color:windowtext; text-decoration:none'>Theorem Proving Examples</span></a> (OCaml)</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				<span lang="EN-US">Mutable Data</span>
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Mutable Data</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">All of the data types and values in F# seen so far have been immutable, meaning the values cannot be reassigned another value after they've been declared. However, F# allows programmers to create variables in the true sense of the word: variables whose values can change throughout the lifetime of the application.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">mutable Keyword</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">The simplest mutable variables in F# are declared using the</span> <span class="Teletyped"><span lang="EN-US" style=''>mutable</span></span> <span lang="EN-US">keyword. Here is a sample using fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let mutable x = 5;;<br>
				<br>
				val mutable x : int<br>
				<br>
				&gt; x;;<br>
				val it : int = 5<br>
				<br>
				&gt; x &lt;- 10;;<br>
				val it : unit = ()<br>
				<br>
				&gt; x;;<br>
				val it : int = 10</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">As shown above, the</span> <span class="Teletyped"><span lang="EN-US" style=''>&lt;-</span></span> <span lang="EN-US">operator is used to assign a mutable variable a new value. Notice that variable assignment actually returns</span> <span class="Teletyped"><span lang="EN-US" style=''>unit</span></span> <span lang="EN-US">as a value.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The mutable keyword is frequently used with record types to create mutable records:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				&nbsp;&nbsp;&nbsp;<br>
				type transactionItem =<br>
				&nbsp;&nbsp;&nbsp; { ID : int;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mutable IsProcessed : bool;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mutable ProcessedText : string; }<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let getItem id =<br>
				&nbsp;&nbsp;&nbsp; { ID = id;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;IsProcessed = false;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessedText = null; }<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let processItems (items : transactionItem list) =<br>
				&nbsp;&nbsp;&nbsp; items |&gt; List.iter(fun item -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item.IsProcessed &lt;- true<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item.ProcessedText &lt;- sprintf "Processed %s" (DateTime.Now.ToString("hh:mm:ss"))<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Threading.Thread.Sleep(1000) (* Putting thread to sleep for 1 second to simulate<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; processing overhead. *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				<br>
				let printItems (items : transactionItem list) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; items |&gt; List.iter (fun x -&gt; printfn "%A" x)<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let items = List.init 5 getItem<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printfn "Before Process:"<br>
				&nbsp;&nbsp;&nbsp; printItems items<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printfn "After process:"<br>
				&nbsp;&nbsp;&nbsp; processItems items<br>
				&nbsp;&nbsp;&nbsp; printItems items<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; Console.ReadKey(true) |&gt; ignore<br>
				&nbsp;<br>
				main()</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Before Process:{ID = 0; IsProcessed = false; ProcessedText = null;}{ID = 1; IsProcessed = false; ProcessedText = null;}{ID = 2; IsProcessed = false; ProcessedText = null;}{ID = 3; IsProcessed = false; ProcessedText = null;}{ID = 4; IsProcessed = false; ProcessedText = null;}After process:{ID = 0; IsProcessed = true; ProcessedText = "Processed 10:00:31";}{ID = 1; IsProcessed = true; ProcessedText = "Processed 10:00:32";}{ID = 2; IsProcessed = true; ProcessedText = "Processed 10:00:33";}{ID = 3; IsProcessed = true; ProcessedText = "Processed 10:00:34";}{ID = 4; IsProcessed = true; ProcessedText = "Processed 10:00:35";}</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Limitations of Mutable Variables</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Mutable variables are somewhat limited: mutables are inaccessible outside of the scope of the function where they are defined. Specifically, this means its not possible to reference a mutable in a subfunction of another function. Here's a demonstration in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let testMutable() =<br>
				&nbsp;&nbsp;&nbsp; let mutable msg = "hello"<br>
				&nbsp;&nbsp;&nbsp; printfn "%s" msg<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let setMsg() =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg &lt;- "world"<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; setMsg()<br>
				&nbsp;&nbsp;&nbsp; printfn "%s" msg;;<br>
				<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg &lt;- "world"<br>
				&nbsp; --------^^^^^^^^^^^^^^^<br>
				<br>
				stdin(18,9): error FS0191: The mutable variable 'msg' is used in an invalid way. Mutable<br>
				variables may not be captured by closures. Consider eliminating this use of mutation or<br>
				using a heap-allocated mutable reference cell via 'ref' and '!'.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Ref cells</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Ref cells get around some of the limitations of mutables. In fact, ref cells are very simple datatypes which wrap up a mutable field in a record type. Ref cells are defined by F# as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type 'a ref = { mutable contents : 'a }</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The F# library contains several built-in functions and operators for working with ref cells:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let ref v = { contents = v }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* val ref&nbsp; : 'a -&gt; 'a ref *)<br>
				let (!) r = r.contents&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* val (!)&nbsp; : 'a ref -&gt; 'a *)<br>
				let (:=) r v = r.contents &lt;- v&nbsp;&nbsp;&nbsp; (* val (:=) : 'a ref -&gt; 'a -&gt; unit *)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>ref</span></span> <span lang="EN-US">function is used to create a ref cell, the</span> <span class="Teletyped"><span lang="EN-US" style=''>!</span></span> <span lang="EN-US">operator is used to read the contents of a ref cell, and the</span> <span class="Teletyped"><span lang="EN-US" style=''>:=</span></span> <span lang="EN-US">operator is used to assign a ref cell a new value. Here is a sample in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let x = ref "hello";;<br>
				<br>
				val x : string ref<br>
				<br>
				&gt; x;; (* returns ref instance *)<br>
				val it : string ref = {contents = "hello";}<br>
				<br>
				&gt; !x;; (* returns x.contents *)<br>
				val it : string = "hello"<br>
				<br>
				&gt; x := "world";; (* updates x.contents with a new value *)<br>
				val it : unit = ()<br>
				<br>
				&gt; !x;; (* returns x.contents *)<br>
				val it : string = "world"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Since ref cells are allocated on the heap, they can be shared across multiple functions:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let withSideEffects x =<br>
				&nbsp;&nbsp;&nbsp; x := "assigned from withSideEffects function"<br>
				&nbsp;&nbsp;<br>
				let refTest() =<br>
				&nbsp;&nbsp;&nbsp; let msg = ref "hello"<br>
				&nbsp;&nbsp;&nbsp; printfn "%s" !msg<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let setMsg() =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg := "world"<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; setMsg()<br>
				&nbsp;&nbsp;&nbsp; printfn "%s" !msg<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; withSideEffects msg<br>
				&nbsp;&nbsp;&nbsp; printfn "%s" !msg<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; refTest()<br>
				&nbsp;&nbsp;&nbsp; Console.ReadKey(true) |&gt; ignore<br>
				&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>withSideEffects</span></span> <span lang="EN-US">function has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>val withSideEffects : string ref -&gt; unit</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">helloworldassigned from withSideEffects function</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>withSideEffects</span></span> <span lang="EN-US">function is named as such because it has a <em>side-effect</em>, meaning it can change the state of a variable in other functions. Ref Cells should be treated like fire. Use it cautiously when it is absolutetly necessary but avoid it in general. If you find yourself using Ref Cells while translating code from C/C++, then ignore efficiency for a while and see if you can get away without Ref Cells or at worst using mutable. You would often stumble upon a more elegant and more maintanable algorithm</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				Aliasing Ref Cells
			</h3>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US">Note:</span></span> <span lang="EN-US">While imperative programming uses aliasing extensively, this practice has a number of problems. In particular it makes programs hard to follow since the state of any variable can be modified at any point elsewhere in an application. Additionally, multithreaded applications sharing mutable state are difficult to reason about since one thread can potentially change the state of a variable in another thread, which can result in a number of subtle errors related to race conditions and dead locks.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">A ref cell is very similar to a C or C++ pointer. Its possible to point to two or more ref cells to the same memory address; changes at that memory address will change the state of all ref cells pointing to it. Conceptually, this process looks like this:</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Let's say we have 3 ref cells looking at the same address in memory:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Memory&nbsp;&nbsp; ____&nbsp; |____|&nbsp;&nbsp;&nbsp; cell1&nbsp; |____|&nbsp;&nbsp; /&nbsp; |__7_| - cell2&nbsp; |____|&nbsp;&nbsp; \&nbsp; |____|&nbsp;&nbsp;&nbsp; cell3</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>cell1</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>cell2</span></span><span lang="EN-US">, and</span> <span class="Teletyped"><span lang="EN-US" style=''>cell3</span></span> <span lang="EN-US">are all pointing to the same address in memory. The</span> <span class="Teletyped"><span lang="EN-US" style=''>.contents</span></span><span lang="EN-US">property of each cell is</span> <span class="Teletyped"><span lang="EN-US" style=''>7</span></span><span lang="EN-US">. Let's say, at some point in our program, we execute the code</span> <span class="Teletyped"><span lang="EN-US" style=''>cell1 := 10</span></span><span lang="EN-US">, this changes the value in memory to the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Memory&nbsp;&nbsp; ____&nbsp; |____|&nbsp;&nbsp;&nbsp; cell1&nbsp; |____|&nbsp;&nbsp; /&nbsp; |_10_| - cell2&nbsp; |____|&nbsp;&nbsp; \&nbsp; |____|&nbsp;&nbsp;&nbsp; cell3</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">By assigning</span> <span class="Teletyped"><span lang="EN-US" style=''>cell1.contents</span></span> <span lang="EN-US">a new value, the variables</span> <span class="Teletyped"><span lang="EN-US" style=''>cell2</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>cell3</span></span> <span lang="EN-US">were changed as well. This can be demonstrated using fsi as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let cell1 = ref 7;;<br>
				val cell1 : int ref<br>
				<br>
				&gt; let cell2 = cell1;;<br>
				val cell2 : int ref<br>
				<br>
				&gt; let cell3 = cell2;;<br>
				val cell3 : int ref<br>
				<br>
				&gt; !cell1;;<br>
				val it : int = 7<br>
				<br>
				&gt; !cell2;;<br>
				val it : int = 7<br>
				<br>
				&gt; !cell3;;<br>
				val it : int = 7<br>
				<br>
				&gt; cell1 := 10;;<br>
				val it : unit = ()<br>
				<br>
				&gt; !cell1;;<br>
				val it : int = 10<br>
				<br>
				&gt; !cell2;;<br>
				val it : int = 10<br>
				<br>
				&gt; !cell3;;<br>
				val it : int = 10</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Encapsulating Mutable State</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">F# discourages the practice of passing mutable data between functions. Functions that rely on mutation should generally hide its implementation details behind a private function, such as the following example in FSI:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let incr =<br>
				&nbsp;&nbsp;&nbsp; let counter = ref 0<br>
				&nbsp;&nbsp;&nbsp; fun () -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; counter := !counter + 1<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !counter;;<br>
				<br>
				val incr : (unit -&gt; int)<br>
				<br>
				&gt; incr();;<br>
				val it : int = 1<br>
				<br>
				&gt; incr();;<br>
				val it : int = 2<br>
				<br>
				&gt; incr();;<br>
				val it : int = 3</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Control Flow
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Control Flow</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">In all programming languages, <span class="Bold">control flow</span> refers to the decisions made in code that affect the order in which statements are executed in an application. F#'s imperative control flow elements are similar to those encountered in other languages.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Imperative Programming in a Nutshell</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Most programmers coming from a C#, Java, or C++ background are familiar with an imperative style of programming which uses loops, mutable data, and functions with side-effects in applications. While F# primarily encourages the use of a functional programming style, it has constructs which allow programmers to write code in a more imperative style as well. Imperative programming can be useful in the following situations:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Interacting with many objects in the .NET Framework, most of which are inherently imperative.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Interacting with components that depend heavily on side-effects, such as GUIs, I/O, and sockets.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Scripting and prototyping snippets of code.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Initializing complex data structures.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Optimizing blocks of code where an imperative version of an algorithm is more efficient than the functional version.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">if/then Decisions</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">F#'s</span> <span class="Teletyped"><span lang="EN-US" style=''>if/then/elif/else</span></span> <span lang="EN-US">construct has already been seen earlier in this book, but to introduce it more formally, the</span> <span class="Teletyped"><span lang="EN-US" style=''>if/then</span></span> <span lang="EN-US">construct has the following syntaxes:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">(* simple if *)<br>
				if expr then<br>
				&nbsp;&nbsp;&nbsp; expr<br>
				<br>
				(* binary if *)<br>
				if expr then<br>
				&nbsp;&nbsp;&nbsp; expr<br>
				else<br>
				&nbsp;&nbsp;&nbsp; expr<br>
				<br>
				(* multiple else branches *)<br>
				if expr then<br>
				&nbsp;&nbsp;&nbsp; expr<br>
				elif expr then<br>
				&nbsp;&nbsp;&nbsp; expr<br>
				elif expr then<br>
				&nbsp;&nbsp;&nbsp; expr<br>
				...<br>
				else<br>
				&nbsp;&nbsp;&nbsp; expr</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Like all F# blocks, the scope of an</span> <span class="Teletyped"><span lang="EN-US" style=''>if</span></span> <span lang="EN-US">statement extends to any code indented under it. For example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let printMessage condition =<br>
				&nbsp;&nbsp;&nbsp; if condition then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "condition = true: inside the 'if'"<br>
				&nbsp;&nbsp;&nbsp; printfn "outside the 'if' block"<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; printMessage true<br>
				&nbsp;&nbsp;&nbsp; printfn "--------"<br>
				&nbsp;&nbsp;&nbsp; printMessage false<br>
				&nbsp;&nbsp;&nbsp; Console.ReadKey(true) |&gt; ignore<br>
				&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program prints:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">condition = true: inside the 'if'outside the 'if' block--------outside the 'if' block</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Working With Conditions</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">F# has three boolean operators:</span>
			</p>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Symbol</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Description</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Example</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>&amp;&amp;</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Logical AND (infix, short-circuited)</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
						<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
							true &amp;&amp; false (* returns false *)
						</p>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>||</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Logical OR (infix, short-circuited)</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
						<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
							true || false (* returns true *)
						</p>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>not</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Logical NOT</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
						<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
							not false (* returns true *)
						</p>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>&amp;&amp;</span></span><span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>||</span></span> <span lang="EN-US">operators are short-circuited, meaning the CLR will perform the minimum evaluation necessary to determine whether the condition will succeed or fail. For example, if the left side of an</span> <span class="Teletyped"><span lang="EN-US" style=''>&amp;&amp;</span></span><span lang="EN-US">evaluates to</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>false</span></span><span lang="EN-US">, then there is no need to evaluate the right side; likewise, if the left side of a</span> <span class="Teletyped"><span lang="EN-US" style=''>||</span></span> <span lang="EN-US">evaluates to</span> <span class="Teletyped"><span lang="EN-US" style=''>true</span></span><span lang="EN-US">, then there is no need to evaluate the right side of the expression.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here is a demonstration of short-circuiting in F#:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let alwaysTrue() =<br>
				&nbsp;&nbsp;&nbsp; printfn "Always true"<br>
				&nbsp;&nbsp;&nbsp; true<br>
				&nbsp;&nbsp; &nbsp;<br>
				let alwaysFalse() =<br>
				&nbsp;&nbsp;&nbsp; printfn "Always false"<br>
				&nbsp;&nbsp;&nbsp; false<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let testCases =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ["alwaysTrue &amp;&amp; alwaysFalse", fun() -&gt; alwaysTrue() &amp;&amp; alwaysFalse();<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "alwaysFalse &amp;&amp; alwaysTrue", fun() -&gt; alwaysFalse() &amp;&amp; alwaysTrue();<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;"alwaysTrue || alwaysFalse", fun() -&gt; alwaysTrue() || alwaysFalse();<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "alwaysFalse || alwaysTrue", fun() -&gt; alwaysFalse() || alwaysTrue();]<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; testCases |&gt; List.iter (fun (msg, res) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "%s: %b" msg (res())<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "-------")<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; Console.ReadKey(true) |&gt; ignore<br>
				&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>alwaysTrue</span></span><span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>alwaysFalse</span></span> <span lang="EN-US">methods return</span> <span class="Teletyped"><span lang="EN-US" style=''>true</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>false</span></span> <span lang="EN-US">respectively, but they also have a side-effect of printing a message to the console whenever the functions are evaluated.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Always trueAlways falsealwaysTrue &amp;&amp; alwaysFalse: false-------Always falsealwaysFalse &amp;&amp; alwaysTrue: false-------Always truealwaysTrue || alwaysFalse: true-------Always falseAlways truealwaysFalse || alwaysTrue: true-------</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">As you can see above, the expression</span> <span class="Teletyped"><span lang="EN-US" style=''>alwaysTrue &amp;&amp; alwaysFalse</span></span> <span lang="EN-US">evaluates both sides of the expression.</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>alwaysFalse &amp;&amp; alwaysTrue</span></span> <span lang="EN-US">only evaluates the left side of the expression; since the left side returns</span> <span class="Teletyped"><span lang="EN-US" style=''>false</span></span><span lang="EN-US">, its unnecessary to evaluate the right side.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">for Loops Over Ranges</span>
			</h2>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>for</span></span> <span lang="EN-US">loops are traditionally used to iterate over a well-defined integer range. The syntax of a</span> <span class="Teletyped"><span lang="EN-US" style=''>for</span></span> <span lang="EN-US">loop is defined as:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">for var = start-expr to end-expr do<br>
				&nbsp;&nbsp;&nbsp; ... // loop body</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here's a trivial program which prints out the numbers 1 - 10:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let main() =<br>
				&nbsp;&nbsp;&nbsp; for i = 1 to 10 do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "i: %i" i<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">i: 1i: 2i: 3i: 4i: 5i: 6i: 7i: 8i: 9i: 10</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This code takes input from the user to compute an average:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; Console.WriteLine("This program averages numbers input by the user.")<br>
				&nbsp;&nbsp;&nbsp; Console.Write("How many numbers do you want to add? ")<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let mutable sum = 0<br>
				&nbsp;&nbsp;&nbsp; let numbersToAdd = Console.ReadLine() |&gt; int<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; for i = 1 to numbersToAdd do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write("Input #{0}: ", i)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let input = Console.ReadLine() |&gt; int<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum &lt;- sum + input<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let average = sum / numbersToAdd<br>
				&nbsp;&nbsp;&nbsp; Console.WriteLine("Average: {0}", average)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">This program averages numbers input by the user.How many numbers do you want to add? 3Input #1: 100Input #2: 90Input #3: 50Average: 80</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">for Loops Over Collections and Sequences</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Its often convenient to iterate over collections of items using the syntax:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">for pattern in expr do<br>
				&nbsp;&nbsp;&nbsp; ... // loop body</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">For example, we can print out a shopping list in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let shoppingList =<br>
				&nbsp;&nbsp;&nbsp; ["Tofu", 2, 1.99;<br>
				&nbsp;&nbsp;&nbsp; "Seitan", 2, 3.99;<br>
				&nbsp;&nbsp;&nbsp; "Tempeh", 3, 2.69;<br>
				&nbsp;&nbsp;&nbsp; "Rice milk", 1, 2.95;];;<br>
				<br>
				val shoppingList : (string * int * float) list<br>
				<br>
				&gt; for (food, quantity, price) in shoppingList do<br>
				&nbsp;&nbsp;&nbsp; printfn "food: %s, quantity: %i, price: %g" food quantity price;;<br>
				food: Tofu, quantity: 2, price: 1.99<br>
				food: Seitan, quantity: 2, price: 3.99<br>
				food: Tempeh, quantity: 3, price: 2.69<br>
				food: Rice milk, quantity: 1, price: 2.95</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">while Loops</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">As the name suggests,</span> <span class="Teletyped"><span lang="EN-US" style=''>while</span></span> <span lang="EN-US">loops will repeat a block of code indefinitely while a particular condition is true. The syntax of a</span> <span class="Teletyped"><span lang="EN-US" style=''>while</span></span> <span lang="EN-US">loop is defined as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">while expr do<br>
				&nbsp;&nbsp;&nbsp; ... // loop body</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We use a while loop when we don't know how many times to execute a block of code. For example, lets say we wanted the user to guess a password to a secret area; the user could get the password right on the first try, or the user could try millions of passwords, we just don't know. Here is a short program that requires a user to guess a password correctly in at least 3 attempts:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let password = "monkey"<br>
				&nbsp;&nbsp;&nbsp; let mutable guess = String.Empty<br>
				&nbsp;&nbsp;&nbsp; let mutable attempts = 0<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; while password &lt;&gt; guess &amp;&amp; attempts &lt; 3 do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write("What's the password? ")<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempts &lt;- attempts + 1<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; guess &lt;- Console.ReadLine()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; if password = guess then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine("You got the password right!")<br>
				&nbsp;&nbsp;&nbsp; else<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine("You didn't guess the password")<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; Console.ReadKey(true) |&gt; ignore<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">What's the password? kittyWhat's the password? monkeyYou got the password right!</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Arrays
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Arrays</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Arrays</span></span> <span lang="EN-US">are a ubiquitous, a familiar data structure used to represent a group of related, ordered values. Unlike F# data structures, arrays are mutable, meaning the values in an array can be changed after the array has been created.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Creating Arrays</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Arrays are conceptually similar to lists. Naturally, arrays can be created using many of the same techniques as lists:</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Array literals</span>
			</h3>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; [| 1; 2; 3; 4; 5 |];;<br>
				val it : int array = [|1; 2; 3; 4; 5|]</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Array comprehensions</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">F# supports array comprehensions using ranges and generators in the same style and format as <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Lists%23Using_List_Comprehensions"><span style='color:windowtext;text-decoration:none'>list comprehensions</span></a>:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; [| 1 .. 10 |];;<br>
				val it : int array = [|1; 2; 3; 4; 5; 6; 7; 8; 9; 10|]<br>
				<br>
				&gt; [| 1 .. 3 .. 10 |];;<br>
				val it : int array = [|1; 4; 7; 10|]<br>
				<br>
				&gt; [| for a in 1 .. 5 do<br>
				&nbsp;&nbsp;&nbsp; yield (a, a*a, a*a*a) |];;<br>
				val it : (int * int * int) array<br>
				= [|(1, 1, 1); (2, 4, 8); (3, 9, 27); (4, 16, 64); (5, 25, 125)|]</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">System.Array Methods</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">There are several methods in the</span> <span class="Teletyped"><span lang="EN-US" style=''>System.Array</span></span> <span lang="EN-US">module for creating arrays:</span>
			</p>
			<p class="HorizontalLine">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val zeroCreate : int arraySize -&gt; 'T []</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Creates an array with</span> <span class="Teletyped"><span lang="EN-US" style=''>arraySize</span></span> <span lang="EN-US">elements. Each element in the array holds the default value for the particular data type (</span><span class="Teletyped"><span lang="EN-US" style=''>0</span></span> <span lang="EN-US">for numbers,</span> <span class="Teletyped"><span lang="EN-US" style=''>false</span></span> <span lang="EN-US">for bools,</span> <span class="Teletyped"><span lang="EN-US" style=''>null</span></span> <span lang="EN-US">for reference types).</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let (x : int array) = Array.zeroCreate 5;;<br>
				val x : int array<br>
				<br>
				&gt; x;;<br>
				val it : int array = [|0; 0; 0; 0; 0|]</span>
			</p>
			<p class="HorizontalLine">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val create : int -&gt; 'T value -&gt; 'T []</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Creates an array with</span> <span class="Teletyped"><span lang="EN-US" style=''>arraySize</span></span> <span lang="EN-US">elements. Initializes each element in the array with</span> <span class="Teletyped"><span lang="EN-US" style=''>value</span></span><span lang="EN-US">.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; Array.create 5 "Juliet";;<br>
				val it : string [] = [|"Juliet"; "Juliet"; "Juliet"; "Juliet"; "Juliet"|]</span>
			</p>
			<p class="HorizontalLine">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val init : int arraySize -&gt; (int index -&gt; 'T) initializer -&gt; 'T []</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Creates an array with</span> <span class="Teletyped"><span lang="EN-US" style=''>arraySize</span></span> <span lang="EN-US">elements. Initializes each element in the array with the</span> <span class="Teletyped"><span lang="EN-US" style=''>initializer</span></span> <span lang="EN-US">function.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; Array.init 5 (fun index -&gt; sprintf "index: %i" index);;<br>
				val it : string []<br>
				= [|"index: 0"; "index: 1"; "index: 2"; "index: 3"; "index: 4"|]</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Working With Arrays</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Elements in an array are accessed by their <em>index</em>, or position in an array. Array indexes always start at</span> <span class="Teletyped"><span lang="EN-US" style=''>0</span></span> <span lang="EN-US">and end at</span> <span class="Teletyped"><span lang="EN-US" style=''>array.length - 1</span></span><span lang="EN-US">. For example, lets take the following array:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let names = [| "Juliet"; "Monique"; "Rachelle"; "Tara"; "Sophia" |]<br>
				(* Indexes:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 *)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This list contains 5 items. The first index is</span> <span class="Teletyped"><span lang="EN-US" style=''>0</span></span><span lang="EN-US">, and the last index is</span> <span class="Teletyped"><span lang="EN-US" style=''>4</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can access items in the list using the</span> <span class="Teletyped"><span lang="EN-US" style=''>.[index]</span></span> <span lang="EN-US">operator, also called indexer notation. Here is the same list in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let names = [| "Juliet"; "Monique"; "Rachelle"; "Tara"; "Sophia" |];;<br>
				<br>
				val names : string array<br>
				<br>
				&gt; names.[2];;<br>
				val it : string = "Rachelle"<br>
				<br>
				&gt; names.[0];;<br>
				val it : string = "Juliet"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Instances of arrays have a</span> <span class="Teletyped"><span lang="EN-US" style=''>Length</span></span> <span lang="EN-US">property which returns the number of elements in the array:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; names.Length;;<br>
				val it : int = 5<br>
				<br>
				&gt; for i = 0 to names.Length - 1 do<br>
				&nbsp;&nbsp;&nbsp; printfn "%s" (names.[i]);;<br>
				Juliet<br>
				Monique<br>
				Rachelle<br>
				Tara<br>
				Sophia</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Arrays are mutable data structures, meaning we can assign elements in an array new values at any point in our program:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; names;;<br>
				val it : string array = [|"Juliet"; "Monique"; "Rachelle"; "Tara"; "Sophia"|]<br>
				<br>
				&gt; names.[4] &lt;- "Kristen";;<br>
				val it : unit = ()<br>
				<br>
				&gt; names;;<br>
				val it : string array = [|"Juliet"; "Monique"; "Rachelle"; "Tara"; "Kristen"|]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">If you try to access an element outside the range of an array, you'll get an exception:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; names.[-1];;<br>
				System.IndexOutOfRangeException: Index was outside the bounds of the array.<br>
				&nbsp;&nbsp; at &lt;StartupCode$FSI_0029&gt;.$FSI_0029._main()<br>
				stopped due to error<br>
				<br>
				&gt; names.[5];;<br>
				System.IndexOutOfRangeException: Index was outside the bounds of the array.<br>
				&nbsp;&nbsp; at &lt;StartupCode$FSI_0030&gt;.$FSI_0030._main()<br>
				stopped due to error</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Array Slicing</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">F# supports a few useful operators which allow programmers to return "slices" or subarrays of an array using the</span> <span class="Teletyped"><span lang="EN-US" style=''>.[start..finish]</span></span> <span lang="EN-US">operator, where one of the</span> <span class="Teletyped"><span lang="EN-US" style=''>start</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>finish</span></span> <span lang="EN-US">arguments may be omitted.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let names = [|"0: Juliet"; "1: Monique"; "2: Rachelle"; "3: Tara"; "4: Sophia"|];;<br>
				<br>
				val names : string array<br>
				<br>
				&gt; names.[1..3];; (* Grabs items between index 1 and 3 *)<br>
				val it : string [] = [|"1: Monique"; "2: Rachelle"; "3: Tara"|]<br>
				<br>
				&gt; names.[2..];; (* Grabs items between index 2 and last element *)<br>
				val it : string [] = [|"2: Rachelle"; "3: Tara"; "4: Sophia"|]<br>
				<br>
				&gt; names.[..3];; (* Grabs items between first element and index 3 *)<br>
				val it : string [] = [|"0: Juliet"; "1: Monique"; "2: Rachelle"; "3: Tara"|]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Note that array slices generate a new array, rather than altering the existing array. This requires allocating new memory and copying elements from our source array into our target array. If performance is a high priority, it is generally more efficient to look at parts of an array using a few index adjustments.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Multi-dimensional Arrays</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">A multi-dimensional array is literally an array of arrays. Conceptually, its not any harder to work with these types of arrays than single-dimensional arrays (as shown above). Multi-dimensional arrays come in two forms: rectangular and jagged arrays.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h4 class="Heading3">
				<span lang="EN-US">Rectangular Arrays</span>
			</h4>
			<p class="TextBody">
				<span lang="EN-US">A rectangular array, which may be called a grid or a matrix, is an array of arrays, where all of the inner arrays have the same length. Here is a simple 2x3 rectangular array in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; Array2D.zeroCreate&lt;int&gt; 2 3;;<br>
				val it : int [,] = [|[|0; 0; 0|]; [|0; 0; 0|]|]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This array has 2 rows, and each row has 3 columns. To access elements in this array, you use the</span> <span class="Teletyped"><span lang="EN-US" style=''>.[row,col]</span></span> <span lang="EN-US">operator:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let grid = Array2D.init&lt;string&gt; 3 3 (fun row col -&gt; sprintf "row: %i, col: %i" row col);;<br>
				<br>
				val grid : string [,]<br>
				<br>
				&gt; grid;;<br>
				val it : string [,]<br>
				= [|[|"row: 0, col: 0"; "row: 0, col: 1"; "row: 0, col: 2"|];<br>
				&nbsp;&nbsp;&nbsp; [|"row: 1, col: 0"; "row: 1, col: 1"; "row: 1, col: 2"|];<br>
				&nbsp;&nbsp;&nbsp; [|"row: 2, col: 0"; "row: 2, col: 1"; "row: 2, col: 2"|]|]<br>
				<br>
				&gt; grid.[0, 1];;<br>
				val it : string = "row: 0, col: 1"<br>
				<br>
				&gt; grid.[1, 2];;<br>
				val it : string = "row: 1, col: 2"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here's a simple program to demonstrate how to use and iterate through multidimensional arrays:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let printGrid grid =<br>
				&nbsp;&nbsp;&nbsp; let maxY = (Array2D.length1 grid) - 1<br>
				&nbsp;&nbsp;&nbsp; let maxX = (Array2D.length2 grid) - 1<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; for row in 0 .. maxY do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for col in 0 .. maxX do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if grid.[row, col] = true then Console.Write("* ")<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else Console.Write("_ ")<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine()<br>
				<br>
				let toggleGrid (grid : bool[,]) =<br>
				&nbsp;&nbsp;&nbsp; Console.WriteLine()<br>
				&nbsp;&nbsp;&nbsp; Console.WriteLine("Toggle grid:")<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let row =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write("Row: ")<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.ReadLine() |&gt; int<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let col =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write("Col: ")<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.ReadLine() |&gt; int<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; grid.[row, col] &lt;- (not grid.[row, col])<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; Console.WriteLine("Create a grid:")<br>
				&nbsp;&nbsp;&nbsp; let rows =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write("Rows: ")<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.ReadLine() |&gt; int<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let cols =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write("Cols: ")<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.ReadLine() |&gt; int<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let grid = Array2D.zeroCreate&lt;bool&gt; rows cols<br>
				&nbsp;&nbsp;&nbsp; printGrid grid<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let mutable go = true<br>
				&nbsp;&nbsp;&nbsp; while go do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toggleGrid grid<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printGrid grid<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write("Keep playing (y/n)? ")<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; go &lt;- Console.ReadLine() = "y"<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; Console.WriteLine("Thanks for playing")<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Create a grid:Rows: 2Cols: 3_ _ __ _ _Toggle grid:Row: 0Col: 1_ * __ _ _Keep playing (y/n)? yToggle grid:Row: 1Col: 1_ * __ * _Keep playing (y/n)? yToggle grid:Row: 1Col: 2_ * __ * *Keep playing (y/n)? nThanks for playing</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In additional to the</span> <span class="Teletyped"><span lang="EN-US" style=''>Array2D</span></span> <span lang="EN-US">module, F# has an</span> <span class="Teletyped"><span lang="EN-US" style=''>Array3D</span></span> <span lang="EN-US">module to support 3-dimensional arrays as well.</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US">Note</span></span> <span lang="EN-US">Its possible to create arrays with more than 3 dimensions using the</span> <span class="Teletyped"><span lang="EN-US" style=''>System.Array.CreateInstance</span></span> <span lang="EN-US">method, but its generally recommended to avoid creating arrays with huge numbers of elements or dimensions, since it can quickly consume all of the available memory on a machine. For comparison, an</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">is 4 bytes, and a 1000x1000x1000</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">array would consume about 3.7 GB of memory, more than the memory available on 99% of desktop PCs.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h4 class="Heading3">
				<span lang="EN-US">Jagged arrays</span>
			</h4>
			<p class="TextBody">
				<span lang="EN-US">A jagged array is an array of arrays, except each row in the array does not necessary need to have the same number of elements:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; [| for a in 1 .. 5 do yield [| 1 .. a |] |];;<br>
				val it : int array array<br>
				= [|[|1|];<br>
				&nbsp;&nbsp;&nbsp; [|1; 2|];<br>
				&nbsp;&nbsp;&nbsp; [|1; 2; 3|];<br>
				&nbsp;&nbsp;&nbsp; [|1; 2; 3; 4|];<br>
				&nbsp;&nbsp;&nbsp; [|1; 2; 3; 4; 5|]|]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">You use the</span> <span class="Teletyped"><span lang="EN-US" style=''>.[index]</span></span><span lang="EN-US">operator to access items in the array. Since each element contains another array, its common to see code that resembles</span> <span class="Teletyped"><span lang="EN-US" style=''>.[row].[col]</span></span><span lang="EN-US">:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let jagged = [| for a in 1 .. 5 do yield [| 1 .. a |] |]<br>
				for arr in jagged do<br>
				&nbsp;&nbsp;&nbsp; for col in arr do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf "%i " col<br>
				&nbsp;&nbsp;&nbsp; printfn "";;<br>
				<br>
				val jagged : int array array<br>
				<br>
				1<br>
				1 2<br>
				1 2 3<br>
				1 2 3 4<br>
				1 2 3 4 5<br>
				<br>
				&gt; jagged.[2].[2];;<br>
				val it : int = 3<br>
				<br>
				&gt; jagged.[4].[0];;<br>
				val it : int = 1</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US">Note:</span></span> <span lang="EN-US">Notice that the data type of a rectangular array is</span> <span class="Teletyped"><span lang="EN-US" style=''>'a[,]</span></span><span lang="EN-US">, but the data type of a jagged array is</span> <span class="Teletyped"><span lang="EN-US" style=''>'a array array</span></span><span lang="EN-US">. This results because a rectangular array stores data "flat", whereas a jagged array is literally an array of <em>pointers to arrays</em>. Since these two types of arrays are stored differently in memory, F# treats</span> <span class="Teletyped"><span lang="EN-US" style=''>'a[,]</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>'a array array</span></span> <span lang="EN-US">as two different, non-interchangeable data types. As a result, rectangular and jagged arrays have slightly different syntax for element access.</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Rectangular arrays are stored in a slightly more efficient manner and generally perform better than jagged arrays, although there may not be a perceptible difference in most applications. However, its worth noting performance differences between the two in</span> <a href="http://msdn.microsoft.com/en-us/magazine/cc163995.aspx#S10"><span lang="EN-US" style='color:windowtext;text-decoration:none'>benchmark tests</span></a><span lang="EN-US">.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Using the Array Module</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">There are two array modules,</span> <span class="Teletyped"><span lang="EN-US" style=''>System.Array</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Microsoft.FSharp.Collections.Array</span></span><span lang="EN-US">, developed by the .NET BCL designers and the creators of F# respectively. Many of the methods and functions in the F# Array module are similar to those in the List module.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span style=''>val append : 'T[] first -&gt; 'T[] second -&gt; 'T[]</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Returns a new array with elements consisting of the first array followed by the second array.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val choose : ('T item -&gt; 'U option) -&gt; 'T[] input -&gt; 'U[]</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Filters and maps an array, returning a new array consisting of all elements which returned</span> <span class="Teletyped"><span lang="EN-US" style=''>Some</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span style=''>val copy : 'T[] input -&gt; 'T[]</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Returns a copy of the input array.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val fill : 'T[] input -&gt; int start -&gt; int end -&gt; 'T value -&gt; unit</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Assigns</span> <span class="Teletyped"><span lang="EN-US" style=''>value</span></span> <span lang="EN-US">to all the elements between the start and end indexes.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span style=''>val filter : ('T -&gt; bool) -&gt; 'T[] -&gt; 'T[]</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Returns a new array consisting of items filtered out of the input array.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val fold : ('State -&gt; 'T -&gt; 'State) -&gt; 'State -&gt; 'T[] input -&gt; 'State</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Accumulates left to right over an array.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val foldBack : ('T -&gt; 'State -&gt; 'State) -&gt; 'T[] input -&gt; 'State -&gt; 'State</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Accumulates right to left over an array.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span style=''>val iter : ('T -&gt; unit) -&gt; 'T[] input -&gt; unit</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Applies a function to all of the elements of the input array.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val length : 'T[] -&gt; int</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Returns the number of items in an array.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span style=''>val map : ('T -&gt; 'U) -&gt; 'T[] -&gt; 'U[]</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Applies a mapping function to each element in the input array to return a new array.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span style=''>val rev : 'T[] input -&gt; 'T[]</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Returns a new array with the items in reverse order.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val sort : 'T[] -&gt; 'T[]</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Sorts a copy of an array.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val sortInPlace : 'T[] -&gt; unit</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Sorts an array in place. Note that the</span> <span class="Teletyped"><span lang="EN-US" style=''>sortInPlace</span></span> <span lang="EN-US">method returns</span> <span class="Teletyped"><span lang="EN-US" style=''>unit</span></span><span lang="EN-US">, indicating the</span> <span class="Teletyped"><span lang="EN-US" style=''>sortInPlace</span></span> <span lang="EN-US">mutates the original array.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span style=''>val sortBy : ('T -&gt; 'T -&gt; int) -&gt; 'T[] -&gt; 'T[]</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Sorts a copy of an array based on the sorting function.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val sub : 'T[] -&gt; int start -&gt; int end -&gt; 'T[]</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Returns a sub array based on the given start and end indexes.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				Differences Between Arrays and Lists
			</h2>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Lists</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <img width="15" height="1" src="F_files/image001.gif" align="left" hspace="12"><span lang="EN-US">Immutable, allows new lists to share nodes with other lists.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <img width="15" height="1" src="F_files/image001.gif" align="left" hspace="12"><span lang="EN-US">List literals.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <img width="15" height="1" src="F_files/image001.gif" align="left" hspace="12"><span lang="EN-US">Pattern matching.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <img width="15" height="1" src="F_files/image001.gif" align="left" hspace="12"><span lang="EN-US">Supports mapping and folding.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <img width="15" height="1" src="F_files/image002.gif" align="left" hspace="12"><span lang="EN-US">Linear lookup time.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <img width="15" height="1" src="F_files/image002.gif" align="left" hspace="12"><span lang="EN-US">No random access to elements, just "forward-only" traversal.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Arrays</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <img width="15" height="1" src="F_files/image001.gif" align="left" hspace="12"><span lang="EN-US">Array literals.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <img width="15" height="1" src="F_files/image001.gif" align="left" hspace="12"><span lang="EN-US">Constant lookup time.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <img width="15" height="1" src="F_files/image001.gif" align="left" hspace="12"><span lang="EN-US">Good spacial locality of reference ensures efficient lookup time.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <img width="15" height="1" src="F_files/image001.gif" align="left" hspace="12"><span lang="EN-US">Indexes indicate the position of each element relative to others, making arrays ideal for random access.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <img width="15" height="1" src="F_files/image001.gif" align="left" hspace="12"><span lang="EN-US">Supports mapping and folding.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <img width="15" height="1" src="F_files/image002.gif" align="left" hspace="12"><span lang="EN-US">Mutability prevents arrays from sharing nodes with other elements in an array.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <img width="15" height="1" src="F_files/image002.gif" align="left" hspace="12"><span lang="EN-US">Not resizable.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Representation in Memory
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Items in an array are represented in memory as adjacent values in memory. For example, lets say we create the following int array:</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Teletyped"><span style=''>[| 15; 5; 21; 0; 9 |]</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Represented in memory, our array resembles something like this:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Memory Location: |&nbsp; 100 |&nbsp; 104 |&nbsp; 108 |&nbsp; 112 |&nbsp; 116&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value: |&nbsp;&nbsp; 15 |&nbsp;&nbsp;&nbsp; 5 |&nbsp;&nbsp; 21 |&nbsp;&nbsp;&nbsp; 0 |&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index: |&nbsp;&nbsp;&nbsp; 0 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 2 |&nbsp;&nbsp;&nbsp; 3 |&nbsp;&nbsp;&nbsp; 4</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Each</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">occupies 4 bytes of memory. Since our array contains 5 elements, the operating systems allocates 20 bytes of memory to hold this array (4 bytes * 5 elements = 20 bytes). The first first element in the array occupies memory 100-103, the second element occupies 104-107, and so on.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We know that each element in the array is identified by its <em>index</em> or position in the array. Literally, the index is an offset: since the array starts at memory location 100, and each element in the array occupies a fixed amount of memory, the operating system can know the exact address of each element in memory using the formula:</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Start memory address of element at index</span> <span class="Teletyped"><span lang="EN-US" style=''>n</span></span> <span lang="EN-US">= StartPosition of array + (</span><span class="Teletyped"><span lang="EN-US" style=''>n</span></span> <span lang="EN-US">* length of data type)</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">End memory address of element at index</span> <span class="Teletyped"><span lang="EN-US" style=''>n</span></span> <span lang="EN-US">= Start memory address + length of data type</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In laymens terms, this means we can access the <em>nth</em> element of any array in constant time, or in O(1) operations. This is in contrast to lists, where accessing the <em>nth</em> element requires O(n) operations.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">With the understanding that elements in an array occupy adjacent memory locations, we can deduce two properties of arrays:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Creating arrays requires programmers to specify the size of the array upfront, otherwise the operating system won't know how many adjacent memory locations to allocate.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 2.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Arrays are not resizable, because memory locations before the first element or beyond the last element may hold data used by other applications. An array is only "resized" by allocating a new block of memory and copying all of the elements from the old array into the new array.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Mutable Collections
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Mutable Collections</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">The .NET BCL comes with its own suite of <span class="Bold">mutable collections</span> which are found in the <a href="http://msdn.microsoft.com/en-us/library/system.collections.generic.aspx"><span style='color:windowtext;text-decoration:none'>System.Collections.Generic</span></a> namespace. These built-in collections are very similar to their immutable counterparts in F#.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">List&lt;'T&gt; Class</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/6sh2ey19.aspx"><span style='color:windowtext;text-decoration:none'>List&lt;'T&gt;</span></a></span></span> <span lang="EN-US">class represents a strongly typed list of objects that can be accessed by index. Conceptually, this makes the</span> <span class="Teletyped"><span lang="EN-US" style=''>List&lt;'T&gt;</span></span> <span lang="EN-US">class similar to <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Arrays"><span style='color:windowtext;text-decoration:none'>arrays</span></a>. However, unlike arrays,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>List</span></span><span lang="EN-US">s can be resized and don't need to have their size specified on declaration.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">.NET lists are created using the</span> <span class="Teletyped"><span lang="EN-US" style=''>new</span></span> <span lang="EN-US">keyword and calling the list's constructor as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; open System.Collections.Generic;;<br>
				&gt; let myList = new List&lt;string&gt;();;<br>
				<br>
				val myList : List&lt;string&gt;<br>
				<br>
				&gt; myList.Add("hello");;<br>
				val it : unit = ()<br>
				&gt; myList.Add("world");;<br>
				val it : unit = ()<br>
				&gt; myList.[0];;<br>
				val it : string = "hello"<br>
				&gt; myList |&gt; Seq.iteri (fun index item -&gt; printfn "%i: %s" index myList.[index]);;<br>
				0: hello<br>
				1: world</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">It's easy to tell that .NET lists are mutable because their</span> <span class="Teletyped"><span lang="EN-US" style=''>Add</span></span> <span lang="EN-US">methods return</span> <span class="Teletyped"><span lang="EN-US" style=''>unit</span></span> <span lang="EN-US">rather than returning another list.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Underlying Implementation</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Behind the scenes, the</span> <span class="Teletyped"><span lang="EN-US" style=''>List&lt;'T&gt;</span></span> <span lang="EN-US">class is just a fancy wrapper for an array. When a</span> <span class="Teletyped"><span lang="EN-US" style=''>List&lt;'T&gt;</span></span> <span lang="EN-US">is constructed, it creates an 4-element array in memory. Adding the first 4 items is an <em>O(1)</em> operation. However, as soon as the 5th element needs to be added, the list doubles the size of the internal array, which means it has to reallocate new memory and copy elements in the existing list; this is a <em>O(n)</em> operation, where <em>n</em> is the number of items in the list.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>List&lt;'T&gt;.Count</span></span> <span lang="EN-US">property returns the number of items currently held in the collection, the</span> <span class="Teletyped"><span lang="EN-US" style=''>List&lt;'T&gt;.Capacity</span></span> <span lang="EN-US">collection returns the size of the underlying array. This code sample demonstrates how the underlying array is resized:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				open System.Collections.Generic<br>
				<br>
				let items = new List&lt;string&gt;()<br>
				<br>
				let printList (l : List&lt;_&gt;) =<br>
				&nbsp;&nbsp;&nbsp; printfn "l.Count: %i, l.Capacity: %i" l.Count l.Capacity<br>
				&nbsp;&nbsp;&nbsp; printfn "Items:"<br>
				&nbsp;&nbsp;&nbsp; l |&gt; Seq.iteri (fun index item -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "&nbsp;&nbsp;&nbsp; l.[%i]: %s" index l.[index])<br>
				&nbsp;&nbsp;&nbsp; printfn "-----------"<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; printList items<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; items.Add("monkey")<br>
				&nbsp;&nbsp;&nbsp; printList items<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; items.Add("kitty")<br>
				&nbsp;&nbsp;&nbsp; items.Add("bunny")<br>
				&nbsp;&nbsp;&nbsp; printList items<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; items.Add("doggy")<br>
				&nbsp;&nbsp;&nbsp; items.Add("octopussy")<br>
				&nbsp;&nbsp;&nbsp; items.Add("ducky")<br>
				&nbsp;&nbsp;&nbsp; printList items<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printfn "Removing entry for \"doggy\"\n--------\n"<br>
				&nbsp;&nbsp;&nbsp; items.Remove("doggy") |&gt; ignore<br>
				&nbsp;&nbsp;&nbsp; printList items<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printfn "Removing item at index 3\n--------\n"<br>
				&nbsp;&nbsp;&nbsp; items.RemoveAt(3)<br>
				&nbsp;&nbsp;&nbsp; printList items<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; Console.ReadKey(true) |&gt; ignore<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">l.Count: 0, l.Capacity: 0Items:-----------l.Count: 1, l.Capacity: 4Items:&nbsp;&nbsp;&nbsp; l.[0]: monkey-----------l.Count: 3, l.Capacity: 4Items:&nbsp;&nbsp;&nbsp; l.[0]: monkey&nbsp;&nbsp;&nbsp; l.[1]: kitty&nbsp;&nbsp;&nbsp; l.[2]: bunny-----------l.Count: 6, l.Capacity: 8Items:&nbsp;&nbsp;&nbsp; l.[0]: monkey&nbsp;&nbsp;&nbsp; l.[1]: kitty&nbsp;&nbsp;&nbsp; l.[2]: bunny&nbsp;&nbsp;&nbsp; l.[3]: doggy&nbsp;&nbsp;&nbsp; l.[4]: octopussy&nbsp;&nbsp;&nbsp; l.[5]: ducky-----------Removing entry for "doggy"--------l.Count: 5, l.Capacity: 8Items:&nbsp;&nbsp;&nbsp; l.[0]: monkey&nbsp;&nbsp;&nbsp; l.[1]: kitty&nbsp;&nbsp;&nbsp; l.[2]: bunny&nbsp;&nbsp;&nbsp; l.[3]: octopussy&nbsp;&nbsp;&nbsp; l.[4]: ducky-----------Removing item at index 3--------l.Count: 4, l.Capacity: 8Items:&nbsp;&nbsp;&nbsp; l.[0]: monkey&nbsp;&nbsp;&nbsp; l.[1]: kitty&nbsp;&nbsp;&nbsp; l.[2]: bunny&nbsp;&nbsp;&nbsp; l.[3]: ducky-----------</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">If you know the maximum size of the list beforehand, it is possible to avoid the performance hit by calling the</span> <span class="Teletyped"><span lang="EN-US" style=''>List&lt;'T&gt;(size : int)</span></span> <span lang="EN-US">constructor instead. The following sample demonstrates how to add 1000 items to a list without resizing the internal array:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let myList = new List&lt;int&gt;(1000);;<br>
				<br>
				val myList : List&lt;int&gt;<br>
				<br>
				&gt; myList.Count, myList.Capacity;;<br>
				val it : int * int = (0, 1000)<br>
				&gt; seq { 1 .. 1000 } |&gt; Seq.iter (fun x -&gt; myList.Add(x));;<br>
				val it : unit = ()<br>
				&gt; myList.Count, myList.Capacity;;<br>
				val it : int * int = (1000, 1000)</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">LinkedList&lt;'T&gt; Class</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">A</span> <span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/he2s3bh7.aspx"><span style='color:windowtext;text-decoration:none'>LinkedList&lt;'T&gt;</span></a></span></span> <span lang="EN-US">represented a doubly-linked sequence of nodes which allows efficient <em>O(1)</em> inserts and removal, supports forward and backward traversal, but its implementation prevents efficient random access. Linked lists have a few valuable methods:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">(* Prepends an item to the LinkedList *)<br>
				val AddFirst : 'T -&gt; LinkedListNode&lt;'T&gt;<br>
				<br>
				(* Appends an items to the LinkedList *)<br>
				val AddLast : 'T -&gt; LinkedListNode&lt;'T&gt;<br>
				<br>
				(* Adds an item before a LinkedListNode *)<br>
				val AddBefore : LinkedListNode&lt;'T&gt; -&gt; 'T -&gt; LinkedListNode&lt;'T&gt;<br>
				<br>
				(* Adds an item after a LinkedListNode *)<br>
				val AddAfter : LinkedListNode&lt;'T&gt; -&gt; 'T -&gt; LinkedListNode&lt;'T&gt;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Note that these methods return a</span> <span class="Teletyped"><span lang="EN-US" style=''>LinkedListNode&lt;'T&gt;</span></span><span lang="EN-US">, not a new</span> <span class="Teletyped"><span lang="EN-US" style=''>LinkedList&lt;'T&gt;</span></span><span lang="EN-US">. Adding nodes actually mutates the</span> <span class="Teletyped"><span lang="EN-US" style=''>LinkedList</span></span><span lang="EN-US">object:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; open System.Collections.Generic;;<br>
				&gt; let items = new LinkedList&lt;string&gt;();;<br>
				<br>
				val items : LinkedList&lt;string&gt;<br>
				<br>
				&gt; items.AddLast("AddLast1");;<br>
				val it : LinkedListNode&lt;string&gt;<br>
				= System.Collections.Generic.LinkedListNode`1[System.String]<br>
				&nbsp;&nbsp;&nbsp; {List = seq ["AddLast1"];<br>
				&nbsp;&nbsp;&nbsp;&nbsp; Next = null;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; Previous = null;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; Value = "AddLast1";}<br>
				&gt; items.AddLast("AddLast2");;<br>
				val it : LinkedListNode&lt;string&gt;<br>
				= System.Collections.Generic.LinkedListNode`1[System.String]<br>
				&nbsp;&nbsp;&nbsp; {List = seq ["AddLast1"; "AddLast2"];<br>
				&nbsp;&nbsp;&nbsp;&nbsp; Next = null;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; Previous = System.Collections.Generic.LinkedListNode`1[System.String];<br>
				&nbsp;&nbsp;&nbsp;&nbsp; Value = "AddLast2";}<br>
				&gt; let firstItem = items.AddFirst("AddFirst1");;<br>
				<br>
				val firstItem : LinkedListNode&lt;string&gt;<br>
				<br>
				&gt; let addAfter = items.AddAfter(firstItem, "addAfter");;<br>
				<br>
				val addAfter : LinkedListNode&lt;string&gt;<br>
				<br>
				&gt; let addBefore = items.AddBefore(addAfter, "addBefore");;<br>
				<br>
				val addBefore : LinkedListNode&lt;string&gt;<br>
				<br>
				&gt; items |&gt; Seq.iter (fun x -&gt; printfn "%s" x);;<br>
				AddFirst1<br>
				addBefore<br>
				addAfter<br>
				AddLast1<br>
				AddLast2</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>Stack&lt;'T&gt;</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Queue&lt;'T&gt;</span></span> <span lang="EN-US">classes are special cases of a linked list (they can be thought of as linked lists with restrictions on where you can add and remove items).</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Stack&lt;'T&gt; Class</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">A</span> <span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/3278tedw.aspx"><span style='color:windowtext;text-decoration:none'>Stack&lt;'T&gt;</span></a></span></span> <span lang="EN-US">only allows programmers prepend/push and remove/pop items from the front of a list, which makes it a <em>last in, first out</em> (LIFO) data structure. The</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Stack&lt;'T&gt;</span></span> <span lang="EN-US">class can be thought of as a mutable version of the F# <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Lists"><span style='color:windowtext;text-decoration:none'>list</span></a>.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; stack.Push("First");; (* Adds item to front of the list *)<br>
				val it : unit = ()<br>
				&gt; stack.Push("Second");;<br>
				val it : unit = ()<br>
				&gt; stack.Push("Third");;<br>
				val it : unit = ()<br>
				&gt; stack.Pop();; (* Returns and removes item from front of the list *)<br>
				val it : string = "Third"<br>
				&gt; stack.Pop();;<br>
				val it : string = "Second"<br>
				&gt; stack.Pop();;<br>
				val it : string = "First"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">A stack of coins could be represented with this data structure. If we stacked coins one on top another, the first coin in the stack is at the bottom of the stack, and the last coin in the stack appears at the top. We remove coins from top to bottom, so the last coin added to the stack is the first one removed.</span>
			</p>
			<p class="MsoNormal">
				<img width="220" height="1" src="F_files/image003.gif" align="right" hspace="12" alt=" A simple representation of a stack">
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Queue&lt;'T&gt; Class</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">A</span> <span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/7977ey2c.aspx"><span style='color:windowtext;text-decoration:none'>Queue&lt;'T&gt;</span></a></span></span> <span lang="EN-US">only allows programmers to append/enqueue to the rear of a list and remove/dequeue from the front of a list, which makes it a <em>first in, first out</em> (FIFO) data structure.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let queue = new Queue&lt;string&gt;();;<br>
				<br>
				val queue : Queue&lt;string&gt;<br>
				<br>
				&gt; queue.Enqueue("First");; (* Adds item to the rear of the list *)<br>
				val it : unit = ()<br>
				&gt; queue.Enqueue("Second");;<br>
				val it : unit = ()<br>
				&gt; queue.Enqueue("Third");;<br>
				val it : unit = ()<br>
				&gt; queue.Dequeue();; (* Returns and removes item from front of the queue *)<br>
				val it : string = "First"<br>
				&gt; queue.Dequeue();;<br>
				val it : string = "Second"<br>
				&gt; queue.Dequeue();;<br>
				val it : string = "Third"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">A line of people might be represented by a queue: people add themselves to the rear of the line, and are removed from the front. The first person to stand in line is the first person to be served.</span>
			</p>
			<p class="MsoNormal">
				<img width="277" height="1" src="F_files/image004.gif" alt=" "><br clear="all">
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">HashSet&lt;'T&gt;, and Dictionary&lt;'TKey, 'TValue&gt; Classes</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/bb359438.aspx"><span style='color:windowtext;text-decoration:none'>HashSet&lt;'T&gt;</span></a></span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'><a href="http://msdn.microsoft.com/en-us/library/xfhwa508.aspx"><span style='color:windowtext;text-decoration:none'>Dictionary&lt;'TKey, 'TValue&gt;</span></a></span></span> <span lang="EN-US">classes are mutable analogs of the F# <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Sets_and_Maps"><span style='color:windowtext;text-decoration:none'>set and map</span></a> data structures and contain many of the same functions.</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Using the HashSet&lt;'T&gt;</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				open System.Collections.Generic<br>
				<br>
				let nums_1to10 = new HashSet&lt;int&gt;()<br>
				let nums_5to15 = new HashSet&lt;int&gt;()<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let printCollection msg targetSet =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf "%s: " msg<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetSet |&gt; Seq.sort |&gt; Seq.iter(fun x -&gt; printf "%O " x)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn ""<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let addNums min max (targetSet : ICollection&lt;_&gt;) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seq { min .. max } |&gt; Seq.iter(fun x -&gt; targetSet.Add(x))<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; addNums 1 10 nums_1to10<br>
				&nbsp;&nbsp;&nbsp; addNums 5 15 nums_5to15<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printCollection "nums_1to10 (before)" nums_1to10<br>
				&nbsp;&nbsp;&nbsp; printCollection "nums_5to15 (before)" nums_5to15<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; nums_1to10.IntersectWith(nums_5to15) (* mutates nums_1to10 *)<br>
				&nbsp;&nbsp;&nbsp; printCollection "nums_1to10 (after)" nums_1to10<br>
				&nbsp;&nbsp;&nbsp; printCollection "nums_5to15 (after)" nums_5to15<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; Console.ReadKey(true) |&gt; ignore<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">nums_1to10 (before): 1 2 3 4 5 6 7 8 9 10nums_5to15 (before): 5 6 7 8 9 10 11 12 13 14 15nums_1to10 (after): 5 6 7 8 9 10nums_5to15 (after): 5 6 7 8 9 10 11 12 13 14 15</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Using the Dictionary&lt;'TKey, 'TValue&gt;</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; open System.Collections.Generic;;<br>
				&gt; let dict = new Dictionary&lt;string, string&gt;();;<br>
				<br>
				val dict : Dictionary&lt;string,string&gt;<br>
				<br>
				&gt; dict.Add("Garfield", "Jim Davis");;<br>
				val it : unit = ()<br>
				&gt; dict.Add("Farside", "Gary Larson");;<br>
				val it : unit = ()<br>
				&gt; dict.Add("Calvin and Hobbes", "Bill Watterson");;<br>
				val it : unit = ()<br>
				&gt; dict.Add("Peanuts", "Charles Schultz");;<br>
				val it : unit = ()<br>
				&gt; dict.["Farside"];; (* Use the '.[key]' operator to retrieve items *)<br>
				val it : string = "Gary Larson"</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Differences Between .NET BCL and F# Collections</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">The major difference between the collections built into the .NET BCL and their F# analogs is, of course, mutability. The mutable nature of BCL collections dramatically affects their implementation and time-complexity:</span>
			</p>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">.NET Data Structure</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Insert</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Remove</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Lookup</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# Data Structure</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Insert</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Remove</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Lookup</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>List</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(1)</span></em> <span lang="EN-US">/ <em>O(n)</em>*</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(n)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(1)</span></em> <span lang="EN-US">(by index) / <em>O(n)</em> (linear)</span>
						</p>
					</td>
					<td width="384" colspan="4" valign="top" style='width:288.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">No built-in equivalent</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>LinkedList</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(1)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(1)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(n)</span></em>
						</p>
					</td>
					<td width="384" colspan="4" valign="top" style='width:288.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">No built-in equivalent</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Stack</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(1)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(1)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(n)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>List</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(1)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">n/a</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(n)</span></em>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Queue</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(1)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(1)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(n)</span></em>
						</p>
					</td>
					<td width="384" colspan="4" valign="top" style='width:288.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">No built-in equivalent</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>HashSet</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(1)</span></em> <span lang="EN-US">/ <em>O(n)</em>*</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(1)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(1)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Set</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(log n)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(log n)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(log n)</span></em>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Dictionary</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(1)</span></em> <span lang="EN-US">/ <em>O(n)</em>*</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(1)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(1)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Map</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(log n)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(log n)</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">O(log n)</span></em>
						</p>
					</td>
				</tr>
			</table>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">* These classes are built on top of internal arrays. They may take a performance hit as the internal arrays are periodically resized when adding items.</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US">Note:</span></span> <span lang="EN-US">the Big-O notation above refers to the time-complexity of the insert/remove/retrieve operations relative to the number of items in the data structure, not the relative amount of time required to evaluate the operations relative to other data structures. For example, accessing arrays by index vs. accessing dictionaries by key have the same time complexity, <em>O(1)</em>, but the operations do not necessarily occur in the same amount of time.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Input and Output
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Basic I/O</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">Input and output, also called <span class="Bold">I/O</span>, refers to any kind communication between two hardware devices or between the user and the computer. This includes printing text out to the console, reading and writing files to disk, sending data over a socket, sending data to the printer, and a wide variety of other common tasks.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This page is not intended to provide an exhaustive look at .NET's I/O methods (readers seeking exhaustive references are encouraged to review the excellent documentation on the <a href="http://msdn.microsoft.com/en-us/library/system.io.aspx"><span style='color:windowtext;text-decoration:none'>System.IO namespace on MSDN</span></a>). This page will provide a cursory overview of some of the basic methods available to F# programmers for printing and working with files.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Working with the Console</span>
			</h2>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">With F#</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">By now, you're probably familiar with the</span> <span class="Teletyped"><span lang="EN-US" style=''>printf</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>printfn</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>sprintf</span></span> <span lang="EN-US">and its variants in the <a href="http://msdn.microsoft.com/en-us/library/ee370560.aspx"><span style='color:windowtext;text-decoration:none'>Printf module</span></a>. However, just to describe these methods more formally, these methods are used for printf-style printing and formatting using</span> <span class="Teletyped"><span lang="EN-US" style=''>%</span></span> <span lang="EN-US">markers as placeholders:</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Print methods take a format string and a series of arguments, for example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; sprintf "Hi, I'm %s and I'm a %s" "Juliet" "Scorpio";;<br>
				val it : string = "Hi, I'm Juliet and I'm a Scorpio"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Methods in the</span> <span class="Teletyped"><span lang="EN-US" style=''>Printf</span></span><span lang="EN-US">module are type-safe. For example, attempting to use substitute an</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">placeholder with a string results in a compilation error:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; sprintf "I'm %i years old" "kitty";;<br>
				<br>
				&nbsp; sprintf "I'm %i years old" "kitty";;<br>
				&nbsp; ---------------------------^^^^^^^^<br>
				<br>
				stdin(17,28): error FS0001: The type 'string' is not compatible with any of the types<br>
				byte,int16,int32,int64,sbyte,uint16,uint32,uint64,nativeint,unativeint, arising from<br>
				the use of a printf-style format string.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">According to the F# documentation,</span> <span class="Teletyped"><span lang="EN-US" style=''>%</span></span> <span lang="EN-US">placeholders consist of the following:</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Teletyped"><span style=''>%[flags][width][.precision][type]</span></span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">[flags]</span></span> <span lang="EN-US">(optional)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Valid flags are:</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">0: add zeros instead of spaces to make up the required width</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">'-': left justify the result within the width specified</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">'+': add a '+' character if the number is positive (to match a '-' sign for negatives)</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">' ': add an extra space if the number is positive (to match a '-' sign for negatives)</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">[width]</span></span> <span lang="EN-US">(optional)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The optional width is an integer indicating the minimal width of the result. For instance, %6d prints an integer, prefixing it with spaces to fill at least 6 characters. If width is '*', then an extra integer argument is taken to specify the corresponding width.</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> any number
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> '*':
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">[.precision]</span></span> <span lang="EN-US">(optional)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Represents the number of digits after a floating point number.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; sprintf "%.2f" 12345.67890;;<br>
				val it : string = "12345.68"<br>
				<br>
				&gt; sprintf "%.7f" 12345.67890;;<br>
				val it : string = "12345.6789000"</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">[type]</span></span> <span lang="EN-US">(required)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The following placeholder types are interpreted as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">%b:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool, formatted as "true" or "false"&nbsp;&nbsp;&nbsp;&nbsp; %s:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string, formatted as its unescaped contents&nbsp;&nbsp;&nbsp;&nbsp; %d, %i:&nbsp;&nbsp;&nbsp;&nbsp; any basic integer type formatted as a decimal integer, signed if the basic integer type is signed.&nbsp;&nbsp;&nbsp;&nbsp; %u:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; any basic integer type formatted as an unsigned decimal integer&nbsp;&nbsp;&nbsp;&nbsp; %x, %X, %o: any basic integer type formatted as an unsigned hexadecimal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (a-f)/Hexadecimal (A-F)/Octal integer&nbsp;&nbsp;&nbsp;&nbsp; %e, %E, %f, %F, %g, %G:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; any basic floating point type (float,float32) formatted&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using a C-style floating point format specifications, i.e&nbsp;&nbsp;&nbsp;&nbsp; %e, %E: Signed value having the form [-]d.dddde[sign]ddd where&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d is a single decimal digit, dddd is one or more decimal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digits, ddd is exactly three decimal digits, and sign&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is + or -&nbsp;&nbsp;&nbsp;&nbsp; %f:&nbsp;&nbsp;&nbsp;&nbsp; Signed value having the form [-]dddd.dddd, where dddd is one&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or more decimal digits. The number of digits before the&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decimal point depends on the magnitude of the number, and&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the number of digits after the decimal point depends on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the requested precision.&nbsp;&nbsp;&nbsp;&nbsp; %g, %G: Signed value printed in f or e format, whichever is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; more compact for the given value and precision.&nbsp;&nbsp;&nbsp; %M:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Decimal value&nbsp;&nbsp;&nbsp; %O:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Any value, printed by boxing the object and using it's ToString method(s)&nbsp;&nbsp;&nbsp; %A:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Any value, printed by using Microsoft.FSharp.Text.StructuredFormat.Display.any_to_string with the default layout settings&nbsp;&nbsp;&nbsp;&nbsp; %a:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A general format specifier, requires two arguments:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1) a function which accepts two arguments:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (a) a context parameter of the appropriate type for the&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; given formatting function (e.g. an #System.IO.TextWriter)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (b) a value to print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and which either outputs or returns appropriate text.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) the particular value to print&nbsp;&nbsp;&nbsp; %t:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A general format specifier, requires one argument:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1) a function which accepts a context parameter of the&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; appropriate type for the given formatting function (e.g.&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;an #System.IO.TextWriter)and which either outputs or returns&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; appropriate text.&nbsp; Basic integer types are:&nbsp;&nbsp;&nbsp;&nbsp; byte,sbyte,int16,uint16,int32,uint32,int64,uint64,nativeint,unativeint&nbsp; Basic floating point types are:&nbsp;&nbsp;&nbsp; &nbsp;float, float32</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Programmers can print to the console using the</span> <span class="Teletyped"><span lang="EN-US" style=''>printf</span></span> <span lang="EN-US">method, however F# recommends reading console input using the</span> <span class="Teletyped"><span lang="EN-US" style=''>System.Console.ReadLine()</span></span> <span lang="EN-US">method.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">With .NET</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">.NET includes <a href="http://msdn.microsoft.com/en-us/library/26etazsy.aspx"><span style='color:windowtext;text-decoration:none'>its own notation</span></a> for format specifiers. .NET format strings are untyped. Additionally, .NET's format strings are designed to be extensible, meaning that a programmer can implement their own custom format strings. Format placeholders have the following form:</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Teletyped"><span style=''>{index[, length][:formatString]}</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">For example, using the</span> <span class="Teletyped"><span lang="EN-US" style=''>String.Format</span></span> <span lang="EN-US">method in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; System.String.Format("Hi, my name is {0} and I'm a {1}", "Juliet", "Scorpio");;<br>
				val it : string = "Hi, my name is Juliet and I'm a Scorpio"<br>
				<br>
				&gt; System.String.Format("|{0,-50}|", "Left justified");;<br>
				val it : string = "|Left justified&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |"<br>
				<br>
				&gt; System.String.Format("|{0,50}|", "Right justified");;<br>
				val it : string = "|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Right justified|"<br>
				<br>
				&gt; System.String.Format("|{0:yyyy-MMM-dd}|", System.DateTime.Now);;<br>
				val it : string = "|2009-Apr-06|"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">See <a href="http://msdn.microsoft.com/en-us/library/427bttx3.aspx"><span style='color:windowtext;text-decoration:none'>Number Format Strings</span></a>, <a href="http://msdn.microsoft.com/en-us/library/97x6twsz.aspx"><span style='color:windowtext;text-decoration:none'>Date and Time Format Strings</span></a>, and <a href="http://msdn.microsoft.com/en-us/library/c3s1ez6e.aspx"><span style='color:windowtext;text-decoration:none'>Enum Format Strings</span></a> for a comprehensive reference on format specifiers for .NET.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Programmers can read and write to the console using the <a href="http://msdn.microsoft.com/en-us/library/system.console.aspx"><span style='color:windowtext;text-decoration:none'>System.Console class</span></a>:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; Console.Write("What's your name? ")<br>
				&nbsp;&nbsp;&nbsp; let name = Console.ReadLine()<br>
				&nbsp;&nbsp;&nbsp; Console.Write("Hello, {0}", name)<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">System.IO Namespace</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">The <a href="http://msdn.microsoft.com/en-us/library/system.io.aspx"><span style='color:windowtext;text-decoration:none'>System.IO</span></a> namespace contains a variety of useful classes for performing basic I/O.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Files and Directories</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">The following classes are useful for interrogating the host filesystem:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">The <a href="http://msdn.microsoft.com/en-us/library/system.io.file.aspx"><span style='color:windowtext;text-decoration:none'>System.IO.File</span></a> class exposes several useful members for creating, appending, and deleting files.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://msdn.microsoft.com/en-us/library/system.io.directory.aspx"><span style='color:windowtext;text-decoration:none'>System.IO.Directory</span></a> exposes methods for creating, moving, and deleting directories.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://msdn.microsoft.com/en-us/library/system.io.path.aspx"><span style='color:windowtext;text-decoration:none'>System.IO.Path</span></a> performs operations on strings which represent file paths.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://msdn.microsoft.com/en-us/library/system.io.filesystemwatcher.aspx"><span style='color:windowtext;text-decoration:none'>System.IO.FileSystemWatcher</span></a> which allows users to listen to a directory for changes.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Streams</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">A stream is a sequence of bytes. .NET provides some classes which allow programmers to work with steams including:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://msdn.microsoft.com/en-us/library/system.io.streamreader.aspx"><span style='color:windowtext;text-decoration:none'>System.IO.StreamReader</span></a> which is used to read characters from a stream.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://msdn.microsoft.com/en-us/library/system.io.streamwriter.aspx"><span style='color:windowtext;text-decoration:none'>System.IO.StreamWriter</span></a> which is used to write characters to a stream.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://msdn.microsoft.com/en-us/library/system.io.memorystream.aspx"><span style='color:windowtext;text-decoration:none'>System.IO.MemoryStream</span></a> which creates an in-memory stream of bytes.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Exception Handling
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Exception Handling</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">When a program encounters a problem or enters an invalid state, it will often respond by throwing an exception. Left to its own devices, an uncaught exception will crash an application. Programmers write <span class="Bold">exception handling</span> code to rescue an application from an invalid state.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Try/With</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Let's look at the following code:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let getNumber msg = printf msg; int32(System.Console.ReadLine())<br>
				<br>
				let x = getNumber("x = ")<br>
				let y = getNumber("y = ")<br>
				printfn "%i + %i = %i" x y (x + y)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This code is syntactically valid, and it has the correct types. However, it can fail at run time if we give it a bad input:</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">x = 7y = monkeys!------------FormatException was unhandled. Input string was not in a correct format.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The string</span> <span class="Teletyped"><span lang="EN-US" style=''>monkeys</span></span> <span lang="EN-US">does not represent a number, so the conversion fails with an exception. We can handle this exception using F#'s</span> <span class="Teletyped"><span lang="EN-US" style=''>try... with</span></span><span lang="EN-US">, a special kind of pattern matching construct:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let getNumber msg =<br>
				&nbsp;&nbsp;&nbsp; printf msg;<br>
				&nbsp;&nbsp;&nbsp; try<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32(System.Console.ReadLine())<br>
				&nbsp;&nbsp;&nbsp; with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | :? System.FormatException -&gt; System.Int32.MinValue<br>
				<br>
				let x = getNumber("x = ")<br>
				let y = getNumber("y = ")<br>
				printfn "%i + %i = %i" x y (x + y)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">x = 7y = monkeys!7 + -2147483648 = -2147483641</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">It is, of course, wholly possible to catch multiple types of exceptions in a single</span> <span class="Teletyped"><span lang="EN-US" style=''>with</span></span> <span lang="EN-US">block. For example, according to the <a href="http://msdn.microsoft.com/en-us/library/b3h1hf19.aspx"><span style='color:windowtext;text-decoration:none'>MSDN documentation</span></a>, the</span> <span class="Teletyped"><span lang="EN-US" style=''>System.Int32.Parse(s : string)</span></span> <span lang="EN-US">method will throw three types of exceptions:</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/system.argumentnullexception.aspx"><span style='color:windowtext;text-decoration:none'>ArgumentNullException</span></a></span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Occurs when</span> <span class="Teletyped"><span lang="EN-US" style=''>s</span></span> <span lang="EN-US">is a null reference.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/system.formatexception.aspx"><span style='color:windowtext;text-decoration:none'>FormatException</span></a></span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Occurs when</span> <span class="Teletyped"><span lang="EN-US" style=''>s</span></span> <span lang="EN-US">does not represent a numeric input.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/system.overflowexception.aspx"><span style='color:windowtext;text-decoration:none'>OverflowException</span></a></span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Occurs when</span> <span class="Teletyped"><span lang="EN-US" style=''>s</span></span> <span lang="EN-US">represents number greater than or less than</span> <span class="Teletyped"><span lang="EN-US" style=''>Int32.MaxValue</span></span> <span lang="EN-US">or</span> <span class="Teletyped"><span lang="EN-US" style=''>Int32.MinValue</span></span> <span lang="EN-US">(i.e. the number cannot be represented with a 32-bit signed integer).</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can catch all of these exceptions by adding additional match cases:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let getNumber msg =<br>
				&nbsp;&nbsp;&nbsp; printf msg;<br>
				&nbsp;&nbsp;&nbsp; try<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32(System.Console.ReadLine())<br>
				&nbsp;&nbsp;&nbsp; with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | :? System.FormatException -&gt; -1<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | :? System.OverflowException -&gt; System.Int32.MinValue<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | :? System.ArgumentNullException -&gt; 0</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Its not necessary to have an exhaustive list of match cases on exception types, as the uncaught exception will simply move to the next method in the stack trace.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Raising Exceptions</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">The code above demonstrates how to recover from an invalid state. However, when designing F# libraries, its often useful to throw exceptions to notify users that the program encountered some kind of invalid input. There are several standard functions for raising exceptions:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">(* General failure *)<br>
				val failwith : string -&gt; 'a<br>
				<br>
				(* General failure with formatted message *)<br>
				val failwithf : StringFormat&lt;'a, 'b&gt; -&gt; 'a<br>
				<br>
				(* Raise a specific exception *)<br>
				val raise : #exn -&gt; 'a<br>
				<br>
				(* Bad input *)<br>
				val invalidArg : string -&gt; 'a</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">For example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type 'a tree =<br>
				&nbsp;&nbsp;&nbsp; | Node of 'a * 'a tree * 'a tree<br>
				&nbsp;&nbsp;&nbsp; | Empty<br>
				&nbsp;&nbsp;&nbsp;<br>
				let rec add x = function<br>
				&nbsp;&nbsp;&nbsp; | Empty -&gt; Node(x, Empty, Empty)<br>
				&nbsp;&nbsp;&nbsp; | Node(y, left, right) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if x &gt; y then Node(y, left, add x right)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if x &lt; y then Node(y, add x left, right)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else failwithf "Item '%A' already been added to tree" x</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Try/Finally</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Normally, an exception will cause a function to exit immediately. However, a</span> <span class="Teletyped"><span lang="EN-US" style=''>finally</span></span> <span lang="EN-US">block will always execute, even if the code throws an exception:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let tryWithFinallyExample f =<br>
				&nbsp;&nbsp;&nbsp; try<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "tryWithFinallyExample: outer try block"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "tryWithFinallyExample: inner try block"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | exn -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "tryWithFinallyExample: inner with block"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reraise() (* raises the same exception we just caught *)<br>
				&nbsp;&nbsp;&nbsp; finally<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "tryWithFinally: outer finally block"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let catchAllExceptions f =<br>
				&nbsp;&nbsp;&nbsp; try<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "-------------"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "catchAllExceptions: try block"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tryWithFinallyExample f<br>
				&nbsp;&nbsp;&nbsp; with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | exn -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "catchAllExceptions: with block"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "Exception message: %s" exn.Message<br>
				&nbsp;&nbsp;&nbsp;<br>
				let main() =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; catchAllExceptions (fun () -&gt; printfn "Function executed successfully")<br>
				&nbsp;&nbsp;&nbsp; catchAllExceptions (fun () -&gt; failwith "Function executed with an error")<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program will output the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">-------------catchAllExceptions: try blocktryWithFinallyExample: outer try blocktryWithFinallyExample: inner try blockFunction executed successfullytryWithFinally: outer finally block-------------catchAllExceptions: try blocktryWithFinallyExample: outer try blocktryWithFinallyExample: inner try blocktryWithFinallyExample: inner with blocktryWithFinally: outer finally blockcatchAllExceptions: with blockException message: Function executed with an error</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice that our finally block executed in spite of the exception. Finally blocks are used most commonly to clean up resources, such as closing an open file handle or closing a database connection (even in the event of an exception, we <em>do not</em> want to leave file handles or database connections open):</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System.Data.SqlClient<br>
				let executeScalar connectionString sql =<br>
				&nbsp;&nbsp;&nbsp; let conn = new SqlConnection(connectionString)<br>
				&nbsp;&nbsp;&nbsp; try<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; conn.Open() (* this line can throw an exception *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let comm = new SqlCommand(sql, conn)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comm.ExecuteScalar() (* this line can throw an exception *)<br>
				&nbsp;&nbsp;&nbsp; finally<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* finally block guarantees our SqlConnection is closed, even if our sql statement fails *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; conn.Close()</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">use Statement</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Many objects in the .NET framework implement the <a href="http://msdn.microsoft.com/en-us/library/system.idisposable.aspx"><span style='color:windowtext;text-decoration:none'>System.IDisposable</span></a> interface, which means the objects have a special method called</span> <span class="Teletyped"><span lang="EN-US" style=''>Dispose</span></span> <span lang="EN-US">to guarantee deterministic cleanup of unmanaged resources. It's considered a best practice to call</span> <span class="Teletyped"><span lang="EN-US" style=''>Dispose</span></span> <span lang="EN-US">on these types of objects as soon as they are no longer needed.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Traditionally, we'd use a</span> <span class="Teletyped"><span lang="EN-US" style=''>try/finally</span></span> <span lang="EN-US">block in this fashion:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let writeToFile fileName =<br>
				&nbsp;&nbsp;&nbsp; let sw = new System.IO.StreamWriter(fileName : string)<br>
				&nbsp;&nbsp;&nbsp; try<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sw.Write("Hello ")<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sw.Write("World!")<br>
				&nbsp;&nbsp;&nbsp; finally<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sw.Dispose()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">However, this can be occasionally bulky and cumbersome, especially when dealing with many objects which implement the IDisposable interface. F# provides the keyword</span> <span class="Teletyped"><span lang="EN-US" style=''>use</span></span> <span lang="EN-US">as syntactic sugar for the pattern above. An equivalent version of the code above can be written as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let writeToFile fileName =<br>
				&nbsp;&nbsp;&nbsp; use sw = new System.IO.StreamWriter(fileName : string)<br>
				&nbsp;&nbsp;&nbsp; sw.Write("Hello ")<br>
				&nbsp;&nbsp;&nbsp; sw.Write("World!")</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The scope of a</span> <span class="Teletyped"><span lang="EN-US" style=''>use</span></span><span lang="EN-US">statement is identical to the scope of a</span> <span class="Teletyped"><span lang="EN-US" style=''>let</span></span><span lang="EN-US">statement. F# will automatically call</span> <span class="Teletyped"><span lang="EN-US" style=''>Dispose()</span></span> <span lang="EN-US">on an object when the identifier goes out of scope.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Defining New Exceptions</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">F# allows us to easily define new types of exceptions using the</span> <span class="Teletyped"><span lang="EN-US" style=''>exception</span></span> <span lang="EN-US">declaration. Here's an example using fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; exception ReindeerNotFoundException of string<br>
				<br>
				let reindeer =<br>
				&nbsp;&nbsp;&nbsp; ["Dasher"; "Dancer"; "Prancer"; "Vixen"; "Comet"; "Cupid"; "Donner"; "Blitzen"]<br>
				&nbsp;&nbsp;&nbsp;<br>
				let getReindeerPosition name =<br>
				&nbsp;&nbsp;&nbsp; match List.tryFindIndex (fun x -&gt; x = name) reindeer with<br>
				&nbsp;&nbsp;&nbsp; | Some(index) -&gt; index<br>
				&nbsp;&nbsp;&nbsp; | None -&gt; raise (ReindeerNotFoundException(name));;<br>
				<br>
				exception ReindeerNotFoundException of string<br>
				val reindeer : string list<br>
				val getReindeerPosition : string -&gt; int<br>
				<br>
				&gt; getReindeerPosition "Comet";;<br>
				val it : int = 4<br>
				<br>
				&gt; getReindeerPosition "Donner";;<br>
				val it : int = 6<br>
				<br>
				&gt; getReindeerPosition "Rudolf";;<br>
				FSI_0033+ReindeerNotFoundExceptionException: Rudolf<br>
				&nbsp;&nbsp; at FSI_0033.getReindeerPosition(String name)<br>
				&nbsp;&nbsp; at &lt;StartupCode$FSI_0036&gt;.$FSI_0036._main()<br>
				stopped due to error</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can pattern match on our new existing exception type just as easily as any other exception:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let tryGetReindeerPosition name =<br>
				&nbsp;&nbsp;&nbsp; try<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getReindeerPosition name<br>
				&nbsp;&nbsp;&nbsp; with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ReindeerNotFoundException(s) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "Got ReindeerNotFoundException: %s" s<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1;;<br>
				<br>
				val tryGetReindeerPosition : string -&gt; int<br>
				<br>
				&gt; tryGetReindeerPosition "Comet";;<br>
				val it : int = 4<br>
				<br>
				&gt; tryGetReindeerPosition "Rudolf";;<br>
				Got ReindeerNotFoundException: Rudolf<br>
				val it : int = -1</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				Exception Handling Constructs
			</h2>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Bold"><span lang="EN-US">Construct</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Bold"><span lang="EN-US">Kind</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Bold"><span lang="EN-US">Description</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>raise</span></span> <em><span lang="EN-US">expr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# library function</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Raises the given exception</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>failwith</span></span> <em><span lang="EN-US">expr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# library function</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Raises the</span> <span class="Teletyped"><span lang="EN-US" style=''>System.Exception</span></span> <span lang="EN-US">exception</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>try</span></span> <em><span lang="EN-US">expr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>with</span></span> <em><span lang="EN-US">rules</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# expression</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Catches expressions matching the pattern rules</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>try</span></span> <em><span lang="EN-US">expr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>finally</span></span> <em><span lang="EN-US">expr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# expression</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Execution the</span> <span class="Teletyped"><span lang="EN-US" style=''>finally</span></span> <span lang="EN-US">expression both when the computation is successful and when an exception is raised</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>| :? ArgumentException</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# pattern rule</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">A rule matching the given .NET exception type</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>| :? ArgumentException as e</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# pattern rule</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">A rule matching the given .NET exception type, binding the name</span> <span class="Teletyped"><span lang="EN-US" style=''>e</span></span> <span lang="EN-US">to the exception object value</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>| Failure(msg) -&gt;</span></span> <em><span lang="EN-US">expr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# pattern rule</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">A rule matching the given data-carrying F# exception</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>| exn -&gt;</span></span> <em><span lang="EN-US">expr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# pattern rule</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">A rule matching any exception, binding the name</span> <span class="Teletyped"><span lang="EN-US" style=''>exn</span></span> <span lang="EN-US">to the exception object value</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>| exn when</span></span> <em><span lang="EN-US">expr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>-&gt;</span></span> <em><span lang="EN-US">expr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# pattern rule</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">A rule matching the exception under the given condition, binding the name</span> <span class="Teletyped"><span lang="EN-US" style=''>exn</span></span> <span lang="EN-US">to the exception object value</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Operator Overloading
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Operator Overloading</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">Operator overloading allows programmers to provide new behavior for the default operators in F#. In practice, programmers overload operators to provide a simplified syntax for objects which can be combined mathematically.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Using Operators</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">You've already used operators:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let sum = x + y</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here</span> <span class="Teletyped"><span lang="EN-US" style=''>+</span></span> <span lang="EN-US">is example of using a mathematical addition operator.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Operator Overloading</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Operators are functions with special names, enclosed in brackets. They must be defined as static class members. Here's an example on declaring</span> <span class="Teletyped"><span lang="EN-US" style=''>+</span></span> <span lang="EN-US">operator on complex numbers:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Complex =<br>
				&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; Re: double<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Im: double }<br>
				&nbsp;&nbsp;&nbsp; static member ( + ) (left: Complex, right: Complex) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Re = left.Re + right.Re; Im = left.Im + right.Im }</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In FSI, we can add two complex numbers as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let first = { Re = 1.0; Im = 7.0 };;<br>
				val first : Complex<br>
				<br>
				&gt; let second = { Re = 2.0; Im = -10.5 };;<br>
				val second : Complex<br>
				<br>
				&gt; first + second;;<br>
				val it : Complex = {Re = 3.0;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Im = -3.5;}</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Defining New Operators</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">In addition to overloading existing operators, its possible to define new operators. The names of custom operators can only be one or more of the following characters:</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Teletyped"><span style=''>!$%&amp;*+-./&lt;=&gt;?@^|~:</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">F# supports two types of operators: infix operators and prefix operators.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Infix operators</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">An infix operator takes two arguments, with the operator appearing in between both arguments (i.e.</span> <span class="Teletyped"><span lang="EN-US" style=''>arg1 {op} arg2</span></span><span lang="EN-US">). We can define our own infix operators using the syntax:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let (op) arg1 arg2 = ...</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In addition to mathematical operators, F# has a variety of infix operators defined as part of its library, for example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let inline (|&gt;) x f = f x<br>
				let inline (::) hd tl = Cons(hd, tl)<br>
				let inline (:=) (x : 'a ref) value = x.contents &lt;- value</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Let's say we're writing an application which performs a lot of regex matching and replacing. We can match text using Perl-style operators by defining our own operators as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System.Text.RegularExpressions<br>
				<br>
				let (=~) input pattern =<br>
				&nbsp;&nbsp;&nbsp; Regex.IsMatch(input, pattern)<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; printfn "cat =~ dog: %b" ("cat" =~ "dog")<br>
				&nbsp;&nbsp;&nbsp; printfn "cat =~ cat|dog: %b" ("cat" =~ "cat|dog")<br>
				&nbsp;&nbsp;&nbsp; printfn "monkey =~ monk*: %b" ("monkey" =~ "monk*")<br>
				&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">cat =~ dog: falsecat =~ cat|dog: truemonkey =~ monk*: true</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Prefix Operators</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Prefix operators take a single argument which appears to the right side of the operator (</span><span class="Teletyped"><span lang="EN-US" style=''>{op}argument</span></span><span lang="EN-US">). You've already seen how the</span> <span class="Teletyped"><span lang="EN-US" style=''>!</span></span> <span lang="EN-US">operator is defined for ref cells:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type 'a ref = { mutable contents : 'a }<br>
				let (!) (x : 'a ref) = x.contents</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Let's say we're writing a number crunching application, and we wanted to define some operators that work on lists of numbers. We might define some prefix operators in fsi as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let ( !+ ) l = List.reduce ( + ) l<br>
				let ( !- ) l = List.reduce ( - ) l<br>
				let ( !* ) l = List.reduce ( * ) l<br>
				let ( !/ ) l = List.reduce ( / ) l;;<br>
				<br>
				val ( !+ ) : int list -&gt; int<br>
				val ( !- ) : int list -&gt; int<br>
				val ( !* ) : int list -&gt; int<br>
				val ( !/ ) : int list -&gt; int<br>
				<br>
				&gt; !* [2; 3; 5];;<br>
				val it : int = 30<br>
				<br>
				&gt; !+ [2; 3; 5];;<br>
				val it : int = 10<br>
				<br>
				&gt; !-</span> [2; 3; 7];;<br>
				val it : int = -8<br>
				<br>
				&gt; !/ [100; 10; 2];;<br>
				val it : int = 5
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h1 class="HeadingArticle">
				Classes
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Classes and Objects</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">In the real world, an <span class="Bold">object</span> is a "real" thing. A cat, person, computer, and a roll of duct tape are all "real" things in the tangible sense. When we think about these things, we can broadly describe them in terms of a number of attributes:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Properties: a person has a name, a cat has four legs, computers have a price tag, duct tape is sticky.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Behaviors: a person reads the newspaper, cats sleep all day, computers crunch numbers, duct tape attaches things to other things.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Types/group membership: an employee is a type of person, a cat is a pet, a Dell and Mac are types of computers, duct tape is part of the broader family of adhesives.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">In the programming world, an "object" is, in the simplest of terms, a model of something in the real world. Object-oriented programming (OOP) exists because it allows programmers to model real-world entities and simulate their interactions in code. Just like their real-world counterparts, objects in computer programming have properties and behaviors, and can be classified according to their type.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">While we can certainly create objects that represents cats, people, and adhesives, objects can also represent less concrete things, such as a bank account or a business rule.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Although the scope of OOP has expanded to include some advanced concepts such as design patterns and the large-scale architecture of applications, this page will keep things simple and limit the discussion of OOP to data modeling.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Defining an Object</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Before you create an object, you have to identify the properties of your object and describe what it does. You define properties and methods of an object in a <em>class</em>. There are actually two different syntaxes for defining a class: an implicit syntax and an explicit syntax.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Implicit Class Construction</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Implicit class syntax is defined as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type TypeName optional-type-arguments arguments [ as ident ] =<br>
				&nbsp;&nbsp;&nbsp; [ inherit type { as base } ]<br>
				&nbsp;&nbsp;&nbsp; [ let-binding | let-rec bindings ] *<br>
				&nbsp;&nbsp;&nbsp; [ do-statement ] *<br>
				&nbsp;&nbsp;&nbsp; [ abstract-binding | member-binding | interface-implementation ] *</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <em><span lang="EN-US">Elements in brackets are optional, elements followed by a</span></em> <span class="Teletyped"><span lang="EN-US" style=''>*</span></span> <em><span lang="EN-US">may appear zero or more times.</span></em>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This syntax above is not as daunting as it looks. Here's a simple class written in implicit style:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Account(number : int, holder : string) = class<br>
				&nbsp;&nbsp;&nbsp; let mutable amount = 0m<br>
				<br>
				&nbsp;&nbsp;&nbsp; member x.Number = number<br>
				&nbsp;&nbsp;&nbsp; member x.Holder = holder<br>
				&nbsp;&nbsp;&nbsp; member x.Amount = amount<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Deposit(value) = amount &lt;- amount + value<br>
				&nbsp;&nbsp;&nbsp; member x.Withdraw(value) = amount &lt;- amount - value<br>
				end</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The code above defines a class called</span> <span class="Teletyped"><span lang="EN-US" style=''>Account</span></span><span lang="EN-US">, which has three properties and two methods. Let's take a closer look at the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Account(number : int, holder : string) = class</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The underlined code is called the class <em>constructor</em>. A constructor is a special kind of function used to initialize the fields in an object. In this case, our constructor defines two values,</span> <span class="Teletyped"><span lang="EN-US" style=''>number</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>holder</span></span><span lang="EN-US">, which can be accessed anywhere in our class. You create an instance of</span> <span class="Teletyped"><span lang="EN-US" style=''>Account</span></span> <span lang="EN-US">by using the</span> <span class="Teletyped"><span lang="EN-US" style=''>new</span></span> <span lang="EN-US">keyword and passing the appropriate parameters into the constructor as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let bob = new Account(123456, "Bob&rsquo;s Saving")</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Additionally, let's look at the way a member is defined:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">member x.Deposit(value) = amount &lt;- amount + value</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>x</span></span> <span lang="EN-US">above is an alias for the object currently in scope. Most OO languages provide an implicit</span> <span class="Teletyped"><span lang="EN-US" style=''>this</span></span> <span lang="EN-US">or</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>self</span></span> <span lang="EN-US">variable to access the object in scope, but F# requires programmers to create their own alias.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">After we can create an instance of our</span> <span class="Teletyped"><span lang="EN-US" style=''>Account</span></span><span lang="EN-US">, we can access its properties using</span> <span class="Teletyped"><span lang="EN-US" style=''>.propertyName</span></span> <span lang="EN-US">notation. Here's an example in FSI:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let printAccount (x : Account) =<br>
				&nbsp;&nbsp;&nbsp; printfn "x.Number: %i, x.Holder: %s, x.Amount: %M" x.Number x.Holder x.Amount;;<br>
				<br>
				val printAccount : Account -&gt; unit<br>
				<br>
				&gt; let bob = new Account(123456, "Bob&rsquo;s Savings");;<br>
				<br>
				val bob : Account<br>
				<br>
				&gt; printAccount bob;;<br>
				x.Number: 123456, x.Holder: Bob&rsquo;s Savings, x.Amount: 0<br>
				val it : unit = ()<br>
				<br>
				&gt; bob.Deposit(100M);;<br>
				val it : unit = ()<br>
				<br>
				&gt; printAccount bob;;<br>
				x.Number: 123456, x.Holder: Bob&rsquo;s Savings, x.Amount: 100<br>
				val it : unit = ()<br>
				<br>
				&gt; bob.Withdraw(29.95M);;<br>
				val it : unit = ()<br>
				<br>
				&gt; printAccount bob;;<br>
				x.Number: 123456, x.Holder: Bob&rsquo;s Savings, x.Amount: 70.05</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h4 class="Heading3">
				<span lang="EN-US">Example</span>
			</h4>
			<p class="TextBody">
				<span lang="EN-US">Let's use this class in a real program:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				type Account(number : int, holder : string) = class<br>
				&nbsp;&nbsp;&nbsp; let mutable amount = 0m<br>
				<br>
				&nbsp;&nbsp;&nbsp; member x.Number = number<br>
				&nbsp;&nbsp;&nbsp; member x.Holder = holder<br>
				&nbsp;&nbsp;&nbsp; member x.Amount = amount<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Deposit(value) = amount &lt;- amount + value<br>
				&nbsp;&nbsp;&nbsp; member x.Withdraw(value) = amount &lt;- amount - value<br>
				end<br>
				<br>
				let homer = new Account(12345, "Homer")<br>
				let marge = new Account(67890, "Marge")<br>
				<br>
				let transfer amount (source : Account) (target : Account) =<br>
				&nbsp;&nbsp;&nbsp; source.Withdraw amount<br>
				&nbsp;&nbsp;&nbsp; target.Deposit amount<br>
				&nbsp;&nbsp;&nbsp;<br>
				let printAccount (x : Account) =<br>
				&nbsp;&nbsp;&nbsp; printfn "x.Number: %i, x.Holder: %s, x.Amount: %M" x.Number x.Holder x.Amount<br>
				&nbsp;&nbsp;&nbsp;<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let printAccounts() =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [homer; marge] |&gt; Seq.iter printAccount<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printfn "\nInializing account"<br>
				&nbsp;&nbsp;&nbsp; homer.Deposit 50M<br>
				&nbsp;&nbsp;&nbsp; marge.Deposit 100M<br>
				&nbsp;&nbsp;&nbsp; printAccounts()<br>
				&nbsp; &nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printfn "\nTransferring $30 from Marge to Homer"<br>
				&nbsp;&nbsp;&nbsp; transfer 30M marge homer<br>
				&nbsp;&nbsp;&nbsp; printAccounts()<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printfn "\nTransferring $75 from Homer to Marge"<br>
				&nbsp;&nbsp;&nbsp; transfer 75M homer marge<br>
				&nbsp;&nbsp;&nbsp; printAccounts()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The program has the following types:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Account =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; new : number:int * holder:string -&gt; Account<br>
				&nbsp;&nbsp;&nbsp; member Deposit : value:decimal -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; member Withdraw : value:decimal -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; member Amount : decimal<br>
				&nbsp;&nbsp;&nbsp; member Holder : string<br>
				&nbsp;&nbsp;&nbsp; member Number : int<br>
				&nbsp; end<br>
				val homer : Account<br>
				val marge : Account<br>
				val transfer : decimal -&gt; Account -&gt; Account -&gt; unit<br>
				val printAccount : Account -&gt; unit</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Initializing accountx.Number: 12345, x.Holder: Homer, x.Amount: 50x.Number: 67890, x.Holder: Marge, x.Amount: 100Transferring $30 from Marge to Homerx.Number: 12345, x.Holder: Homer, x.Amount: 80x.Number: 67890, x.Holder: Marge, x.Amount: 70Transferring $75 from Homer to Margex.Number: 12345, x.Holder: Homer, x.Amount: 5x.Number: 67890, x.Holder: Marge, x.Amount: 145</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h4 class="Heading3">
				<span lang="EN-US">Example using the do keyword</span>
			</h4>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>do</span></span> <span lang="EN-US">keyword is used for post-constructor initialization. For example, let's say we wanted to create an object which represents a stock. We only need to pass in the stock symbol, and initialize the rest of the properties in our constructor:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				open System.Net<br>
				<br>
				type Stock(symbol : string) = class<br>
				&nbsp;&nbsp;&nbsp; let url =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "http://download.finance.yahoo.com/d/quotes.csv?s=" + symbol + "&amp;f=sl1d1t1c1ohgv&amp;e=.csv"<br>
				<br>
				&nbsp;&nbsp;&nbsp; let mutable _symbol = String.Empty<br>
				&nbsp;&nbsp;&nbsp; let mutable _current = 0.0<br>
				&nbsp;&nbsp;&nbsp; let mutable _open = 0.0<br>
				&nbsp;&nbsp;&nbsp; let mutable _high = 0.0<br>
				&nbsp;&nbsp;&nbsp; let mutable _low = 0.0<br>
				&nbsp;&nbsp;&nbsp; let mutable _volume = 0<br>
				<br>
				&nbsp;&nbsp;&nbsp; do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* We initialize our object in the do block *)<br>
				<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let webClient = new WebClient()<br>
				<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(* Data comes back as a comma-seperated list, so we split it<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; on each comma *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let data = webClient.DownloadString(url).Split([|','|])<br>
				<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _symbol &lt;- data.[0]<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _current &lt;- float data.[1]<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _open &lt;- float data.[5]<br>
				&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_high &lt;- float data.[6]<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _low &lt;- float data.[7]<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _volume &lt;- int data.[8]<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Symbol = _symbol<br>
				&nbsp;&nbsp;&nbsp; member x.Current = _current<br>
				&nbsp;&nbsp;&nbsp; member x.Open = _open<br>
				&nbsp;&nbsp;&nbsp; member x.High = _high<br>
				&nbsp;&nbsp;&nbsp; member x.Low = _low<br>
				&nbsp;&nbsp;&nbsp; member x.Volume = _volume<br>
				end<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let stocks =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ["msft"; "noc"; "yhoo"; "gm"]<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Seq.map (fun x -&gt; new Stock(x))<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; stocks |&gt; Seq.iter (fun x -&gt; printfn "Symbol: %s (%F)" x.Symbol x.Current)<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program has the following types:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Stock =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; new : symbol:string -&gt; Stock<br>
				&nbsp;&nbsp;&nbsp; member Current : float<br>
				&nbsp;&nbsp;&nbsp; member High : float<br>
				&nbsp;&nbsp;&nbsp; member Low : float<br>
				&nbsp;&nbsp;&nbsp; member Open : float<br>
				&nbsp;&nbsp;&nbsp; member Symbol : string<br>
				&nbsp;&nbsp;&nbsp; member Volume : int<br>
				&nbsp; end</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following (your outputs will vary):</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Symbol: "MSFT" (19.130000)Symbol: "NOC" (43.240000)Symbol: "YHOO" (12.340000)Symbol: "GM" (3.660000)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US">Note:</span></span> <span lang="EN-US">It's possible to have any number of</span> <span class="Teletyped"><span lang="EN-US" style=''>do</span></span><span lang="EN-US">statements in a class definition, although there's no particular reason why you'd need more than one.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Explicit Class Definition</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Classes written in explicit style follow this format:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type TypeName =<br>
				&nbsp;&nbsp;&nbsp; [ inherit type ]<br>
				&nbsp;&nbsp;&nbsp; [ val-definitions ]<br>
				&nbsp;&nbsp;&nbsp; [ new ( optional-type-arguments arguments ) [ as ident ] =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { field-initialization }<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ then constructor-statements ]<br>
				&nbsp;&nbsp;&nbsp; ] *<br>
				&nbsp;&nbsp;&nbsp; [ abstract-binding | member-binding | interface-implementation ] *</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here's a class defined using the explicit syntax:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Line = class<br>
				&nbsp;&nbsp;&nbsp; val X1 : float<br>
				&nbsp;&nbsp;&nbsp; val Y1 : float<br>
				&nbsp;&nbsp;&nbsp; val X2 : float<br>
				&nbsp;&nbsp;&nbsp; val Y2 : float<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; new (x1, y1, x2, y2) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { X1 = x1; Y1 = y1;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X2 = x2; Y2 = y2}<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Length =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let sqr x = x * x<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqrt(sqr(x.X1 - x.X2) + sqr(x.Y1 - x.Y2) )<br>
				end</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Each</span> <span class="Teletyped"><span lang="EN-US" style=''>val</span></span> <span lang="EN-US">defines a field in our object. Unlike other object-oriented languages, F# does not implicitly initialize fields in a class to any value. Instead, F# requires programmers to define a constructor and explicitly initialize each field in their object with a value.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can perform some post-constructor processing using a</span> <span class="Teletyped"><span lang="EN-US" style=''>then</span></span> <span lang="EN-US">block as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Line = class<br>
				&nbsp;&nbsp;&nbsp; val X1 : float<br>
				&nbsp;&nbsp;&nbsp; val Y1 : float<br>
				&nbsp;&nbsp;&nbsp; val X2 : float<br>
				&nbsp;&nbsp;&nbsp; val Y2 : float<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; new (x1, y1, x2, y2) as this =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { X1 = x1; Y1 = y1;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X2 = x2; Y2 = y2;}<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "Line constructor: {(%F, %F), (%F, %F)}, Line.Length: %F"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.X1 this.Y1 this.X2 this.Y2 this.Length<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Length =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let sqr x = x * x<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqrt(sqr(x.X1 - x.X2) + sqr(x.Y1 - x.Y2) )<br>
				end</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice that we have to add an alias after our constructor,</span> <span class="Teletyped"><span lang="EN-US" style=''>new (x1, y1, x2, y2)</span></span> <span class="Underline"><span lang="EN-US">as this</span></span><span lang="EN-US">), to access the fields of our object being constructed. Each time we create a</span> <span class="Teletyped"><span lang="EN-US" style=''>Line</span></span> <span lang="EN-US">object, the constructor will print to the console. We can demonstrate this using fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let line = new Line(1.0, 1.0, 4.0, 2.5);;<br>
				<br>
				val line : Line<br>
				<br>
				Line constructor: {(1.000000, 1.000000), (4.000000, 2.500000)}, Line.Length: 3.354102</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h4 class="Heading3">
				<span lang="EN-US">Example Using Two Constructors</span>
			</h4>
			<p class="TextBody">
				<span lang="EN-US">Since the constructor is defined explicitly, we have the option to provide more than one constructor.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				open System.Net<br>
				<br>
				type Car = class<br>
				&nbsp;&nbsp;&nbsp; val used : bool<br>
				&nbsp;&nbsp;&nbsp; val owner : string<br>
				&nbsp;&nbsp;&nbsp; val mutable mileage : int<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; (* first constructor *)<br>
				&nbsp;&nbsp;&nbsp; new (owner) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { used = false;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owner = owner;<br>
				&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mileage = 0 }<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; (* another constructor *)<br>
				&nbsp;&nbsp;&nbsp; new (owner, mileage) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { used = true;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owner = owner;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mileage = mileage }<br>
				end<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let printCar (c : Car) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "c.used: %b, c.owner: %s, c.mileage: %i" c.used c.owner c.mileage<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let stevesNewCar = new Car("Steve")<br>
				&nbsp;&nbsp;&nbsp; let bobsUsedCar = new Car("Bob", 83000)<br>
				&nbsp;&nbsp;&nbsp; let printCars() =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [stevesNewCar; bobsUsedCar] |&gt; Seq.iter printCar<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printfn "\nCars created"<br>
				&nbsp;&nbsp;&nbsp; printCars()<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printfn "\nSteve drives all over the state"&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; stevesNewCar.mileage &lt;- stevesNewCar.mileage + 780<br>
				&nbsp;&nbsp;&nbsp; printCars()<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printfn "\nBob commits odometer fraud"<br>
				&nbsp;&nbsp;&nbsp; bobsUsedCar.mileage &lt;- 0<br>
				&nbsp;&nbsp;&nbsp; printCars()<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program has the following types:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Car =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; val used: bool<br>
				&nbsp;&nbsp;&nbsp; val owner: string<br>
				&nbsp;&nbsp;&nbsp; val mutable mileage: int<br>
				&nbsp;&nbsp;&nbsp; new : owner:string * mileage:int -&gt; Car<br>
				&nbsp;&nbsp;&nbsp; new : owner:string -&gt; Car<br>
				&nbsp; end</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice that our</span> <span class="Teletyped"><span lang="EN-US" style=''>val</span></span> <span lang="EN-US">fields are included in the public interface of our class definition.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Cars createdc.used: false, c.owner: Steve, c.mileage: 0c.used: true, c.owner: Bob, c.mileage: 83000Steve drives all over the statec.used: false, c.owner: Steve, c.mileage: 780c.used: true, c.owner: Bob, c.mileage: 83000Bob commits odometer fraudc.used: false, c.owner: Steve, c.mileage: 780c.used: true, c.owner: Bob, c.mileage: 0</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Differences Between Implicit and Explicit Syntaxes</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">As you've probably guessed, the major difference between the two syntaxes is related to the constructor: the explicit syntax forces a programmer to provide explicit constructor(s), whereas the implicit syntax fuses the primary constructor with the class body. However, there are a few other subtle differences:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">The explicit syntax does not allow programmers to declare</span> <span class="Teletyped"><span lang="EN-US" style=''>let</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>do</span></span> <span lang="EN-US">bindings.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Even though you can use</span> <span class="Teletyped"><span lang="EN-US" style=''>val</span></span> <span lang="EN-US">fields in the implicit syntax, they must have the attribute</span> <span class="Teletyped"><span lang="EN-US" style=''>[&lt;DefaultValue&gt;]</span></span> <span lang="EN-US">and be mutable. It is more convenient to use</span> <span class="Teletyped"><span lang="EN-US" style=''>let</span></span> <span lang="EN-US">bindings in this case. You can add public</span> <span class="Teletyped"><span lang="EN-US" style=''>member</span></span> <span lang="EN-US">accessors when they need to be public.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">In the implicit syntax, the primary constructor parameters are visible throughout the whole class body. By using this feature, you do not need to write code that copies constructor parameters to instance members.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">While both syntaxes support multiple constructors, when you declare additional constructors with the implicit syntax, they must call the primary constructor. In the explicit syntax all constructors are declared with new() and there is no primary constructor that needs to be referenced from others.</span>
			</p>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Class with primary (implicit) constructor</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Class with only explicit constructors</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
						<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
							<span lang="EN-US">// The class body acts as a constructor<br>
							type Car1(make : string, model : string) = class<br>
							&nbsp;&nbsp;&nbsp; // x.Make and x.Model are property getters<br>
							&nbsp;&nbsp;&nbsp; // (explained later in this chapter)<br>
							&nbsp;&nbsp;&nbsp; // Notice how they can access the<br>
							&nbsp;&nbsp;&nbsp; // constructor parameters directly<br>
							&nbsp;&nbsp;&nbsp; member x.Make = make<br>
							&nbsp;&nbsp;&nbsp; member x.Model = model<br>
							<br>
							&nbsp;&nbsp;&nbsp; // This is an extra constructor.<br>
							&nbsp;&nbsp;&nbsp; // It calls the primary constructor<br>
							&nbsp;&nbsp;&nbsp; new () = Car1("default make", "default model")<br>
							end</span>
						</p>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
						<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
							<span lang="EN-US">type Car2 = class<br>
							&nbsp;&nbsp;&nbsp; // In this case, we need to declare<br>
							&nbsp;&nbsp;&nbsp; // all fields and their types explicitly<br>
							&nbsp;&nbsp;&nbsp; val private make : string<br>
							&nbsp;&nbsp;&nbsp; val private model : string<br>
							<br>
							&nbsp;&nbsp;&nbsp; // Notice how field access differs<br>
							&nbsp;&nbsp;&nbsp; // from parameter access<br>
							&nbsp;&nbsp;&nbsp; member x.Make = x.make<br>
							&nbsp;&nbsp;&nbsp; member x.Model = x.model<br>
							<br>
							&nbsp;&nbsp;&nbsp; // Two constructors<br>
							&nbsp;&nbsp;&nbsp; new (make : string, model : string) = {<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; make = make<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; model = model<br>
							&nbsp;&nbsp;&nbsp; }<br>
							&nbsp;&nbsp;&nbsp; new () = {<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; make = "default make"<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; model = "default model"<br>
							&nbsp;&nbsp;&nbsp; }<br>
							end</span>
						</p>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">In general, its up to the programmer to use the implicit or explicit syntax to define classes. However, the implicit syntax is used more often in practice as it tends to result in shorter, more readable class definitions.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Class Inference</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">F#'s</span> <span class="Teletyped"><span lang="EN-US" style=''>#light</span></span><span lang="EN-US">syntax allows programmers to omit the</span> <span class="Teletyped"><span lang="EN-US" style=''>class</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>end</span></span> <span lang="EN-US">keywords in class definitions, a feature commonly referred to as <em>class inference</em> or <em><a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec2.aspx#_Toc207785727"><span style='color:windowtext;text-decoration:none'>type kind inference</span></a></em>. For example, there is no difference between the following class definitions:</span>
			</p>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Class Inference</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Class Explicit</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
						<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
							<span lang="EN-US">type Product(make : string, model : string) =<br>
							&nbsp;&nbsp;&nbsp; member x.Make = make<br>
							&nbsp;&nbsp;&nbsp; member x.Model = model</span>
						</p>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
						<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
							<span lang="EN-US">type Car(make : string, model : string) = class&nbsp;&nbsp;&nbsp;<br>
							&nbsp;&nbsp;&nbsp; member x.Make = make<br>
							&nbsp;&nbsp;&nbsp; member x.Model = model<br>
							end</span>
						</p>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">Both classes compile down to the same bytecode, but the code using class inference allows us to omit a few unnecessary keywords.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Class inference and class explicit styles are considered acceptable. At the very least, when writing F# libraries, don't define half of your classes using class inference and the other half using class explicit style -- pick one style and use it consistently for all of your classes throughout your project.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Class Members</span>
			</h2>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Instance and Static Members</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">There are two types of members you can add to an object:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Instance members, which can only be called from an object instance created using the</span> <span class="Teletyped"><span lang="EN-US" style=''>new</span></span> <span lang="EN-US">keyword.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Static members, which are not associated with any object instance.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The following class has a static method and an instance method:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type SomeClass(prop : int) = class<br>
				&nbsp;&nbsp;&nbsp; member x.Prop = prop<br>
				&nbsp;&nbsp;&nbsp; static member SomeStaticMethod = "This is a static method"<br>
				end</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We invoke a static method using the form</span> <span class="Teletyped"><span lang="EN-US" style=''>className.methodName</span></span><span lang="EN-US">. We invoke instance methods by creating an instance of our class and calling the methods using</span> <span class="Teletyped"><span lang="EN-US" style=''>classInstance.methodName</span></span><span lang="EN-US">. Here is a demonstration in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; SomeClass.SomeStaticMethod;; (* invoking static method *)<br>
				val it : string = "This is a static method"<br>
				<br>
				&gt; SomeClass.Prop;; (* doesn't make sense, we haven't created an object instance yet *)<br>
				<br>
				&nbsp; SomeClass.Prop;; (* doesn't make sense, we haven't created an object instance yet *)<br>
				&nbsp; ^^^^^^^^^^^^^^^<br>
				<br>
				stdin(78,1): error FS0191: property 'Prop' is not static.<br>
				<br>
				&gt; let instance = new SomeClass(5);;<br>
				<br>
				val instance : SomeClass<br>
				<br>
				&gt; instance.Prop;; (* now we have an instance, we can call our instance method *)<br>
				val it : int = 5<br>
				<br>
				&gt; instance.SomeStaticMethod;; (* can't invoke static method from instance *)<br>
				<br>
				&nbsp; instance.SomeStaticMethod;; (* can't invoke static method from instance *)<br>
				&nbsp; ^^^^^^^^^^^^^^^^^^^^^^^^^^<br>
				<br>
				stdin(81,1): error FS0191: property 'SomeStaticMethod' is static.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can, of course, invoke instance methods from objects passed <em>into</em> static methods, for example, let's say we add a</span> <span class="Teletyped"><span lang="EN-US" style=''>Copy</span></span> <span lang="EN-US">method to our object defined above:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type SomeClass(prop : int) = class<br>
				&nbsp;&nbsp;&nbsp; member x.Prop = prop<br>
				&nbsp;&nbsp;&nbsp; static member SomeStaticMethod = "This is a static method"<br>
				&nbsp;&nbsp;&nbsp; static member Copy (source : SomeClass) = new SomeClass(source.Prop)<br>
				end</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can experiment with this method in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let instance = new SomeClass(10);;<br>
				<br>
				val instance : SomeClass<br>
				<br>
				&gt; let shallowCopy = instance;; (* copies pointer to another symbol *)<br>
				<br>
				val shallowCopy : SomeClass<br>
				<br>
				&gt; let deepCopy = SomeClass.Copy instance;; (* copies values into a new object *)<br>
				<br>
				val deepCopy : SomeClass<br>
				<br>
				&gt; open System;;<br>
				<br>
				&gt; Object.ReferenceEquals(instance, shallowCopy);;<br>
				val it : bool = true<br>
				<br>
				&gt; Object.ReferenceEquals(instance, deepCopy);;<br>
				val it : bool = false</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>Object.ReferenceEquals</span></span> <span lang="EN-US">is a static method on the</span> <span class="Teletyped"><span lang="EN-US" style=''>System.Object</span></span> <span lang="EN-US">class which determines whether two objects instances are the same object. As shown above, our</span> <span class="Teletyped"><span lang="EN-US" style=''>Copy</span></span> <span lang="EN-US">method takes an instance of</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>SomeClass</span></span> <span lang="EN-US">and accesses its</span> <span class="Teletyped"><span lang="EN-US" style=''>Prop</span></span> <span lang="EN-US">property.</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">When should you use static methods rather than instance methods?</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">When the designers of the .NET framework were designing the</span> <span class="Teletyped"><span lang="EN-US" style=''>System.String</span></span> <span lang="EN-US">class, they had to decide where the</span> <span class="Teletyped"><span lang="EN-US" style=''>Length</span></span> <span lang="EN-US">method should go. They had the option of making the property an instance method (</span><span class="Teletyped"><span lang="EN-US" style=''>s.Length</span></span><span lang="EN-US">) or making it static (</span><span class="Teletyped"><span lang="EN-US" style=''>String.GetLength(s)</span></span><span lang="EN-US">). The .NET designers chose to make</span> <span class="Teletyped"><span lang="EN-US" style=''>Length</span></span> <span lang="EN-US">an instance method because it is an intrinsic property of strings.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">On the other hand, the</span> <span class="Teletyped"><span lang="EN-US" style=''>String</span></span> <span lang="EN-US">class also has several static methods, including</span> <span class="Teletyped"><span lang="EN-US" style=''>String.Concat</span></span> <span lang="EN-US">which takes a list of string and concatenates them all together. Concatenating strings is instance-agnostic, its does not depend on the instance members of any <em>particular</em> strings.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The following general principles apply to all OO languages:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Instance members should be used to access properties intrinsic to an object, such as</span> <span class="Teletyped"><span lang="EN-US" style=''>stringInstance.Length</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Instance methods should be used when they depend on state of a <em>particular</em> object instance, such as</span> <span class="Teletyped"><span lang="EN-US" style=''>stringInstance.Contains</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Instance methods should be used when its expected that programmers will want to override the method in a derived class.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Static methods should not depend on a particular instance of an object, such as</span> <span class="Teletyped"><span lang="EN-US" style=''>Int32.TryParse</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Static methods should return the same value as long as the inputs remain the same.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Constants, which are values that don't change for any class instance, should be declared as a static members, such as</span> <span class="Teletyped"><span lang="EN-US" style=''>System.Boolean.TrueString</span></span><span lang="EN-US">.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Getters and Setters</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Getters and setters are special functions which allow programmers to read and write to members using a convenient syntax. Getters and setters are written using this format:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">member alias.PropertyName<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = some-value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(value) = some-assignment</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here's a simple example using fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; type IntWrapper() = class<br>
				&nbsp;&nbsp;&nbsp; let mutable num = 0<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Num<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = num<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(value) = num &lt;- value<br>
				end;;<br>
				<br>
				type IntWrapper =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; new : unit -&gt; IntWrapper<br>
				&nbsp;&nbsp;&nbsp; member Num : int<br>
				&nbsp;&nbsp;&nbsp; member Num : int with set<br>
				&nbsp; end<br>
				<br>
				&gt; let wrapper = new IntWrapper();;<br>
				<br>
				val wrapper : IntWrapper<br>
				<br>
				&gt; wrapper.Num;;<br>
				val it : int = 0<br>
				<br>
				&gt; wrapper.Num &lt;- 20;;<br>
				val it : unit = ()<br>
				<br>
				&gt; wrapper.Num;;<br>
				val it : int = 20</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Getters and setters are used to expose private members to outside world. For example, our</span> <span class="Teletyped"><span lang="EN-US" style=''>Num</span></span> <span lang="EN-US">property allows users to read/write to the internal</span> <span class="Teletyped"><span lang="EN-US" style=''>num</span></span> <span lang="EN-US">variable. Since getters and setters are glorified functions, we can use them to sanitize input before writing the values to our internal variables. For example, we can modify our</span> <span class="Teletyped"><span lang="EN-US" style=''>IntWrapper</span></span> <span lang="EN-US">class to constrain our to values between 0 and 10 by modifying our class as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type IntWrapper() = class<br>
				&nbsp;&nbsp;&nbsp; let mutable num = 0<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Num<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = num<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(value) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if value &gt; 10 || value &lt; 0 then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise (new Exception("Values must be between 0 and 10"))<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num &lt;- value<br>
				end</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can use this class in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let wrapper = new IntWrapper();;<br>
				<br>
				val wrapper : IntWrapper<br>
				<br>
				&gt; wrapper.Num &lt;- 5;;<br>
				val it : unit = ()<br>
				<br>
				&gt; wrapper.Num;;<br>
				val it : int = 5<br>
				<br>
				&gt; wrapper.Num &lt;- 20;;<br>
				System.Exception: Values must be between 0 and 10<br>
				&nbsp;&nbsp; at FSI_0072.IntWrapper.set_Num(Int32 value)<br>
				&nbsp;&nbsp; at &lt;StartupCode$FSI_0076&gt;.$FSI_0076._main()<br>
				stopped due to error</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Adding Members to Records and Unions</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Its just as easy to add members to records and union types as well.</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Record example:</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; type Line =<br>
				&nbsp;&nbsp;&nbsp; { X1 : float; Y1 : float;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X2 : float; Y2 : float }<br>
				&nbsp;&nbsp;&nbsp; with&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member x.Length =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let sqr x = x * x<br>
				&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqrt(sqr(x.X1 - x.X2) + sqr(x.Y1 - x.Y2))<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member x.ShiftH amount =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { x with X1 = x.X1 + amount; X2 = x.X2 + amount }<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member x.ShiftV amount =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { x with Y1 = x.Y1 + amount; Y2 = x.Y2 + amount };;<br>
				<br>
				type Line =<br>
				&nbsp; {X1: float;<br>
				&nbsp;&nbsp; Y1: float;<br>
				&nbsp;&nbsp; X2: float;<br>
				&nbsp;&nbsp; Y2: float;}<br>
				&nbsp; with<br>
				&nbsp;&nbsp;&nbsp; member ShiftH : amount:float -&gt; Line<br>
				&nbsp;&nbsp;&nbsp; member ShiftV : amount:float -&gt; Line<br>
				&nbsp;&nbsp;&nbsp; member Length : float<br>
				&nbsp; end<br>
				<br>
				&gt; let line = { X1 = 1.0; Y1 = 2.0; X2 = 5.0; Y2 = 4.5 };;<br>
				<br>
				val line : Line<br>
				<br>
				&gt; line.Length;;<br>
				val it : float = 4.716990566<br>
				<br>
				&gt; line.ShiftH 10.0;;<br>
				val it : Line = {X1 = 11.0;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y1 = 2.0;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X2 = 15.0;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y2 = 4.5;}<br>
				<br>
				&gt; line.ShiftV -5.0;;<br>
				val it : Line = {X1 = 1.0;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y1 = -3.0;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X2 = 5.0;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y2 = -0.5;}</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Union example</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; type shape =<br>
				&nbsp;&nbsp;&nbsp; | Circle of float<br>
				&nbsp;&nbsp;&nbsp; | Rectangle of float * float<br>
				&nbsp;&nbsp;&nbsp; | Triangle of float * float<br>
				&nbsp;&nbsp;&nbsp; with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member x.Area =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match x with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Circle(r) -&gt; Math.PI * r * r<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Rectangle(b, h) -&gt; b * h<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Triangle(b, h) -&gt; b * h / 2.0<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member x.Scale value =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match x with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Circle(r) -&gt; Circle(r + value)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Rectangle(b, h) -&gt; Rectangle(b + value, h + value)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Triangle(b, h) -&gt; Triangle(b + value, h + value);;<br>
				<br>
				type shape =<br>
				&nbsp; | Circle of float<br>
				&nbsp; | Rectangle of float * float<br>
				&nbsp; | Triangle of float * float<br>
				&nbsp; with<br>
				&nbsp;&nbsp;&nbsp; member Scale : value:float -&gt; shape<br>
				&nbsp;&nbsp;&nbsp; member Area : float<br>
				&nbsp; end<br>
				<br>
				&gt; let mycircle = Circle(5.0);;<br>
				<br>
				val mycircle : shape<br>
				<br>
				&gt; mycircle.Area;;<br>
				val it : float = 78.53981634<br>
				<br>
				&gt; mycircle.Scale(7.0);;<br>
				val it : shape = Circle 12.0</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Generic classes</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">We can also create classes which take generic types:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type 'a GenericWrapper(initialVal : 'a) = class<br>
				&nbsp;&nbsp;&nbsp; let mutable internalVal = initialVal<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = internalVal<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(value) = internalVal &lt;- value<br>
				end</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can use this class in FSI as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let intWrapper = new GenericWrapper&lt;_&gt;(5);;<br>
				<br>
				val intWrapper : int GenericWrapper<br>
				<br>
				&gt; intWrapper.Value;;<br>
				val it : int = 5<br>
				<br>
				&gt; intWrapper.Value &lt;- 20;;<br>
				val it : unit = ()<br>
				<br>
				&gt; intWrapper.Value;;<br>
				val it : int = 20<br>
				<br>
				&gt; intWrapper.Value &lt;- 2.0;; (* throws an exception *)<br>
				<br>
				&nbsp; intWrapper.Value &lt;- 2.0;; (* throws an exception *)<br>
				&nbsp; --------------------^^^^<br>
				<br>
				stdin(156,21): error FS0001: This expression has type<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float<br>
				but is here used with type<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int.<br>
				<br>
				&gt; let boolWrapper = new GenericWrapper&lt;_&gt;(true);;<br>
				<br>
				val boolWrapper : bool GenericWrapper<br>
				<br>
				&gt; boolWrapper.Value;;<br>
				val it : bool = true</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Generic classes help programmers generalize classes to operate on multiple different types. They are used in fundamentally the same way as all other generic types already seen in F#, such as Lists, Sets, Maps, and union types.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Pattern Matching Objects</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">While it's not possible to match objects based on their <em>structure</em> in quite the same way that we do for lists and union types, F# allows programmers to match on <em>types</em> using the syntax:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">match arg with<br>
				| :? type1 -&gt; expr<br>
				| :? type2 -&gt; expr</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here's an example which uses type testing:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Cat() = class<br>
				&nbsp;&nbsp;&nbsp; member x.Meow() = printfn "Meow"<br>
				end<br>
				<br>
				type Person(name : string) = class<br>
				&nbsp;&nbsp;&nbsp; member x.Name = name<br>
				&nbsp;&nbsp;&nbsp; member x.SayHello() = printfn "Hi, I'm %s" x.Name<br>
				end<br>
				<br>
				type Monkey() = class<br>
				&nbsp;&nbsp;&nbsp; member x.SwingFromTrees() = printfn "swinging from trees"<br>
				end<br>
				<br>
				let handlesAnything (o : obj) =<br>
				&nbsp;&nbsp;&nbsp; match o with<br>
				&nbsp;&nbsp;&nbsp; | null -&gt; printfn "&lt;null&gt;"<br>
				&nbsp;&nbsp;&nbsp; | :? Cat as cat -&gt; cat.Meow()<br>
				&nbsp;&nbsp;&nbsp; | :? Person as person -&gt; person.SayHello()<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt; printfn "I don't recognize type '%s'" (o.GetType().Name)<br>
				<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; let cat = new Cat()<br>
				&nbsp;&nbsp;&nbsp; let bob = new Person("Bob")<br>
				&nbsp;&nbsp;&nbsp; let bill = new Person("Bill")<br>
				&nbsp;&nbsp;&nbsp; let phrase = "Hello world!"<br>
				&nbsp;&nbsp;&nbsp; let monkey = new Monkey()<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; handlesAnything cat<br>
				&nbsp;&nbsp;&nbsp; handlesAnything bob<br>
				&nbsp;&nbsp;&nbsp; handlesAnything bill<br>
				&nbsp;&nbsp;&nbsp; handlesAnything phrase<br>
				&nbsp;&nbsp;&nbsp; handlesAnything monkey<br>
				&nbsp;&nbsp;&nbsp; handlesAnything null<br>
				<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">MeowHi, I'm BobHi, I'm BillI don't recognize type 'String'I don't recognize type 'Monkey'&lt;null&gt;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Inheritance
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Inheritance</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">Many object-oriented languages use <span class="Bold">inheritance</span> extensively in the .NET BCL to construct class hierarchies.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Subclasses</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">A subclass is, in the simplest terms, a class derived from a class which has already been defined. A subclass inherits its members from a base class in addition to adding its own members. A subclass is defined using the</span> <span class="Teletyped"><span lang="EN-US" style=''>inherit</span></span> <span lang="EN-US">keyword as shown below:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Person(name) =<br>
				&nbsp;&nbsp;&nbsp; member x.Name = name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Greet() = printfn "Hi, I'm %s" x.Name<br>
				&nbsp;&nbsp;&nbsp;<br>
				type Student(name, studentID : int) =<br>
				&nbsp;&nbsp;&nbsp; inherit Person(name)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let mutable _GPA = 0.0<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.StudentID = studentID<br>
				&nbsp;&nbsp;&nbsp; member x.GPA<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = _GPA<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set value = _GPA &lt;- value<br>
				&nbsp;&nbsp;&nbsp;<br>
				type Worker(name, employer : string) =<br>
				&nbsp;&nbsp;&nbsp; inherit Person(name)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let mutable _salary = 0.0<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Salary<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = _salary<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set value = _salary &lt;- value<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Employer = employer</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Our simple class hierarchy looks like this:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">System.Object (* All classes descend from&nbsp; *) - Person&nbsp;&nbsp; - Student&nbsp;&nbsp; - Worker</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>Student</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>Worker</span></span> <span lang="EN-US">subclasses both inherit the</span> <span class="Teletyped"><span lang="EN-US" style=''>Name</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>Greet</span></span> <span lang="EN-US">methods from the</span> <span class="Teletyped"><span lang="EN-US" style=''>Person</span></span> <span lang="EN-US">base class. This can be demonstrated in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let somePerson, someStudent, someWorker =<br>
				&nbsp;&nbsp;&nbsp; new Person("Juliet"), new Student("Monique", 123456), new Worker("Carla", "Awesome Hair Salon");;<br>
				<br>
				val someWorker : Worker<br>
				val someStudent : Student<br>
				val somePerson : Person<br>
				<br>
				&gt; somePerson.Name, someStudent.Name, someWorker.Name;;<br>
				val it : string * string * string = ("Juliet", "Monique", "Carla")<br>
				<br>
				&gt; someStudent.StudentID;;<br>
				val it : int = 123456<br>
				<br>
				&gt; someWorker.Employer;;<br>
				val it : string = "Awesome Hair Salon"<br>
				<br>
				&gt; someWorker.ToString();; (* ToString method inherited from System.Object *)<br>
				val it : string = "FSI_0002+Worker"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">.NET's object model supports <em>single-class inheritance</em>, meaning that a subclass is limited to one base class. In other words, its not possible to create a class which derives from</span> <span class="Teletyped"><span lang="EN-US" style=''>Student</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Employee</span></span> <span lang="EN-US">simultaneously.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Overriding Methods</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Occasionally, you may want a derived class to change the default behavior of methods inherited from the base class. For example, the output of the</span> <span class="Teletyped"><span lang="EN-US" style=''>.ToString()</span></span> <span lang="EN-US">method above isn't very useful. We can override that behavior with a different implementation using the</span> <span class="Teletyped"><span lang="EN-US" style=''>override</span></span><span lang="EN-US">:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Person(name) =<br>
				&nbsp;&nbsp;&nbsp; member x.Name = name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Greet() = printfn "Hi, I'm %s" x.Name<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; override x.ToString() = x.Name&nbsp;&nbsp;&nbsp; (* The ToString() method is inherited from System.Object *)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We've overridden the default implementation of the</span> <span class="Teletyped"><span lang="EN-US" style=''>ToString()</span></span> <span lang="EN-US">method, causing it to print out a person's name.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Methods in F# are not overridable by default. If you expect users will want to override methods in a derived class, you have to declare your method as overridable using the</span> <span class="Teletyped"><span lang="EN-US" style=''>abstract</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>default</span></span> <span lang="EN-US">keywords as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Person(name) =<br>
				&nbsp;&nbsp;&nbsp; member x.Name = name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; abstract Greet : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; default x.Greet() = printfn "Hi, I'm %s" x.Name<br>
				&nbsp;&nbsp;&nbsp;<br>
				type Quebecois(name) =<br>
				&nbsp;&nbsp;&nbsp; inherit Person(name)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; override x.Greet() = printfn "Bonjour, je m'appelle %s, eh." x.Name</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Our class</span> <span class="Teletyped"><span lang="EN-US" style=''>Person</span></span><span lang="EN-US">provides a</span> <span class="Teletyped"><span lang="EN-US" style=''>Greet</span></span> <span lang="EN-US">method which may be overridden in derived classes. Here's an example of these two classes in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let terrance, phillip = new Person("Terrance"), new Quebecois("Phillip");;<br>
				<br>
				val terrance : Person<br>
				val phillip : Quebecois<br>
				<br>
				&gt; terrance.Greet();;<br>
				Hi, I'm Terrance<br>
				val it : unit = ()<br>
				<br>
				&gt; phillip.Greet();;<br>
				Bonjour, je m'appelle Phillip, eh.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Abstract Classes</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">An abstract class is one which provides an incomplete implementation of a object, and requires a programmer to create subclasses of the abstract class to fill in the rest of the implementation. For example, consider the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">[&lt;AbstractClass&gt;]<br>
				type Shape(position : Point) =<br>
				&nbsp;&nbsp;&nbsp; member x.Position = position<br>
				&nbsp;&nbsp;&nbsp; override x.ToString() =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf "position = {%i, %i}, area = %f" position.X position.Y (x.Area())<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; abstract member Draw : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; abstract member Area : unit -&gt; float</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The first thing you'll notice is the</span> <span class="Teletyped"><span lang="EN-US" style=''>AbstractClass</span></span> <span lang="EN-US">attribute, which tells the compiler that our class has some abstract members. Additionally, you notice two abstract members,</span> <span class="Teletyped"><span lang="EN-US" style=''>Draw</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Area</span></span> <span lang="EN-US">don't have an implementation, only a type signature.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can't create an instance of</span> <span class="Teletyped"><span lang="EN-US" style=''>Shape</span></span> <span lang="EN-US">because the class hasn't been fully implemented. Instead, we have to derive from</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Shape</span></span> <span lang="EN-US">and override the</span> <span class="Teletyped"><span lang="EN-US" style=''>Draw</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Area</span></span> <span lang="EN-US">methods with a concrete implementation:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Circle(position : Point, radius : float) =<br>
				&nbsp;&nbsp;&nbsp; inherit Shape(position)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Radius = radius<br>
				&nbsp;&nbsp;&nbsp; override x.Draw() = printfn "(Circle)"<br>
				&nbsp;&nbsp;&nbsp; override x.Area() = Math.PI * radius * radius<br>
				&nbsp;&nbsp;&nbsp;<br>
				type Rectangle(position : Point, width : float, height : float) =<br>
				&nbsp;&nbsp;&nbsp; inherit Shape(position)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Width = width<br>
				&nbsp;&nbsp;&nbsp; member x.Height = height<br>
				&nbsp;&nbsp;&nbsp; override x.Draw() = printfn "(Rectangle)"<br>
				&nbsp;&nbsp;&nbsp; override x.Area() = width * height<br>
				&nbsp;&nbsp;&nbsp;<br>
				type Square(position : Point, width : float) =<br>
				&nbsp;&nbsp;&nbsp; inherit Shape(position)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Width = width<br>
				&nbsp;&nbsp;&nbsp; member x.ToRectangle() = new Rectangle(position, width, width)<br>
				&nbsp;&nbsp;&nbsp; override x.Draw() = printfn "(Square)"<br>
				&nbsp;&nbsp;&nbsp; override x.Area() = width * width<br>
				&nbsp;&nbsp;&nbsp;<br>
				type Triangle(position : Point, sideA : float, sideB : float, sideC : float) =<br>
				&nbsp;&nbsp;&nbsp; inherit Shape(position)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.SideA = sideA<br>
				&nbsp;&nbsp;&nbsp; member x.SideB = sideB<br>
				&nbsp;&nbsp;&nbsp; member x.SideC = sideC<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; override x.Draw() = printfn "(Triangle)"<br>
				&nbsp;&nbsp;&nbsp; override x.Area() =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* Heron's formula *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let a, b, c = sideA, sideB, sideC<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;let s = (a + b + c) / 2.0<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.Sqrt(s * (s - a) * (s - b) * (s - c) )</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Now we have several different implementations of the</span> <span class="Teletyped"><span lang="EN-US" style=''>Shape</span></span> <span lang="EN-US">class. We can experiment with these in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let position = { X = 0; Y = 0 };;<br>
				<br>
				val position : Point<br>
				<br>
				&gt; let circle, rectangle, square, triangle =<br>
				&nbsp;&nbsp;&nbsp; new Circle(position, 5.0),<br>
				&nbsp;&nbsp;&nbsp; new Rectangle(position, 2.0, 7.0),<br>
				&nbsp;&nbsp;&nbsp; new Square(position, 10.0),<br>
				&nbsp;&nbsp;&nbsp; new Triangle(position, 3.0, 4.0, 5.0);;<br>
				<br>
				val triangle : Triangle<br>
				val square : Square<br>
				val rectangle : Rectangle<br>
				val circle : Circle<br>
				<br>
				&gt; circle.ToString();;<br>
				val it : string = "Circle, position = {0, 0}, area = 78.539816"<br>
				<br>
				&gt; triangle.ToString();;<br>
				val it : string = "Triangle, position = {0, 0}, area = 6.000000"<br>
				<br>
				&gt; square.Width;;<br>
				val it : float = 10.0<br>
				<br>
				&gt; square.ToRectangle().ToString();;<br>
				val it : string = "Rectangle, position = {0, 0}, area = 100.000000"<br>
				<br>
				&gt; rectangle.Height, rectangle.Width;;<br>
				val it : float * float = (7.0, 2.0)</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Working With Subclasses</span>
			</h2>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Up-casting and Down-casting</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">A <em>type cast</em> is an operation which changes the type of an object from one type to another. This is not the same as a map function, because a type cast does not return an instance of a new object, it returns the same instance of an object with a different type.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">For example, let's say</span> <span class="Teletyped"><span lang="EN-US" style=''>B</span></span> <span lang="EN-US">is a subclass of</span> <span class="Teletyped"><span lang="EN-US" style=''>A</span></span><span lang="EN-US">. If we have an instance of</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>B</span></span><span lang="EN-US">, we are able to cast as an instance of</span> <span class="Teletyped"><span lang="EN-US" style=''>A</span></span><span lang="EN-US">. Since</span> <span class="Teletyped"><span lang="EN-US" style=''>A</span></span> <span lang="EN-US">is upward in the class hiearchy, we call this an up-cast. We use the</span> <span class="Teletyped"><span lang="EN-US" style=''>:&gt;</span></span> <span lang="EN-US">operator to perform upcasts:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let regularString = "Hello world";;<br>
				<br>
				val regularString : string<br>
				<br>
				&gt; let upcastString = "Hello world" :&gt; obj;;<br>
				<br>
				val upcastString : obj<br>
				<br>
				&gt; regularString.ToString();;<br>
				val it : string = "Hello world"<br>
				<br>
				&gt; regularString.Length;;<br>
				val it : int = 11<br>
				<br>
				&gt; upcastString.ToString();; (* type obj has a .ToString method *)<br>
				val it : string = "Hello world"<br>
				<br>
				&gt; upcastString.Length;; (* however, obj does not have Length method *)<br>
				<br>
				&nbsp; upcastString.Length;; (* however, obj does not have Length method *)<br>
				&nbsp; -------------^^^^^^^<br>
				<br>
				stdin(24,14): error FS0039: The field, constructor or member 'Length' is not defined.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Up-casting is considered "safe", because a derived class is guaranteed to have all of the same members as an ancestor class. We can, if necessary, go in the opposite direction: we can down-cast from an ancestor class to a derived class using the</span> <span class="Teletyped"><span lang="EN-US" style=''>:?&gt;</span></span> <span lang="EN-US">operator:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; let intAsObj = 20 :&gt; obj;;<br>
				<br>
				val intAsObj : obj<br>
				<br>
				&gt; intAsObj, intAsObj.ToString();;<br>
				val it : obj * string = (20, "20")<br>
				<br>
				&gt; let intDownCast = intAsObj :?&gt; int;;<br>
				<br>
				val intDownCast : int<br>
				<br>
				&gt; intDownCast, intDownCast.ToString();;<br>
				val it : int * string = (20, "20")<br>
				<br>
				&gt; let stringDownCast = intAsObj :?&gt; string;; (* boom! *)<br>
				<br>
				val stringDownCast : string<br>
				<br>
				System.InvalidCastException: Unable to cast object of type 'System.Int32' to type 'System.String'.<br>
				&nbsp;&nbsp; at &lt;StartupCode$FSI_0067&gt;.$FSI_0067._main()<br>
				stopped due to error</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Since</span> <span class="Teletyped"><span lang="EN-US" style=''>intAsObj</span></span><span lang="EN-US">holds an</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">boxed as an</span> <span class="Teletyped"><span lang="EN-US" style=''>obj</span></span><span lang="EN-US">, we can downcast to an</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">as needed. However, we cannot downcast to a</span> <span class="Teletyped"><span lang="EN-US" style=''>string</span></span> <span lang="EN-US">because its an incompatible type. Down-casting is considered "unsafe" because the error isn't detectable by the type-checker, so an error with a down-cast always results in a runtime exception.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h4 class="Heading3">
				<span lang="EN-US">Up-casting example</span>
			</h4>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				type Point = { X : int; Y : int }<br>
				<br>
				[&lt;AbstractClass&gt;]<br>
				type Shape() =<br>
				&nbsp;&nbsp;&nbsp; override x.ToString() =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf "%s, area = %f" (x.GetType().Name) (x.Area())<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; abstract member Draw : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; abstract member Area : unit -&gt; float<br>
				&nbsp;&nbsp;&nbsp;<br>
				type Circle(radius : float) =<br>
				&nbsp; &nbsp;&nbsp;inherit Shape()<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Radius = radius<br>
				&nbsp;&nbsp;&nbsp; override x.Draw() = printfn "(Circle)"<br>
				&nbsp;&nbsp;&nbsp; override x.Area() = Math.PI * radius * radius<br>
				&nbsp;&nbsp;&nbsp;<br>
				type Rectangle(width : float, height : float) =<br>
				&nbsp;&nbsp;&nbsp; inherit Shape()<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Width = width<br>
				&nbsp;&nbsp;&nbsp; member x.Height = height<br>
				&nbsp;&nbsp;&nbsp; override x.Draw() = printfn "(Rectangle)"<br>
				&nbsp;&nbsp;&nbsp; override x.Area() = width * height<br>
				&nbsp;&nbsp;&nbsp;<br>
				type Square(width : float) =<br>
				&nbsp;&nbsp;&nbsp; inherit Shape()<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.Width = width<br>
				&nbsp;&nbsp;&nbsp; member x.ToRectangle() = new Rectangle(width, width)<br>
				&nbsp;&nbsp;&nbsp; override x.Draw() = printfn "(Square)"<br>
				&nbsp;&nbsp;&nbsp; override x.Area() = width * width<br>
				&nbsp;&nbsp;&nbsp;<br>
				type Triangle(sideA : float, sideB : float, sideC : float) =<br>
				&nbsp;&nbsp;&nbsp; inherit Shape()<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member x.SideA = sideA<br>
				&nbsp;&nbsp;&nbsp; member x.SideB = sideB<br>
				&nbsp;&nbsp;&nbsp; member x.SideC = sideC<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp; &nbsp;override x.Draw() = printfn "(Triangle)"<br>
				&nbsp;&nbsp;&nbsp; override x.Area() =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* Heron's formula *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let a, b, c = sideA, sideB, sideC<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let s = (a + b + c) / 2.0<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Math.Sqrt(s * (s - a) * (s - b) * (s - c) )<br>
				<br>
				let shapes =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [(new Circle(5.0) :&gt; Shape);<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (new Circle(12.0) :&gt; Shape);<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (new Square(10.5) :&gt; Shape);<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (new Triangle(3.0, 4.0, 5.0) :&gt; Shape);<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (new Rectangle(5.0, 2.0) :&gt; Shape)]<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* Notice we have to cast each object as a Shape *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; shapes<br>
				&nbsp;&nbsp;&nbsp; |&gt; Seq.iter (fun x -&gt; printfn "x.ToString: %s" (x.ToString()) )<br>
				<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program has the following types:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Point =<br>
				&nbsp; {X: int;<br>
				&nbsp;&nbsp; Y: int;}<br>
				<br>
				type Shape =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; abstract member Area : unit -&gt; float<br>
				&nbsp;&nbsp;&nbsp; abstract member Draw : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; new : unit -&gt; Shape<br>
				&nbsp;&nbsp;&nbsp; override ToString : unit -&gt; string<br>
				&nbsp; end<br>
				<br>
				type Circle =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; inherit Shape<br>
				&nbsp;&nbsp;&nbsp; new : radius:float -&gt; Circle<br>
				&nbsp;&nbsp;&nbsp; override Area : unit -&gt; float<br>
				&nbsp;&nbsp;&nbsp; override Draw : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; member Radius : float<br>
				&nbsp; end<br>
				<br>
				type Rectangle =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; inherit Shape<br>
				&nbsp;&nbsp;&nbsp; new : width:float * height:float -&gt; Rectangle<br>
				&nbsp;&nbsp;&nbsp; override Area : unit -&gt; float<br>
				&nbsp;&nbsp;&nbsp; override Draw : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; member Height : float<br>
				&nbsp;&nbsp;&nbsp; member Width : float<br>
				&nbsp; end<br>
				<br>
				type Square =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; inherit Shape<br>
				&nbsp;&nbsp;&nbsp; new : width:float -&gt; Square<br>
				&nbsp;&nbsp;&nbsp; override Area : unit -&gt; float<br>
				&nbsp;&nbsp;&nbsp; override Draw : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; member ToRectangle : unit -&gt; Rectangle<br>
				&nbsp;&nbsp;&nbsp; member Width : float<br>
				&nbsp; end<br>
				<br>
				type Triangle =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; inherit Shape<br>
				&nbsp;&nbsp;&nbsp; new : sideA:float * sideB:float * sideC:float -&gt; Triangle<br>
				&nbsp;&nbsp;&nbsp; override Area : unit -&gt; float<br>
				&nbsp;&nbsp;&nbsp; override Draw : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; member SideA : float<br>
				&nbsp;&nbsp;&nbsp; member SideB : float<br>
				&nbsp;&nbsp;&nbsp; member SideC : float<br>
				&nbsp; end<br>
				<br>
				val shapes : Shape list</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">x.ToString: Circle, area = 78.539816x.ToString: Circle, area = 452.389342x.ToString: Square, area = 110.250000x.ToString: Triangle, area = 6.000000x.ToString: Rectangle, area = 10.000000</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Interfaces
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Interfaces</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">An object's <span class="Bold">interface</span> refers to all of the public members and functions that a function exposes to consumers of the object. For example, take the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Monkey(name : string, birthday : DateTime) =<br>
				&nbsp;&nbsp;&nbsp; let mutable _birthday = birthday<br>
				&nbsp;&nbsp;&nbsp; let mutable _lastEaten = DateTime.Now<br>
				&nbsp;&nbsp;&nbsp; let mutable _foodsEaten = [] : string list<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Speak() = printfn "Ook ook!"<br>
				&nbsp;&nbsp;&nbsp; member this.Name = name<br>
				&nbsp;&nbsp;&nbsp; member this.Birthday<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = _birthday<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(value) = _birthday &lt;- value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member internal this.UpdateFoodsEaten(food) = _foodsEaten &lt;- food :: _foodsEaten<br>
				&nbsp;&nbsp;&nbsp; member internal this.ResetLastEaten() = _lastEaten &lt;- DateTime.Now<br>
				&nbsp;&nbsp;&nbsp; member this.IsHungry = (DateTime.Now - _lastEaten).TotalSeconds &gt;= 5.0<br>
				&nbsp;&nbsp;&nbsp; member this.GetFoodsEaten() = _lastEaten<br>
				&nbsp;&nbsp;&nbsp; member this.Feed(food) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.UpdateFoodsEaten(food)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.ResetLastEaten()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.Speak()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This class contains several public, private, and internal members. However, consumers of this class can only access the public members; when a consumer uses this class, they see the following interface:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Monkey =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; new : name:string * birthday:DateTime -&gt; Monkey<br>
				&nbsp;&nbsp;&nbsp; member Feed : food:string -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; member GetFoodsEaten : unit -&gt; DateTime<br>
				&nbsp;&nbsp;&nbsp; member Speak : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; member Birthday : DateTime<br>
				&nbsp;&nbsp;&nbsp; member IsHungry : bool<br>
				&nbsp;&nbsp;&nbsp; member Name : string<br>
				&nbsp;&nbsp;&nbsp; member Birthday : DateTime with set<br>
				&nbsp; end</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice the</span> <span class="Teletyped"><span lang="EN-US" style=''>_birthday</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>_lastEaten</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>_foodsEaten</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>UpdateFoodsEaten</span></span><span lang="EN-US">, and</span> <span class="Teletyped"><span lang="EN-US" style=''>ResetLastEaten</span></span> <span lang="EN-US">members are inaccessible to the outside world, so they are not part of this object's public interface.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">All interfaces you've seen so far have been intrinsically tied to a specific object. However, F# and many other OO languages allow users to define interfaces as stand-alone types, allowing us to effectively <em>separate an object's interface from its implementation</em>.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Defining Interfaces</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">According to the <a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec2.aspx#_Toc207785736"><span style='color:windowtext;text-decoration:none'>F# specification</span></a>, interfaces are defined with the following syntax:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type type-name =<br>
				&nbsp;&nbsp; interface<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inherits-decl<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member-defns<br>
				&nbsp;&nbsp; end</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US">Note:</span></span> <span lang="EN-US">The interface/end tokens can be omitted when using the #light syntax option, in which case Type Kind Inference (</span> <a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec2.aspx#_Toc207785727"><span lang="EN-US" style='color:windowtext;text-decoration:none'>&sect;10.1</span></a><span lang="EN-US">) is used to determine the kind of the type. The presence of any non-abstract members or constructors means a type is not an interface type.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">For example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type ILifeForm = (* .NET convention recommends the prefix 'I' on all interfaces *)<br>
				&nbsp;&nbsp;&nbsp; abstract Name : string<br>
				&nbsp;&nbsp;&nbsp; abstract Speak : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; abstract Eat : unit -&gt; unit</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Using Interfaces</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Since they only define a set of public method signatures, users need to create an object to <em>implement</em> the interface. Here are three classes which implement the ILifeForm interface in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; type ILifeForm =<br>
				&nbsp;&nbsp;&nbsp; abstract Name : string<br>
				&nbsp;&nbsp;&nbsp; abstract Speak : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; abstract Eat : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp;<br>
				type Dog(name : string, age : int) =<br>
				&nbsp;&nbsp;&nbsp; member this.Age = age<br>
				<br>
				&nbsp;&nbsp;&nbsp; interface ILifeForm with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Name = name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Speak() = printfn "Woof!"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Eat() = printfn "Yum, doggy biscuits!"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				type Monkey(weight : float) =<br>
				&nbsp;&nbsp;&nbsp; let mutable _weight = weight<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Weight<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = _weight<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(value) = _weight &lt;- value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; interface ILifeForm with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Name = "Monkey!!!"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Speak() = printfn "Ook ook"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Eat() = printfn "Bananas!"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				type Ninja() =<br>
				&nbsp;&nbsp;&nbsp; interface ILifeForm with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Name = "Ninjas have no name"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Speak() = printfn "Ninjas are silent, deadly killers"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Eat() =<br>
				&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfn "Ninjas don't eat, they wail on guitars because they're totally sweet";;<br>
				<br>
				type ILifeForm =<br>
				&nbsp; interface<br>
				&nbsp;&nbsp;&nbsp; abstract member Eat : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; abstract member Speak : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; abstract member Name : string<br>
				&nbsp; end<br>
				type Dog =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; interface ILifeForm<br>
				&nbsp;&nbsp;&nbsp; new : name:string * age:int -&gt; Dog<br>
				&nbsp;&nbsp;&nbsp; member Age : int<br>
				&nbsp; end<br>
				type Monkey =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; interface ILifeForm<br>
				&nbsp;&nbsp;&nbsp; new : weight:float -&gt; Monkey<br>
				&nbsp;&nbsp;&nbsp; member Weight : float<br>
				&nbsp;&nbsp;&nbsp; member Weight : float with set<br>
				&nbsp; end<br>
				type Ninja =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; interface ILifeForm<br>
				&nbsp;&nbsp;&nbsp; new : unit -&gt; Ninja<br>
				&nbsp; end</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Typically, we call an interface an <em>abstraction</em>, and any class which implements the interface as a <em>concrete implementation</em>. In the example above,</span> <span class="Teletyped"><span lang="EN-US" style=''>ILifeForm</span></span> <span lang="EN-US">is an abstraction, whereas</span> <span class="Teletyped"><span lang="EN-US" style=''>Dog</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>Monkey</span></span><span lang="EN-US">, and</span> <span class="Teletyped"><span lang="EN-US" style=''>Ninja</span></span> <span lang="EN-US">are concrete implementations.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Its worth noting that interfaces only define instance members signatures on objects. In other words, they cannot define static member signatures or constructor signatures.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">What are interfaces used for?</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Interfaces are a mystery to newbie programmers (after all, what's the point of creating a type with no implementation?), however they are essential to many object-oriented programming techniques. Interfaces allow programmers to generalize functions to all classes which implement a particular interface, even if those classes don't necessarily descend from one another. For example, using the</span> <span class="Teletyped"><span lang="EN-US" style=''>Dog</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Monkey</span></span><span lang="EN-US">, and</span> <span class="Teletyped"><span lang="EN-US" style=''>Ninja</span></span> <span lang="EN-US">classes defined above, we can write a method to operate on all of them, as well as any other classes which implement the ILifeForm interface.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Implementing Interfaces with Object Expressions</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Interfaces are extremely useful for sharing snippets of implementation logic between other classes, however it can be very cumbersome to define and implement a new class for ad hoc interfaces. Object expressions allow users to implement interfaces on anonymous classes using the <a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec2.aspx#_Toc207785612"><span style='color:windowtext;text-decoration:none'>following syntax</span></a>:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">{ new ty0 [ args-expr ] [ as base-ident ] [ with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val-or-member-defns end ]<br>
				&nbsp;<br>
				&nbsp; interface ty1 with [<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val-or-member-defns1<br>
				&nbsp;&nbsp; end ]<br>
				&nbsp;<br>
				&nbsp; &hellip;<br>
				<br>
				&nbsp; interface tyn with [<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val-or-member-defnsn&nbsp;<br>
				&nbsp; end ] }</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Using a concrete example, the .NET BCL has a method called</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'><a href="http://msdn.microsoft.com/en-us/library/bzw8611x.aspx"><span style='color:windowtext;text-decoration:none'>System.Array.Sort&lt;T&gt;(T array, IComparer&lt;T&gt;)</span></a></span></span><span lang="EN-US">, where</span> <span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/6zzyats9.aspx"><span style='color:windowtext;text-decoration:none'>IComparer&lt;T&gt;</span></a></span></span> <span lang="EN-US">exposes a single method called</span> <span class="Teletyped"><span lang="EN-US" style=''>Compare</span></span><span lang="EN-US">. Let's say we wanted to sort an array on an ad hoc basis using this method; rather than litter our code with one-time use classes, we can use object expressions to define anonymous classes on the fly:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; open System<br>
				open System.Collections.Generic<br>
				<br>
				type person = { name : string; age : int }<br>
				<br>
				let people =<br>
				&nbsp;&nbsp;&nbsp; [| { name = "Larry"; age = 20 };<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { name = "Moe"; age = 30 };<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { name = "Curly"; age = 25 } |]<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let sortAndPrint msg items (comparer : System.Collections.Generic.IComparer&lt;person&gt;) =<br>
				&nbsp;&nbsp;&nbsp; Array.Sort(items, comparer)<br>
				&nbsp;&nbsp;&nbsp; printf "%s: " msg<br>
				&nbsp;&nbsp;&nbsp; Seq.iter (fun x -&gt; printf "(%s, %i) " x.name x.age) items<br>
				&nbsp;&nbsp;&nbsp; printfn ""<br>
				<br>
				(* sorting by age *)&nbsp;&nbsp;&nbsp;<br>
				sortAndPrint "age" people { new IComparer&lt;person&gt; with member this.Compare(x, y) = x.age.CompareTo(y.age) }<br>
				<br>
				(* sorting by name *)<br>
				sortAndPrint "name" people { new IComparer&lt;person&gt; with member this.Compare(x, y) = x.name.CompareTo(y.name) }<br>
				<br>
				(* sorting by name descending *)<br>
				sortAndPrint "name desc" people { new IComparer&lt;person&gt; with member this.Compare(x, y) = y.name.CompareTo(x.name) };;<br>
				<br>
				type person =<br>
				&nbsp; {name: string;<br>
				&nbsp;&nbsp; age: int;}<br>
				val people : person array<br>
				val sortAndPrint : string -&gt; person array -&gt; IComparer&lt;person&gt; -&gt; unit<br>
				<br>
				age: (Larry, 20) (Curly, 25) (Moe, 30)<br>
				name: (Curly, 25) (Larry, 20) (Moe, 30)<br>
				name desc: (Moe, 30) (Larry, 20) (Curly, 25)</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Implementing Multiple Interfaces</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Unlike inheritance, its possible to implement multiple interfaces:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				type Person(name : string, age : int) =<br>
				&nbsp;&nbsp;&nbsp; member this.Name = name<br>
				&nbsp;&nbsp;&nbsp; member this.Age = age<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; (* IComparable is used for ordering instances *)<br>
				&nbsp;&nbsp;&nbsp; interface IComparable&lt;Person&gt; with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.CompareTo(other) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* sorts by name, then age *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match this.Name.CompareTo(other.Name) with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0 -&gt; this.Age.CompareTo(other.Age)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | n -&gt; n<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; (* Used for comparing this type against other types *)<br>
				&nbsp;&nbsp;&nbsp; interface IEquatable&lt;string&gt; with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Equals(othername) = this.Name.Equals(othername)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Its just as easy to implement multiple interfaces in object expressions as well.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Interface Hierarchies</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Interfaces can extend other interfaces in a kind of interface hierarchy. For example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type ILifeForm =<br>
				&nbsp;&nbsp;&nbsp; abstract member location : System.Drawing.Point<br>
				<br>
				type 'a IAnimal =&nbsp;&nbsp; (* interface with generic type parameter *)<br>
				&nbsp;&nbsp;&nbsp; inherit ILifeForm<br>
				&nbsp;&nbsp;&nbsp; inherit System.IComparable&lt;'a&gt;<br>
				&nbsp;&nbsp;&nbsp; abstract member speak : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp;<br>
				type IFeline =<br>
				&nbsp;&nbsp;&nbsp; inherit IAnimal&lt;IFeline&gt;<br>
				&nbsp;&nbsp;&nbsp; abstract member purr : unit -&gt; unit</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">When users create a concrete implementation of</span> <span class="Teletyped"><span lang="EN-US" style=''>IFeline</span></span><span lang="EN-US">, they are required to provide implementations for all of the methods defined in the</span> <span class="Teletyped"><span lang="EN-US" style=''>IAnimal</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>IComparable</span></span><span lang="EN-US">, and</span> <span class="Teletyped"><span lang="EN-US" style=''>ILifeForm</span></span> <span lang="EN-US">interfaces.</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US">Note:</span></span> <span lang="EN-US">Interface hierarchies are occasionally useful, however deep, complicated hierarchies can be cumbersome to work with.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Examples</span>
			</h2>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Generalizing a function to many classes</span>
			</h3>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				type ILifeForm =<br>
				&nbsp;&nbsp;&nbsp; abstract Name : string<br>
				&nbsp;&nbsp;&nbsp; abstract Speak : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; abstract Eat : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp;<br>
				type Dog(name : string, age : int) =<br>
				&nbsp;&nbsp;&nbsp; member this.Age = age<br>
				<br>
				&nbsp;&nbsp;&nbsp; interface ILifeForm with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Name = name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Speak() = printfn "Woof!"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Eat() = printfn "Yum, doggy biscuits!"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				type Monkey(weight : float) =<br>
				&nbsp;&nbsp;&nbsp; let mutable _weight = weight<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Weight<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = _weight<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(value) = _weight &lt;- value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; interface ILifeForm with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Name = "Monkey!!!"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Speak() = printfn "Ook ook"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Eat() = printfn "Bananas!"<br>
				&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				type Ninja() =<br>
				&nbsp;&nbsp;&nbsp; interface ILifeForm with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Name = "Ninjas have no name"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Speak() = printfn "Ninjas are silent, deadly killers"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Eat() =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "Ninjas don't eat, they wail on guitars because they're totally sweet"<br>
				<br>
				let lifeforms =<br>
				&nbsp;&nbsp;&nbsp; [(new Dog("Fido", 7) :&gt; ILifeForm);<br>
				&nbsp;&nbsp;&nbsp;&nbsp; (new Monkey(500.0) :&gt; ILifeForm);<br>
				&nbsp;&nbsp;&nbsp;&nbsp; (new Ninja() :&gt; ILifeForm)]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				<br>
				let handleLifeForm (x : ILifeForm) =<br>
				&nbsp;&nbsp;&nbsp; printfn "Handling lifeform '%s'" x.Name<br>
				&nbsp;&nbsp;&nbsp; x.Speak()<br>
				&nbsp;&nbsp;&nbsp; x.Eat()<br>
				&nbsp;&nbsp;&nbsp; printfn ""<br>
				&nbsp;&nbsp;&nbsp;<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; printfn "Processing...\n"<br>
				&nbsp;&nbsp;&nbsp; lifeforms |&gt; Seq.iter handleLifeForm<br>
				&nbsp;&nbsp;&nbsp; printfn "Done."<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program has the following types:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type ILifeForm =<br>
				&nbsp; interface<br>
				&nbsp;&nbsp;&nbsp; abstract member Eat : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; abstract member Speak : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; abstract member Name : string<br>
				&nbsp; end<br>
				<br>
				type Dog =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; interface ILifeForm<br>
				&nbsp;&nbsp;&nbsp; new : name:string * age:int -&gt; Dog<br>
				&nbsp;&nbsp;&nbsp; member Age : int<br>
				&nbsp; end<br>
				<br>
				type Monkey =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; interface ILifeForm<br>
				&nbsp;&nbsp;&nbsp; new : weight:float -&gt; Monkey<br>
				&nbsp;&nbsp;&nbsp; member Weight : float<br>
				&nbsp;&nbsp;&nbsp; member Weight : float with set<br>
				&nbsp; end<br>
				<br>
				type Ninja =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; interface ILifeForm<br>
				&nbsp;&nbsp;&nbsp; new : unit -&gt; Ninja<br>
				&nbsp; end<br>
				<br>
				val lifeforms : ILifeForm list<br>
				val handleLifeForm : ILifeForm -&gt; unit<br>
				val main : unit -&gt; unit</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Processing...Handling lifeform 'Fido'Woof!Yum, doggy biscuits!Handling lifeform 'Monkey!!!'Ook ookBananas!Handling lifeform 'Ninjas have no name'Ninjas are silent, deadly killersNinjas don't eat, they wail on guitars because they're totally sweetDone.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Using interfaces in generic type definitions</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">We can constrain generic types in class and function definitions to particular interfaces. For example, let's say that we wanted to create a binary tree which satisfies the following property: each node in a binary tree has two children,</span> <span class="Teletyped"><span lang="EN-US" style=''>left</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>right</span></span><span lang="EN-US">, where all of the child nodes in</span> <span class="Teletyped"><span lang="EN-US" style=''>left</span></span> <span lang="EN-US">are less than all of its parent nodes, and all of the child nodes in</span> <span class="Teletyped"><span lang="EN-US" style=''>right</span></span> <span lang="EN-US">are greater than all of its parent nodes.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can implement a binary tree with these properties defining a binary tree which constrains our tree to the</span> <span class="Teletyped"><span lang="EN-US" style=''>IComparable&lt;T&gt;</span></span> <span lang="EN-US">interface.</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US">Note:</span></span> <span lang="EN-US">.NET has a number of interfaces defined in the BCL, including the very important</span> <span class="Teletyped"><span style=''><a href="http://msdn.microsoft.com/en-us/library/4d7sx9hd.aspx"><span lang="EN-US" style='color:windowtext;text-decoration:none'>IComparable&lt;T&gt; interface</span></a></span></span><span lang="EN-US">. IComparable exposes a single method,</span> <a href="http://msdn.microsoft.com/en-us/library/43hc6wht.aspx"><span lang="EN-US" style='color:windowtext;text-decoration:none'>objectInstance.CompareTo(otherInstance)</span></a><span lang="EN-US">, which should return 1, -1, or 0 when the</span> <span class="Teletyped"><span lang="EN-US" style=''>objectInstance</span></span> <span lang="EN-US">is greater than, less than, or equal to</span> <span class="Teletyped"><span lang="EN-US" style=''>otherInstance</span></span> <span lang="EN-US">respectively. Many classes in the .NET framework already implement IComparable, including all of the numeric data types, strings, and datetimes.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">For example, using fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; open System<br>
				<br>
				type tree&lt;'a&gt; when 'a :&gt; IComparable&lt;'a&gt; =<br>
				&nbsp;&nbsp;&nbsp; | Nil<br>
				&nbsp;&nbsp;&nbsp; | Node of 'a * 'a tree * 'a tree<br>
				<br>
				let rec insert (x : #IComparable&lt;'a&gt;) = function<br>
				&nbsp;&nbsp;&nbsp; | Nil -&gt; Node(x, Nil, Nil)<br>
				&nbsp;&nbsp;&nbsp; | Node(y, l, r) as node -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if x.CompareTo(y) = 0 then node<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif x.CompareTo(y) = -1 then Node(y, insert x l, r)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else Node(y, l, insert x r)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let rec contains (x : #IComparable&lt;'a&gt;) = function<br>
				&nbsp; &nbsp;&nbsp;| Nil -&gt; false<br>
				&nbsp;&nbsp;&nbsp; | Node(y, l, r) as node -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if x.CompareTo(y) = 0 then true<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif x.CompareTo(y) = -1 then contains x l<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else contains x r;;<br>
				<br>
				type tree&lt;'a&gt; when 'a :&gt; IComparable&lt;'a&gt;&gt; =<br>
				&nbsp; | Nil<br>
				&nbsp; | Node of 'a * tree&lt;'a&gt; * tree&lt;'a&gt;<br>
				val insert : 'a -&gt; tree&lt;'a&gt; -&gt; tree&lt;'a&gt; when 'a :&gt; IComparable&lt;'a&gt;<br>
				val contains : #IComparable&lt;'a&gt; -&gt; tree&lt;'a&gt; -&gt; bool when 'a :&gt; IComparable&lt;'a&gt;<br>
				<br>
				&gt; let x =<br>
				&nbsp;&nbsp;&nbsp; let rnd = new Random()<br>
				&nbsp;&nbsp;&nbsp; [ for a in 1 .. 10 -&gt; rnd.Next(1, 100) ]<br>
				&nbsp;&nbsp;&nbsp; |&gt; Seq.fold (fun acc x -&gt; insert x acc) Nil;;<br>
				<br>
				val x : tree&lt;int&gt;<br>
				<br>
				&gt; x;;<br>
				val it : tree&lt;int&gt;<br>
				= Node<br>
				&nbsp;&nbsp;&nbsp; (25,Node (20,Node (6,Nil,Nil),Nil),<br>
				&nbsp;&nbsp;&nbsp;&nbsp; Node<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (90,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (86,Node (65,Node (50,Node (39,Node (32,Nil,Nil),Nil),Nil),Nil),Nil),<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Nil))<br>
				<br>
				&gt; contains 39 x;;<br>
				val it : bool = true<br>
				<br>
				&gt; contains 55 x;;<br>
				val it : bool = false</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Simple dependency injection</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Dependency injection refers to the process of supplying an external dependency to a software component. For example, let's say we had a class which, in the event of an error, sends an email to the network administrator, we might write some code like this:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Processor() =<br>
				&nbsp;&nbsp;&nbsp; (* ... *)<br>
				&nbsp;&nbsp;&nbsp; member this.Process items =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* do stuff with items *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | err -&gt; (new Emailer()).SendMsg("admin@company.com", "Error! " + err.Message)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>Process</span></span><span lang="EN-US">method creates an instance of</span> <span class="Teletyped"><span lang="EN-US" style=''>Emailer</span></span><span lang="EN-US">, so we can say that the</span> <span class="Teletyped"><span lang="EN-US" style=''>Processor</span></span> <span lang="EN-US">class <em>depends</em> on the</span> <span class="Teletyped"><span lang="EN-US" style=''>Emailer</span></span><span lang="EN-US">class.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Let's say we're testing our</span> <span class="Teletyped"><span lang="EN-US" style=''>Processor</span></span> <span lang="EN-US">class, and we don't want to be sending emails to the network admin all the time. Rather than comment out the lines of code we don't want to run while we test, its much easier to substitute the</span> <span class="Teletyped"><span lang="EN-US" style=''>Emailer</span></span><span lang="EN-US">dependency with a dummy class instead. We can achieve that by passing in our dependency through the constructor:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type IFailureNotifier =<br>
				&nbsp;&nbsp;&nbsp; abstract Notify : string -&gt; unit<br>
				<br>
				type Processor(notifier : IFailureNotifier) =<br>
				&nbsp;&nbsp;&nbsp; (* ... *)<br>
				&nbsp;&nbsp;&nbsp; member this.Process items =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // do stuff with items<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | err -&gt; notifier.Notify(err.Message)<br>
				<br>
				(* concrete implementations of IFailureNotifier *)<br>
				<br>
				type EmailNotifier() =<br>
				&nbsp;&nbsp;&nbsp; interface IFailureNotifier with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member Notify(msg) = (new Emailer()).SendMsg("admin@company.com", "Error! " + msg)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				type DummyNotifier() =<br>
				&nbsp;&nbsp;&nbsp; interface IFailureNotifier with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member Notify(msg) = () // swallow message<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				type LogfileNotifier(filename : string) =<br>
				&nbsp;&nbsp;&nbsp; interface IFailureNotifer with&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member Notify(msg) = System.IO.File.AppendAllText(filename, msg)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Now, we create a processor and pass in the kind of FailureNotifier we're interested in. In test environments, we'd use</span> <span class="Teletyped"><span lang="EN-US" style=''>new Processor(new DummyNotifier())</span></span><span lang="EN-US">; in production, we'd use</span> <span class="Teletyped"><span lang="EN-US" style=''>new Processor(new EmailNotifier())</span></span> <span lang="EN-US">or</span> <span class="Teletyped"><span lang="EN-US" style=''>new Processor(new LogfileNotifier(@"C:\log.txt"))</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">To demonstrate dependency injection using a somewhat contrived example, the following code in fsi shows how to hot swap one interface implementation with another:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; #time;;<br>
				<br>
				--&gt; Timing now on<br>
				<br>
				&gt; type IAddStrategy =<br>
				&nbsp;&nbsp;&nbsp; abstract add : int -&gt; int -&gt; int<br>
				&nbsp;&nbsp;&nbsp;<br>
				type DefaultAdder() =<br>
				&nbsp;&nbsp;&nbsp; interface IAddStrategy with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.add x y = x + y<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				type SlowAdder() =<br>
				&nbsp;&nbsp;&nbsp; interface IAddStrategy with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.add x y =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec loop acc = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0 -&gt; acc<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | n -&gt; loop (acc + 1) (n - 1)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop x y<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				type OffByOneAdder() =<br>
				&nbsp;&nbsp;&nbsp; interface IAddStrategy with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.add x y = x + y - 1<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				type SwappableAdder(adder : IAddStrategy) =<br>
				&nbsp;&nbsp;&nbsp; let mutable _adder = adder<br>
				&nbsp;&nbsp;&nbsp; member this.Adder<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = _adder<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(value) = _adder &lt;- value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Add x y = this.Adder.add x y;;<br>
				<br>
				type IAddStrategy =<br>
				&nbsp; interface<br>
				&nbsp;&nbsp;&nbsp; abstract member add : int -&gt; (int -&gt; int)<br>
				&nbsp; end<br>
				type DefaultAdder =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; interface IAddStrategy<br>
				&nbsp;&nbsp;&nbsp; new : unit -&gt; DefaultAdder<br>
				&nbsp; end<br>
				type SlowAdder =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; interface IAddStrategy<br>
				&nbsp;&nbsp;&nbsp; new : unit -&gt; SlowAdder<br>
				&nbsp; end<br>
				type OffByOneAdder =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; interface IAddStrategy<br>
				&nbsp;&nbsp;&nbsp; new : unit -&gt; OffByOneAdder<br>
				&nbsp; end<br>
				type SwappableAdder =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; new : adder:IAddStrategy -&gt; SwappableAdder<br>
				&nbsp;&nbsp;&nbsp; member Add : x:int -&gt; (int -&gt; int)<br>
				&nbsp;&nbsp;&nbsp; member Adder : IAddStrategy<br>
				&nbsp;&nbsp;&nbsp; member Adder : IAddStrategy with set<br>
				&nbsp; end<br>
				<br>
				Real: 00:00:00.000, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0<br>
				<br>
				&gt; let myAdder = new SwappableAdder(new DefaultAdder());;<br>
				<br>
				val myAdder : SwappableAdder<br>
				<br>
				Real: 00:00:00.000, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0<br>
				<br>
				&gt; myAdder.Add 10 1000000000;;<br>
				Real: 00:00:00.001, CPU: 00:00:00.015, GC gen0: 0, gen1: 0, gen2: 0<br>
				val it : int = 1000000010<br>
				<br>
				&gt; myAdder.Adder &lt;- new SlowAdder();;<br>
				Real: 00:00:00.000, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0<br>
				val it : unit = ()<br>
				<br>
				&gt; myAdder.Add 10 1000000000;;<br>
				Real: 00:00:01.085, CPU: 00:00:01.078, GC gen0: 0, gen1: 0, gen2: 0<br>
				val it : int = 1000000010<br>
				<br>
				&gt; myAdder.Adder &lt;- new OffByOneAdder();;<br>
				Real: 00:00:00.000, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0<br>
				val it : unit = ()<br>
				<br>
				&gt; myAdder.Add 10 1000000000;;<br>
				Real: 00:00:00.000, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0<br>
				val it : int = 1000000009</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Events
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Events</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Events</span></span> <span lang="EN-US">allow objects to communicate with one another through a kind of synchronous message passing. Events are simply hooks to other functions: objects register callback functions to an event, and these callbacks will be executed when (and if) the event is triggered by some object.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">For example, let's say we have a clickable button which exposed an event called</span> <span class="Teletyped"><span lang="EN-US" style=''>Click</span></span><span lang="EN-US">. We can register a block of code, something like</span> <span class="Teletyped"><span lang="EN-US" style=''>fun () -&gt; printfn "I've been clicked!"</span></span><span lang="EN-US">, to the button's click event. When the click event is triggered, it will execute the block of code we've registered. If we wanted to, we could register an indefinite number of callback functions to the click event -- the button doesn't care what code is trigged by the callbacks or how many callback functions are registered to its click event, it blindly executes whatever functions are hooked to its click event.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Event-driven programming is natural in GUI code, as GUIs tend to consist of controls which react and respond to user input. Events are, of course, useful in non-GUI applications as well. For example, if we have an object with mutable properties, we may want to notify another object when those properties change.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Defining Events</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Events are created and used though F#'s <a href="http://msdn.microsoft.com/en-us/library/ee370608(VS.100).aspx"><span style='color:windowtext;text-decoration:none'>Event class</span></a>. To create an event, use the</span> <span class="Teletyped"><span lang="EN-US" style=''>Event</span></span> <span lang="EN-US">constructor as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Person(name : string) =<br>
				&nbsp;&nbsp;&nbsp; let mutable _name = name;<br>
				&nbsp;&nbsp;&nbsp; let nameChanged = new Event&lt;string&gt;()<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = _name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(value) = _name &lt;- value</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">To allow listeners to hook onto our event, we need to expose the</span> <span class="Teletyped"><span lang="EN-US" style=''>nameChanged</span></span> <span lang="EN-US">field as a public member using the event's</span> <span class="Teletyped"><span lang="EN-US" style=''>Publish</span></span> <span lang="EN-US">property:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Person(name : string) =<br>
				&nbsp;&nbsp;&nbsp; let mutable _name = name;<br>
				&nbsp;&nbsp;&nbsp; let nameChanged = new Event&lt;unit&gt;() (* creates event *)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.NameChanged = nameChanged.Publish (* exposed event handler *)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;with get() = _name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(value) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _name &lt;- value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nameChanged.Trigger() (* invokes event handler *)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Now, any object can listen to the changes on the person method. By convention and <a href="http://msdn.microsoft.com/en-us/library/ms229012.aspx"><span style='color:windowtext;text-decoration:none'>Microsoft's recommendation</span></a>, events are usually named <em>Verb</em> or <em>VerbPhrase</em>, as well as adding tenses like <em>Verbed</em> and <em>Verbing</em> to indicate pre- and post-events.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Adding Callbacks to Event Handlers</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Its very easy to add callbacks to event handlers. Each event handler has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>IEvent&lt;'T&gt;</span></span> <span lang="EN-US">which exposes several methods:</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val Add : event:('T -&gt; unit) -&gt; unit</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Connect a listener function to the event. The listener will be invoked when the event is fired.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val AddHandler : 'del -&gt; unit</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Connect a handler delegate object to the event. A handler can be later removed using RemoveHandler. The listener will be invoked when the event is fired.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val RemoveHandler : 'del -&gt; unit</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Remove a listener delegate from an event listener store.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here's an example program:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Person(name : string) =<br>
				&nbsp;&nbsp;&nbsp; let mutable _name = name;<br>
				&nbsp;&nbsp;&nbsp; let nameChanged = new Event&lt;unit&gt;() (* creates event *)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.NameChanged = nameChanged.Publish (* exposed event handler *)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;with get() = _name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(value) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _name &lt;- value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nameChanged.Trigger() (* invokes event handler *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let p = new Person("Bob")<br>
				p.NameChanged.Add(fun () -&gt; printfn "-- Name changed! New name: %s" p.Name)<br>
				<br>
				printfn "Event handling is easy"<br>
				p.Name &lt;- "Joe"<br>
				<br>
				printfn "It handily decouples objects from one another"<br>
				p.Name &lt;- "Moe"<br>
				<br>
				p.NameChanged.Add(fun () -&gt; printfn "-- Another handler attached to NameChanged!")<br>
				<br>
				printfn "It's also causes programs behave non-deterministically."<br>
				p.Name &lt;- "Bo"<br>
				<br>
				printfn "The function NameChanged is invoked effortlessly."</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Event handling is easy-- Name changed! New name: JoeIt handily decouples objects from one another-- Name changed! New name: MoeIt's also causes programs behave non-deterministically.-- Name changed! New name: Bo-- Another handler attached to NameChanged!The function NameChanged is invoked effortlessly.</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US">Note:</span></span> <span lang="EN-US">When multiple callbacks are connected to a single event, they are executed in the order they are added. However, in practice, you should <span class="Bold">not</span> write code with the expectation that events will trigger in a particular order, as doing so can introduce complex dependencies between functions. Event-driven programming is often non-deterministic and fundamentally stateful, which can occasionally be at odds with the spirit of functional programming. Its best to write callback functions which do not modify state, and do not depend on the invocation of any prior events.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Working with EventHandlers Explicitly</span>
			</h2>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Adding and Removing Event Handlers</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">The code above demonstrates how to use the</span> <span class="Teletyped"><span lang="EN-US" style=''>IEvent&lt;'T&gt;.add</span></span> <span lang="EN-US">method. However, occasionally we need to remove callbacks. To do so, we need to work with the</span> <span class="Teletyped"><span lang="EN-US" style=''>IEvent&lt;'T&gt;.AddHandler</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>IEvent&lt;'T&gt;.RemoveHandler</span></span> <span lang="EN-US">methods, as well as .NET's built-in <a href="http://msdn.microsoft.com/en-us/library/system.delegate.aspx"><span style='color:windowtext;text-decoration:none'>System.Delegate</span></a> type.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The function</span> <span class="Teletyped"><span lang="EN-US" style=''>person.NameChanged.AddHandler</span></span> <span lang="EN-US">has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>val AddHandler : Handler&lt;'T&gt; -&gt; unit</span></span><span lang="EN-US">, where</span> <span class="Teletyped"><span lang="EN-US" style=''>Handler&lt;'T&gt;</span></span><span lang="EN-US">inherits from</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>System.Delegate</span></span><span lang="EN-US">. We can create an instance of</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Handler</span></span> <span lang="EN-US">as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Person(name : string) =<br>
				&nbsp;&nbsp;&nbsp; let mutable _name = name;<br>
				&nbsp;&nbsp;&nbsp; let nameChanged = new Event&lt;unit&gt;() (* creates event *)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.NameChanged = nameChanged.Publish (* exposed event handler *)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = _name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(value) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _name &lt;- value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nameChanged.Trigger() (* invokes event handler *)<br>
				<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let p = new Person("Bob")<br>
				<br>
				let person_NameChanged =<br>
				&nbsp;&nbsp;&nbsp; new Handler&lt;unit&gt;(fun sender eventargs -&gt; printfn "-- Name changed! New name: %s" p.Name)<br>
				<br>
				p.NameChanged.AddHandler(person_NameChanged)<br>
				<br>
				printfn "Event handling is easy"<br>
				p.Name &lt;- "Joe"<br>
				<br>
				printfn "It handily decouples objects from one another"<br>
				p.Name &lt;- "Moe"<br>
				<br>
				p.NameChanged.RemoveHandler(person_NameChanged)<br>
				p.NameChanged.Add(fun () -&gt; printfn "-- Another handler attached to NameChanged!")<br>
				<br>
				printfn "It's also causes programs behave non-deterministically."<br>
				p.Name &lt;- "Bo"<br>
				<br>
				printfn "The function NameChanged is invoked effortlessly."</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Event handling is easy-- Name changed! New name: JoeIt handily decouples objects from one another-- Name changed! New name: MoeIt's also causes programs behave non-deterministically.-- Another handler attached to NameChanged!The function NameChanged is invoked effortlessly.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Defining New Delegate Types</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">F#'s event handling model is a little different from the rest of .NET. If we want to expose F# events to different languages like C# or VB.NET, we can define a custom delegate type which compiles to a .NET delegate using the</span> <span class="Teletyped"><span lang="EN-US" style=''>delegate</span></span><span lang="EN-US">keyword, for example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type NameChangingEventArgs(oldName : string, newName : string) =<br>
				&nbsp;&nbsp;&nbsp; inherit System.EventArgs()<br>
				<br>
				&nbsp;&nbsp;&nbsp; member this.OldName = oldName<br>
				&nbsp;&nbsp;&nbsp; member this.NewName = newName<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				type NameChangingDelegate = delegate of obj * NameChangingEventArgs -&gt; unit</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The convention</span> <span class="Teletyped"><span lang="EN-US" style=''>obj * NameChangingEventArgs</span></span> <span lang="EN-US">corresponds to the .NET naming guidelines which recommend that all events have the type</span> <span class="Teletyped"><span lang="EN-US" style=''>val eventName : (sender : obj * e : #EventArgs) -&gt; unit</span></span><span lang="EN-US">.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Passing State To Callbacks</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Events can pass state to callbacks with minimal effort. Here is a simple program which reads a file in blocks of characters:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open System<br>
				<br>
				type SuperFileReader() =<br>
				&nbsp;&nbsp;&nbsp; let progressChanged = new Event&lt;int&gt;()<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.ProgressChanged = progressChanged.Publish<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.OpenFile (filename : string, charsPerBlock) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use sr = new System.IO.StreamReader(filename)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let streamLength = int64 sr.BaseStream.Length<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let sb = new System.Text.StringBuilder(int streamLength)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let charBuffer = Array.zeroCreate&lt;char&gt; charsPerBlock<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let mutable oldProgress = 0<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let mutable totalCharsRead = 0<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progressChanged.Trigger(0)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while not sr.EndOfStream do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* sr.ReadBlock returns number of characters read from stream *)<br>
				&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let charsRead = sr.ReadBlock(charBuffer, 0, charBuffer.Length)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; totalCharsRead &lt;- totalCharsRead + charsRead<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* appending chars read from buffer *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sb.Append(charBuffer, 0, charsRead) |&gt; ignore<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let newProgress = int(decimal totalCharsRead / decimal streamLength * 100m)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if newProgress &gt; oldProgress then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progressChanged.Trigger(newProgress) // passes newProgress as state to callbacks<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldProgress &lt;- newProgress<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sb.ToString()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let fileReader = new SuperFileReader()<br>
				fileReader.ProgressChanged.Add(fun percent -&gt;<br>
				&nbsp;&nbsp;&nbsp; printfn "%i percent done..." percent)<br>
				&nbsp;&nbsp;&nbsp;<br>
				let x = fileReader.OpenFile(@"C:\Test.txt", 50)<br>
				printfn "%s[...]" x.[0 .. if x.Length &lt;= 100 then x.Length - 1 else 100]</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program has the following types:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type SuperFileReader =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; new : unit -&gt; SuperFileReader<br>
				&nbsp;&nbsp;&nbsp; member OpenFile : filename:string * charsToRead:int -&gt; string<br>
				&nbsp;&nbsp;&nbsp; member ProgressChanged : IEvent&lt;int&gt;<br>
				&nbsp; end<br>
				val fileReader : SuperFileReader<br>
				val x : string</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Since our event has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>IEvent&lt;int&gt;</span></span><span lang="EN-US">, we can pass</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">data as state to listening callbacks. This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">0 percent done...4 percent done...9 percent done...14 percent done...19 percent done...24 percent done...29 percent done...34 percent done...39 percent done...44 percent done...49 percent done...53 percent done...58 percent done...63 percent done...68 percent done...73 percent done...78 percent done...83 percent done...88 percent done...93 percent done...98 percent done...100 percent done...In computer programming, event-driven programming or event-based programming is a programming paradig[...]</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Retrieving State from Callers</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">A common idiom in event-driven programming is pre- and post-event handling, as well as the ability to cancel events. Cancellation requires two-way communication between an event handler and a listener, which we can easily accomplish through the use of <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Mutable_Data%23Ref_cells"><span style='color:windowtext;text-decoration:none'>ref cells</span></a> or mutable members:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Person(name : string) =<br>
				&nbsp;&nbsp;&nbsp; let mutable _name = name;<br>
				&nbsp;&nbsp;&nbsp; let nameChanging = new Event&lt;string * bool ref&gt;()<br>
				&nbsp;&nbsp;&nbsp; let nameChanged = new Event&lt;unit&gt;()<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.NameChanging = nameChanging.Publish<br>
				&nbsp;&nbsp;&nbsp; member this.NameChanged = nameChanged.Publish<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = _name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(value) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let cancelChange = ref false<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nameChanging.Trigger(value, cancelChange)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not !cancelChange then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _name &lt;- value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nameChanged.Trigger()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let p = new Person("Bob")<br>
				<br>
				p.NameChanging.Add(fun (name, cancel) -&gt;<br>
				&nbsp;&nbsp;&nbsp; let exboyfriends = ["Steve"; "Mike"; "Jon"; "Seth"]<br>
				&nbsp;&nbsp;&nbsp; if List.exists (fun forbiddenName -&gt; forbiddenName = name) exboyfriends then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "-- No %s's allowed!" name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cancel := true<br>
				&nbsp;&nbsp;&nbsp; else<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "-- Name allowed")<br>
				&nbsp;&nbsp;&nbsp;<br>
				p.NameChanged.Add(fun () -&gt;<br>
				&nbsp; &nbsp;&nbsp;printfn "-- Name changed to %s" p.Name)<br>
				&nbsp;&nbsp;&nbsp;<br>
				let tryChangeName newName =<br>
				&nbsp;&nbsp;&nbsp; printfn "Attempting to change name to '%s'" newName<br>
				&nbsp;&nbsp;&nbsp; p.Name &lt;- newName<br>
				<br>
				tryChangeName "Joe"<br>
				tryChangeName "Moe"<br>
				tryChangeName "Jon"<br>
				tryChangeName "Thor"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program has the following types:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type Person =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; new : name:string -&gt; Person<br>
				&nbsp;&nbsp;&nbsp; member Name : string<br>
				&nbsp;&nbsp;&nbsp; member NameChanged : IEvent&lt;unit&gt;<br>
				&nbsp;&nbsp;&nbsp; member NameChanging : IEvent&lt;string * bool ref&gt;<br>
				&nbsp;&nbsp;&nbsp; member Name : string with set<br>
				&nbsp; end<br>
				val p : Person<br>
				val tryChangeName : string -&gt; unit</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">Attempting to change name to 'Joe'-- Name allowed-- Name changed to JoeAttempting to change name to 'Moe'-- Name allowed-- Name changed to MoeAttempting to change name to 'Jon'-- No Jon's allowed!Attempting to change name to 'Thor'-- Name allowed-- Name changed to Thor</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">If we need to pass a significant amount of state to listeners, then its recommended to wrap the state in an object as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type NameChangingEventArgs(newName : string) =<br>
				&nbsp;&nbsp;&nbsp; inherit System.EventArgs()<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let mutable cancel = false<br>
				&nbsp;&nbsp;&nbsp; member this.NewName = newName<br>
				&nbsp;&nbsp;&nbsp; member this.Cancel<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = cancel<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(value) = cancel &lt;- value<br>
				<br>
				type Person(name : string) =<br>
				&nbsp;&nbsp;&nbsp; let mutable _name = name;<br>
				&nbsp;&nbsp;&nbsp; let nameChanging = new Event&lt;NameChangingEventArgs&gt;()<br>
				&nbsp;&nbsp;&nbsp; let nameChanged = new Event&lt;unit&gt;()<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.NameChanging = nameChanging.Publish<br>
				&nbsp;&nbsp;&nbsp; member this.NameChanged = nameChanged.Publish<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = _name<br>
				&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;and set(value) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let eventArgs = new NameChangingEventArgs(value)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nameChanging.Trigger(eventArgs)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not eventArgs.Cancel then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _name &lt;- value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nameChanged.Trigger()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let p = new Person("Bob")<br>
				<br>
				p.NameChanging.Add(fun e -&gt;<br>
				&nbsp;&nbsp;&nbsp; let exboyfriends = ["Steve"; "Mike"; "Jon"; "Seth"]<br>
				&nbsp;&nbsp;&nbsp; if List.exists (fun forbiddenName -&gt; forbiddenName = e.NewName) exboyfriends then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "-- No %s's allowed!" e.NewName<br>
				&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.Cancel &lt;- true<br>
				&nbsp;&nbsp;&nbsp; else<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "-- Name allowed")<br>
				<br>
				(* ... rest of program ... *)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">By convention, custom event parameters should inherit from</span> <span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/system.eventargs.aspx"><span style='color:windowtext;text-decoration:none'>System.EventArgs</span></a></span></span><span lang="EN-US">, and should have the suffix</span> <span class="Teletyped"><span lang="EN-US" style=''>EventArgs</span></span><span lang="EN-US">.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Using the Event Module</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">F# allows users to pass event handlers around as first-class values in fundamentally the same way as all other functions. The <a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/FSharp.Core/Microsoft.FSharp.Control.Event.html"><span style='color:windowtext;text-decoration:none'>Event module</span></a> has a variety of functions for working with event handlers:</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val choose : ('T -&gt; 'U option) -&gt; IEvent&lt;'del,'T&gt; -&gt; IEvent&lt;'U&gt; (requires delegate and 'del :&gt; Delegate)</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return a new event which fires on a selection of messages from the original event. The selection function takes an original message to an optional new message.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val filter : ('T -&gt; bool) -&gt; IEvent&lt;'del,'T&gt; -&gt; IEvent&lt;'T&gt; (requires delegate and 'del :&gt; Delegate)</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return a new event that listens to the original event and triggers the resulting event only when the argument to the event passes the given function.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val listen : ('T -&gt; unit) -&gt; IEvent&lt;'del,'T&gt; -&gt; unit (requires delegate and 'del :&gt; Delegate)</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Run the given function each time the given event is triggered.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val map : ('T -&gt; 'U) -&gt; IEvent&lt;'del,'T&gt; -&gt; IEvent&lt;'U&gt; (requires delegate and 'del :&gt; Delegate)</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return a new event which fires on a selection of messages from the original event. The selection function takes an original message to an optional new message.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val merge : IEvent&lt;'del1,'T&gt; -&gt; IEvent&lt;'del2,'T&gt; -&gt; IEvent&lt;'T&gt; (requires delegate and 'del1 :&gt; Delegate and delegate and 'del2 :&gt; Delegate)</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Fire the output event when either of the input events fire.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val pairwise : IEvent&lt;'del,'T&gt; -&gt; IEvent&lt;'T * 'T&gt; (requires delegate and 'del :&gt; Delegate)</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return a new event that triggers on the second and subsequent triggerings of the input event. The Nth triggering of the input event passes the arguments from the N-1th and Nth triggering as a pair. The argument passed to the N-1th triggering is held in hidden internal state until the Nth triggering occurs. You should ensure that the contents of the values being sent down the event are not mutable. Note that many EventArgs types are mutable, e.g. MouseEventArgs, and each firing of an event using this argument type may reuse the same physical argument obejct with different values. In this case you should extract the necessary information from the argument before using this combinator.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val partition : ('T -&gt; bool) -&gt; IEvent&lt;'del,'T&gt; -&gt; IEvent&lt;'T&gt; * IEvent&lt;'T&gt; (requires delegate and 'del :&gt; Delegate</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return a new event that listens to the original event and triggers the first resulting event if the application of the predicate to the event arguments returned true, and the second event if it returned false.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val scan : ('U -&gt; 'T -&gt; 'U) -&gt; 'U -&gt; IEvent&lt;'del,'T&gt; -&gt; IEvent&lt;'U&gt; (requires delegate and 'del :&gt; Delegate)</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return a new event consisting of the results of applying the given accumulating function to successive values triggered on the input event. An item of internal state records the current value of the state parameter. The internal state is not locked during the execution of the accumulation function, so care should be taken that the input IEvent not triggered by multiple threads simultaneously.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>val split : ('T -&gt; Choice&lt;'U1,'U2&gt;) -&gt; IEvent&lt;'del,'T&gt; -&gt; IEvent&lt;'U1&gt; * IEvent&lt;'U2&gt; (requires delegate and 'del :&gt; Delegate)</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Return a new event that listens to the original event and triggers the first resulting event if the application of the function to the event arguments returned a Choice2Of1, and the second event if it returns a Choice2Of2.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Take the following snippet:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">p.NameChanging.Add(fun (e : NameChangingEventArgs) -&gt;<br>
				&nbsp;&nbsp;&nbsp; let exboyfriends = ["Steve"; "Mike"; "Jon"; "Seth"]<br>
				&nbsp;&nbsp;&nbsp; if List.exists (fun forbiddenName -&gt; forbiddenName = e.NewName) exboyfriends then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "-- No %s's allowed!" e.NewName<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.Cancel &lt;- true)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can rewrite this in a more functional style as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">p.NameChanging<br>
				&nbsp;&nbsp;&nbsp; |&gt; Event.filter (fun (e : NameChangingEventArgs) -&gt;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let exboyfriends = ["Steve"; "Mike"; "Jon"; "Seth"]<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List.exists (fun forbiddenName -&gt;forbiddenName = e.NewName) exboyfriends )<br>
				&nbsp;&nbsp;&nbsp; |&gt; Event.listen (fun e -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "-- No %s's allowed!" e.NewName<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.Cancel &lt;- true)</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Modules and Namespaces
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Modules and Namespaces</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Modules and Namespaces</span></span> <span lang="EN-US">are primarily used for grouping and organizing code.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Defining Modules</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">No code is required to define a module. If a codefile does not contain a leading</span> <span class="Teletyped"><span lang="EN-US" style=''>namespace</span></span> <span lang="EN-US">or</span> <span class="Teletyped"><span lang="EN-US" style=''>module</span></span> <span lang="EN-US">declaration, F# code will implicitly place the code in a module, where the name of the module is the same as the file name with the first letter capitalized.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">To access code in another module, simply use</span> <span class="Teletyped"><span lang="EN-US" style=''>.</span></span> <span lang="EN-US">notation:</span> <span class="Teletyped"><span lang="EN-US" style=''>moduleName.member</span></span><span lang="EN-US">. Notice that this notation is similar to the syntax used to access <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Classes%23Instance_and_Static_Members"><span style='color:windowtext;text-decoration:none'>static members</span></a> -- this is not a coincidence. F# modules are compiled as classes which only contain static members, values, and type definitions.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Let's create two files:</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">DataStructures.fs</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type 'a Stack =<br>
				&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;&nbsp;&nbsp; | StackNode of 'a * 'a Stack<br>
				<br>
				let rec getRange startNum endNum =<br>
				&nbsp;&nbsp;&nbsp; if startNum &gt; endNum then EmptyStack<br>
				&nbsp;&nbsp;&nbsp; else StackNode(startNum, getRange (startNum+1) endNum)</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Program.fs</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">let x =<br>
				&nbsp;&nbsp;&nbsp; DataStructures.StackNode(1,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataStructures.StackNode(2,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataStructures.StackNode(3, DataStructures.EmptyStack)))<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let y = DataStructures.getRange 5 10<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				printfn "%A" x<br>
				printfn "%A" y</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">StackNode (1,StackNode (2,StackNode (3,EmptyStack)))StackNode&nbsp; (5,&nbsp;&nbsp; StackNode&nbsp;&nbsp;&nbsp;&nbsp; (6,StackNode (7,StackNode (8,StackNode (9,StackNode (10,EmptyStack))))))</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US">Note:</span></span> <span lang="EN-US">Remember, order of compilation matters in F#. Dependencies must come before dependents, so</span> <span class="Teletyped"><span lang="EN-US" style=''>DataStructures.fs</span></span> <span lang="EN-US">comes before</span> <span class="Teletyped"><span lang="EN-US" style=''>Program.fs</span></span> <span lang="EN-US">when compiling this program.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Like all modules, we can use the</span> <span class="Teletyped"><span lang="EN-US" style=''>open</span></span> <span lang="EN-US">keyword to give us access to the methods inside a module without fully qualifying the naming of the method. This allows us to revise</span> <span class="Teletyped"><span lang="EN-US" style=''>Program.fs</span></span> <span lang="EN-US">as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open DataStructures<br>
				<br>
				let x = StackNode(1, StackNode(2, StackNode(3, EmptyStack)))<br>
				let y = getRange 5 10<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				printfn "%A" x<br>
				printfn "%A" y</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Submodules</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Its very easy to create submodules using the</span> <span class="Teletyped"><span lang="EN-US" style=''>module</span></span> <span lang="EN-US">keyword:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">(* DataStructures.fs *)<br>
				<br>
				type 'a Stack =<br>
				&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;&nbsp;&nbsp; | StackNode of 'a * 'a Stack<br>
				<br>
				module StackOps =<br>
				&nbsp;&nbsp;&nbsp; let rec getRange startNum endNum =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if startNum &gt; endNum then EmptyStack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else StackNode(startNum, getRange (startNum+1) endNum)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Since the</span> <span class="Teletyped"><span lang="EN-US" style=''>getRange</span></span><span lang="EN-US">method is under another module, the fully qualified name of this method is</span> <span class="Teletyped"><span lang="EN-US" style=''>DataStructures.StackOps.getRange</span></span><span lang="EN-US">. We can use it as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">(* Program.fs *)<br>
				<br>
				open DataStructures<br>
				<br>
				let x =<br>
				&nbsp;&nbsp;&nbsp; StackNode(1, StackNode(2, StackNode(3, EmptyStack)))<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let y = StackOps.getRange 5 10<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				printfn "%A" x<br>
				printfn "%A" y</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">F# allows us to create a module and a type having the same name, for example the following code is perfectly acceptable:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type 'a Stack =<br>
				&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;&nbsp;&nbsp; | StackNode of 'a * 'a Stack<br>
				<br>
				module Stack =<br>
				&nbsp;&nbsp;&nbsp; let rec getRange startNum endNum =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if startNum &gt; endNum then EmptyStack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else StackNode(startNum, getRange (startNum+1) endNum)</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				<span lang="EN-US">&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Bold"><span lang="EN-US">Note:</span></span> <span lang="EN-US">Its possible to nest submodules inside other submodules. However, as a general principle, its best to avoid creating complex module hierarchies. Functional programming libraries tend to be very "flat" with nearly all functionality accessible in the first 2 or 3 levels of a hierarchy. This is in contrast to many other OO languages which encourage programmers to create deeply nested class libraries, where functionality might be buried 8 or 10 levels down the hierarchy.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Extending Types and Modules</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">F# supports extension methods, which allow programmers to add new static and instance methods to classes and modules without inheriting from them.</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Extending a Module</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Sequences%23The_Seq_Module"><span class="Teletyped"><span style='color:windowtext;text-decoration: none'>Seq</span></span><span style='color:windowtext;text-decoration:none'>module</span></a> contains several pairs of methods:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Teletyped"><span lang="EN-US" style=''>iter</span></span><span lang="EN-US">/</span><span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>iteri</span></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Teletyped"><span lang="EN-US" style=''>map</span></span><span lang="EN-US">/</span><span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>mapi</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>Seq</span></span> <span lang="EN-US">has a</span> <span class="Teletyped"><span lang="EN-US" style=''>forall</span></span> <span lang="EN-US">member, but does not have a corresponding</span> <span class="Teletyped"><span lang="EN-US" style=''>foralli</span></span> <span lang="EN-US">function. We add this missing method to the module simply by creating another module with the same name. For example, using fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; module Seq =<br>
				&nbsp;&nbsp;&nbsp; let foralli f s =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Seq.mapi (fun i x -&gt; i, x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* pair item with its index *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Seq.forall (fun (i, x) -&gt; f i x) (* apply item and index to function *)<br>
				<br>
				<br>
				let isPalindrome (input : string) =<br>
				&nbsp;&nbsp;&nbsp; input<br>
				&nbsp;&nbsp;&nbsp; |&gt; Seq.take (input.Length / 2)<br>
				&nbsp;&nbsp;&nbsp; |&gt; Seq.foralli (fun i x -&gt; x = input.[input.Length - i - 1]);;<br>
				<br>
				module Seq = begin<br>
				&nbsp; val foralli : (int -&gt; 'a -&gt; bool) -&gt; seq&lt;'a&gt; -&gt; bool<br>
				end<br>
				val isPalindrome : string -&gt; bool<br>
				<br>
				&gt; isPalindrome "hello";;<br>
				val it : bool = false<br>
				&gt; isPalindrome "racecar";;<br>
				val it : bool = true</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Extending a Type</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/system.string.aspx"><span style='color:windowtext;text-decoration:none'>System.String</span></a></span></span> <span lang="EN-US">has many useful methods, but let's say we thought it was missing a few important functions,</span> <span class="Teletyped"><span lang="EN-US" style=''>Reverse</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>IsPalindrome</span></span><span lang="EN-US">. Since this class is marked as</span> <span class="Teletyped"><span lang="EN-US" style=''>sealed</span></span> <span lang="EN-US">or</span> <span class="Teletyped"><span lang="EN-US" style=''>NotInheritable</span></span><span lang="EN-US">, we can't create a derived version of this class. Instead, we create a module with the new methods we want. Here's an example in fsi which demonstrates how to add new static and instance methods to the</span> <span class="Teletyped"><span lang="EN-US" style=''>String</span></span> <span lang="EN-US">class:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">&gt; module Seq =<br>
				&nbsp;&nbsp;&nbsp; let foralli f s =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Seq.mapi (fun i x -&gt; i, x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* pair item with its index *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Seq.forall (fun (i, x) -&gt; f i x) (* apply item and index to function *)<br>
				<br>
				module StringExtensions =<br>
				&nbsp;&nbsp;&nbsp; type System.String with&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.IsPalindrome =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Seq.take (this.Length / 2)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Seq.foralli (fun i x -&gt; this.[this.Length - i - 1] = x)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static member Reverse(s : string) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let chars : char array =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let temp = Array.zeroCreate s.Length<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let charsToTake = if temp.Length % 2 &lt;&gt; 0 then (temp.Length + 1) / 2 else temp.Length / 2<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Seq.take charsToTake<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Seq.iteri (fun i x -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp.[i] &lt;- s.[temp.Length - i - 1]<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp.[temp.Length - i - 1] &lt;- x)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new System.String(chars)<br>
				<br>
				open StringExtensions;;<br>
				<br>
				module Seq = begin<br>
				&nbsp; val foralli : (int -&gt; 'a -&gt; bool) -&gt; seq&lt;'a&gt; -&gt; bool<br>
				end<br>
				module StringExtensions = begin<br>
				end<br>
				<br>
				&gt; "hello world".IsPalindrome;;<br>
				val it : bool = false<br>
				&gt; System.String.Reverse("hello world");;<br>
				val it : System.String = "dlrow olleh"</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Module Signatures</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">By default, all functions in a module are accessible from anywhere in our application. However, modules often contain helper functions, or functions which should not be accessible from outside the module. We can expose only a set of module members by creating a signature file.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Signature files have the same name as a module, but end with a ".fsi" extension. Signature files always come before implementation files which end with a ".fs" extension. For example:</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">DataStructures.fsi</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type 'a stack =<br>
				&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;&nbsp;&nbsp; | StackNode of 'a * 'a stack<br>
				&nbsp;&nbsp;&nbsp;<br>
				module Stack =<br>
				&nbsp;&nbsp;&nbsp; val getRange : int -&gt; int -&gt; int stack<br>
				&nbsp;&nbsp;&nbsp; val hd : 'a stack -&gt; 'a<br>
				&nbsp;&nbsp;&nbsp; val tl : 'a stack -&gt; 'a stack<br>
				&nbsp;&nbsp;&nbsp; val fold : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b stack -&gt; 'a<br>
				&nbsp;&nbsp;&nbsp; val reduce : ('a -&gt; 'a -&gt; 'a) -&gt; 'a stack -&gt; 'a</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">DataStructures.fs</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">type 'a stack =<br>
				&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;&nbsp;&nbsp; | StackNode of 'a * 'a stack<br>
				<br>
				module Stack =<br>
				&nbsp;&nbsp;&nbsp; (* helper functions *)<br>
				&nbsp;&nbsp;&nbsp; let internal_head_tail = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; failwith "Empty stack"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tail) -&gt; hd, tail<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let rec internal_fold_left f acc = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; acc<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tail) -&gt; internal_fold_left f (f acc hd) tail<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; (* public functions *)<br>
				&nbsp;&nbsp;&nbsp; let rec getRange startNum endNum =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if startNum &gt; endNum then EmptyStack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else StackNode(startNum, getRange (startNum+1) endNum)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let hd s = internal_head_tail s |&gt; fst<br>
				&nbsp;&nbsp;&nbsp; let tl s = internal_head_tail s |&gt; snd<br>
				&nbsp;&nbsp;&nbsp; let fold f seed stack = internal_fold_left f seed stack<br>
				&nbsp;&nbsp;&nbsp; let reduce f stack = internal_fold_left f (hd stack) (tl stack)</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Program.fs</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open DataStructures<br>
				<br>
				let x = Stack.getRange 1 10<br>
				printfn "%A" (Stack.hd x)<br>
				printfn "%A" (Stack.tl x)<br>
				printfn "%A" (Stack.fold ( * ) 1 x)<br>
				printfn "%A" (Stack.reduce ( + ) x)<br>
				(* printfn "%A" (Stack.internal_head_tail x) *) (* will not compile *)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Since</span> <span class="Teletyped"><span lang="EN-US" style=''>Stack.internal_head_tail</span></span> <span lang="EN-US">is not defined in our interface file, the method is marked</span> <span class="Teletyped"><span lang="EN-US" style=''>private</span></span> <span lang="EN-US">and no longer accessible outside of the</span> <span class="Teletyped"><span lang="EN-US" style=''>DataStructures</span></span> <span lang="EN-US">module.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Module signatures are useful to building a code library's skeleton, however they have a few caveats. If you want to expose a class, record, or union in a module through a signature, then the signature file must expose <em>all</em> of the objects members, records fields, and union's cases. Additionally, function signatures in modules and signatures must match <em>exactly</em>. Unlike OCaml, F# does not allow a function in a module with the type</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>'a -&gt; 'a -&gt; 'a</span></span> <span lang="EN-US">to be restricted to</span> <span class="Teletyped"><span lang="EN-US" style=''>int -&gt; int -&gt; int</span></span> <span lang="EN-US">in the signature file.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Defining Namespaces</span>
			</h2>
			<p class="TextBody">
				<span lang="EN-US">A namespace is a hierarchial catergorization of modules, classes, and other namespaces. For example, the</span> <span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/system.collections.aspx"><span style='color:windowtext;text-decoration:none'>System.Collections</span></a></span></span> <span lang="EN-US">namespace groups together all of the collections and data structures in the .NET BCL, whereas the</span> <span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/system.security.cryptography.aspx"><span style='color:windowtext;text-decoration:none'>System.Security.Cryptography</span></a></span></span> <span lang="EN-US">namespace groups together all classes which provide cryptographic services.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Namespaces are primarily used to avoid name conflicts. For example, let's say we were writing an application incorporated code from several different vendors. If Vendor A and Vendor B both have a class called</span> <span class="Teletyped"><span lang="EN-US" style=''>Collections.Stack</span></span><span lang="EN-US">, and we wrote the code</span> <span class="Teletyped"><span lang="EN-US" style=''>let s = new Stack()</span></span><span lang="EN-US">, how would the compiler know whether which stack we intended to create? Namespaces can eliminate this ambiguity by adding one more layer of grouping to our code.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Code is grouped under a namespace using the</span> <span class="Teletyped"><span lang="EN-US" style=''>namespace</span></span> <span lang="EN-US">keyword:</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">DataStructures.fsi</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">namespace Princess.Collections<br>
				&nbsp;&nbsp;&nbsp; type 'a stack =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode of 'a * 'a stack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; module Stack =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val getRange : int -&gt; int -&gt; int stack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val hd : 'a stack -&gt; 'a<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val tl : 'a stack -&gt; 'a stack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val fold : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b stack -&gt; 'a<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val reduce : ('a -&gt; 'a -&gt; 'a) -&gt; 'a stack -&gt; 'a</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">DataStructures.fs</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">namespace Princess.Collections<br>
				<br>
				&nbsp;&nbsp;&nbsp; type 'a stack =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode of 'a * 'a stack<br>
				<br>
				&nbsp;&nbsp;&nbsp; module Stack =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* helper functions *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let internal_head_tail = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; failwith "Empty stack"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tail) -&gt; hd, tail<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec internal_fold_left f acc = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;| EmptyStack -&gt; acc<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tail) -&gt; internal_fold_left f (f acc hd) tail<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* public functions *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec getRange startNum endNum =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if startNum &gt; endNum then EmptyStack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else StackNode(startNum, getRange (startNum+1) endNum)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let hd s = internal_head_tail s |&gt; fst<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let tl s = internal_head_tail s |&gt; snd<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let fold f seed stack = internal_fold_left f seed stack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let reduce f stack = internal_fold_left f (hd stack) (tl stack)</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Program.fs</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open Princess.Collections<br>
				<br>
				let x = Stack.getRange 1 10<br>
				printfn "%A" (Stack.hd x)<br>
				printfn "%A" (Stack.tl x)<br>
				printfn "%A" (Stack.fold ( * ) 1 x)<br>
				printfn "%A" (Stack.reduce ( + ) x)</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Where is the</span></span> <span class="Teletyped"><span lang="EN-US" style=''>DataStructures</span></span> <span class="Bold"><span lang="EN-US">Module?</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">You may have expected the code in</span> <span class="Teletyped"><span lang="EN-US" style=''>Program.fs</span></span> <span lang="EN-US">above to open</span> <span class="Teletyped"><span lang="EN-US" style=''>Princess.Collections.DataStructures</span></span> <span lang="EN-US">rather than</span> <span class="Teletyped"><span lang="EN-US" style=''>Princess.Collections</span></span><span lang="EN-US">. According to the <a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec2.aspx#_Toc207785747"><span style='color:windowtext;text-decoration:none'>F# spec</span></a>, F# treats <em>anonymous implementation files</em> (which are files without a leading</span> <span class="Teletyped"><span lang="EN-US" style=''>module</span></span> <span lang="EN-US">or</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>namespace</span></span> <span lang="EN-US">declaration) by putting all code in an implicit module which matches the code's filename. Since we have a leading</span> <span class="Teletyped"><span lang="EN-US" style=''>namespace</span></span> <span lang="EN-US">declaration, F# does not create the implicit module.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">.NET does not permit users to create functions or values outside of classes or modules. As a consequence, we cannot write the following code:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">namespace Princess.Collections<br>
				<br>
				&nbsp;&nbsp;&nbsp; type 'a stack =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode of 'a * 'a stack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let somefunction() = 12&nbsp;&nbsp; (* &lt;--- functions not allowed outside modules *)<br>
				<br>
				&nbsp;&nbsp;&nbsp; (* ... *)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">If we prefer to have a module called</span> <span class="Teletyped"><span lang="EN-US" style=''>DataStructures</span></span><span lang="EN-US">, we can write this:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">namespace Princess.Collections<br>
				&nbsp;&nbsp;&nbsp; module DataStructures<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type 'a stack =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode of 'a * 'a stack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let somefunction() = 12<br>
				<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* ... *)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Or equivalently, we define a module and place it a namespace simultaneously using:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">module Princess.Collections.DataStructures<br>
				&nbsp;&nbsp;&nbsp; type 'a stack =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode of 'a * 'a stack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let somefunction() = 12<br>
				<br>
				&nbsp;&nbsp;&nbsp; (* ... *)</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Adding to Namespace from Multiple Files</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Unlike modules and classes, any file can contribute to a namespace. For example:</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">DataStructures.fs</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">namespace Princess.Collections<br>
				<br>
				&nbsp;&nbsp;&nbsp; type 'a stack =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode of 'a * 'a stack<br>
				<br>
				&nbsp;&nbsp;&nbsp; module Stack =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* helper functions *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let internal_head_tail = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; failwith "Empty stack"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tail) -&gt; hd, tail<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec internal_fold_left f acc = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; acc<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tail) -&gt; internal_fold_left f (f acc hd) tail<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* public functions *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec getRange startNum endNum =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if startNum &gt; endNum then EmptyStack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else StackNode(startNum, getRange (startNum+1) endNum)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let hd s = internal_head_tail s |&gt; fst<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let tl s = internal_head_tail s |&gt; snd<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let fold f seed stack = internal_fold_left f seed stack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let reduce f stack = internal_fold_left f (hd stack) (tl stack)</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">MoreDataStructures.fs</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">namespace Princess.Collections<br>
				&nbsp; &nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; type 'a tree when 'a :&gt; System.IComparable&lt;'a&gt; =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyTree<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | TreeNode of 'a * 'a tree * 'a tree<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; module Tree =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec insert (x : #System.IComparable&lt;'a&gt;) = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyTree -&gt; TreeNode(x, EmptyTree, EmptyTree)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | TreeNode(y, l, r) as node -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match x.CompareTo(y) with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0 -&gt; node<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1 -&gt; TreeNode(y, l, insert x r)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | -1 -&gt; TreeNode(y, insert x l, r)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | _ -&gt; failwith "CompareTo returned illegal value"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Since we have a leading namespace declaration in both files, F# does not create any implicit modules. The</span> <span class="Teletyped"><span lang="EN-US" style=''>'a stack</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>'a tree</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>Stack</span></span><span lang="EN-US">, and</span> <span class="Teletyped"><span lang="EN-US" style=''>Tree</span></span> <span lang="EN-US">types are all accessible through the</span> <span class="Teletyped"><span lang="EN-US" style=''>Princess.Collections</span></span> <span lang="EN-US">namespace:</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Program.fs</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">open Princess.Collections<br>
				<br>
				let x = Stack.getRange 1 10<br>
				let y =<br>
				&nbsp;&nbsp;&nbsp; let rnd = new System.Random()<br>
				&nbsp;&nbsp;&nbsp; [ for a in 1 .. 10 -&gt; rnd.Next(0, 100) ]<br>
				&nbsp;&nbsp;&nbsp; |&gt; Seq.fold (fun acc x -&gt; Tree.insert x acc) EmptyTree<br>
				&nbsp;&nbsp;&nbsp;<br>
				printfn "%A" (Stack.hd x)<br>
				printfn "%A" (Stack.tl x)<br>
				printfn "%A" (Stack.fold ( * ) 1 x)<br>
				printfn "%A" (Stack.reduce ( + ) x)<br>
				printfn "%A" y</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Controlling Class and Module Accessibility</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Unlike modules, there is no equivalent to a signature file for namespaces. Instead, the visibility of classes and submodules is controlled through standard <a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec2.aspx#_Toc207785709"><span style='color:windowtext;text-decoration:none'>accessibility modifiers</span></a>:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				<span lang="EN-US">namespace Princess.Collections<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; type 'a tree when 'a :&gt; System.IComparable&lt;'a&gt; =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyTree<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | TreeNode of 'a * 'a tree * 'a tree<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; (* InvisibleModule is only accessible by classes or<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modules inside the Princess.Collections namespace*)<br>
				&nbsp;&nbsp;&nbsp; module private InvisibleModule =<br>
				&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;let msg = "I'm invisible!"<br>
				<br>
				&nbsp;&nbsp;&nbsp; module Tree =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* InvisibleClass is only accessible by methods<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inside the Tree module *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type private InvisibleClass() =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member x.Msg() = "I'm invisible too!"<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec insert (x : #System.IComparable&lt;'a&gt;) = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyTree -&gt; TreeNode(x, EmptyTree, EmptyTree)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | TreeNode(y, l, r) as node -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match x.CompareTo(y) with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0 -&gt; node<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1 -&gt; TreeNode(y, l, insert x r)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | -1 -&gt; TreeNode(y, insert x l, r)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | _ -&gt; failwith "CompareTo returned illegal value"</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h1 class="HeadingArticle">
				Units of Measure
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Units of Measure</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Units of measure</span></span> <span lang="EN-US">allow programmers to annotate floats and integers with statically-typed unit metadata. This can be handy when writing programs which manipulate floats and integers representing specific units of measure, such as kilograms, pounds, meters, newtons, pascals, etc. F# will verify that units are used in places where the programmer intended. For example, the F# compiler will throw an error if a</span> <span class="Teletyped"><span lang="EN-US" style=''>float&lt;m/s&gt;</span></span> <span lang="EN-US">is used where it expects a</span> <span class="Teletyped"><span lang="EN-US" style=''>float&lt;kg&gt;</span></span><span lang="EN-US">.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h2 class="Heading1">
				<span lang="EN-US">Use Cases</span>
			</h2>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Statically Checked Type Conversions</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Units of measure are invaluable to programmers who work in scientific research, they add an extra layer of protection to guard against conversion related errors. To cite a famous case study, NASA's $125 million <a href="http://mars.jpl.nasa.gov/msp98/news/mco991110.html"><span style='color:windowtext;text-decoration:none'>Mars Climate Orbiter</span></a> project ended in failure when the orbiter dipped 90 km closer to Mars than originally intended, causing it to tear apart and disintegrate spectacularly in the Mars atmosphere. A post mortem analysis narrowed down the root cause of the problem to a conversion error in the orbiter's propulsion systems used to lower the spacecraft into orbit: NASA passed data to the systems in metric units, but the software expected data in Imperial units. Although there were many contributing project-management errors which resulted in the failed mission, this software bug in particular could have been prevented if the software engineers had used a type-system powerful enough to detect unit-related errors.</span>
			</p>
			<p class="MsoNormal">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<h3 class="Heading2">
				<span lang="EN-US">Decorating Data With Contextual Information</span>
			</h3>
			<p class="TextBody">
				<span lang="EN-US">In an article <a href="http://www.joelonsoftware.com/articles/Wrong.html"><span style='color:windowtext;text-decoration:none'>Making Code Look Wrong</span></a>, Joel Spolsky describes a scenario in which, during the design of Microsoft Word and Excel, programmers at Microsoft were required to track the position of objects on a page using two non-interchangeable coordinate systems:</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span lang="EN-US">In WYSIWYG word processing, you have scrollable windows, so every coordinate has to be interpreted as either relative to the window or relative to the page, and that makes a big difference, and keeping them straight is pretty important.</span> [...]
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span lang="EN-US">The compiler won&rsquo;t help you if you assign one to the other and Intellisense won&rsquo;t tell you bupkis. But they are semantically different; they need to be interpreted differently and treated differently and some kind of conversion function will need to be called if you assign one to the other or you will have a <em>runtime</em> bug.</span> If you&rsquo;re lucky. [...]
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span lang="EN-US">In Excel&rsquo;s source code you see a lot of</span> <span class="Teletyped"><span lang="EN-US" style=''>rw</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>col</span></span> <span lang="EN-US">and when you see those you know that they refer to rows and columns. Yep, they&rsquo;re both integers, but it never makes sense to assign between them. In Word, I'm told, you see a lot of</span> <span class="Teletyped"><span lang="EN-US" style=''>xl</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>xw</span></span><span lang="EN-US">, where</span> <span class="Teletyped"><span lang="EN-US" style=''>xl</span></span> <span lang="EN-US">means &ldquo;horizontal coordinates relative to the layout&rdquo; and</span> <span class="Teletyped"><span lang="EN-US" style=''>xw</span></span> <span lang="EN-US">means &ldquo;horizontal coordinates relative to the window.&rdquo; Both ints. Not interchangeable. In both apps you see a lot of</span> <span class="Teletyped"><span lang="EN-US" style=''>cb</span></span> <span lang="EN-US">meaning &ldquo;count of bytes.&rdquo; Yep, it&rsquo;s an int again, but you know so much more about it just by looking at the variable name.</span> It&rsquo;s a count of bytes: a buffer size. And if you see <span class="Teletyped"><span style=''>xl = cb</span></span>, well, blow the Bad Code Whistle, that is obviously wrong code, because even though <span class="Teletyped"><span style=''>xl</span></span> and <span class="Teletyped"><span style=''>cb</span></span> are both integers, it&rsquo;s completely crazy to set a horizontal offset in pixels to a count of bytes.
			</p>
			<p class="TextBody">
				<span lang="EN-US">In short, Microsoft depends on coding conventions to encode contextual data about a variable, and they depend on code reviews to enforce correct usage of a variable from its context. This works in practice, but its still possible for incorrect code to work its way it the product without the bug being detected for months.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">If Microsoft were using a language were using a language units of measure, they could have defined their own</span> <span class="Teletyped"><span lang="EN-US" style=''>rw</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>col</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>xw</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>xl</span></span><span lang="EN-US">, and</span> <span class="Teletyped"><span lang="EN-US" style=''>cb</span></span> <span lang="EN-US">units of measure so that an assignment of the form</span> <span class="Teletyped"><span lang="EN-US" style=''>int&lt;xl&gt; = int&lt;cb&gt;</span></span> <span lang="EN-US">not only fails visual inspection, it doesn't even compile.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Defining Units
			</h2>
			<p class="TextBody">
				<span lang="EN-US">New units of measure are defined using the</span> <span class="Teletyped"><span lang="EN-US" style=''>Measure</span></span> <span lang="EN-US">attribute:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				[&lt;Measure&gt;]<br>
				type m (* meter *)<br>
				<br>
				[&lt;Measure&gt;]<br>
				type s (* second *)
			</p>
			<p class="TextBody">
				<span lang="EN-US">Additionally, we can define types measures which are derived from existing measures as well:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				[&lt;Measure&gt;] type m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* meter *)<br>
				[&lt;Measure&gt;] type s&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(* second *)<br>
				[&lt;Measure&gt;] type kg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* kilogram *)<br>
				[&lt;Measure&gt;] type N = (kg * m)/(s^2) (* Newtons *)<br>
				[&lt;Measure&gt;] type Pa = N/(m^2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* Pascals *)
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Bold">Important:</span> Units of measure look like a data type, but they aren't. .NET's type system does not support the behaviors that units of measure have, such as being able to square, divide, or raise datatypes to powers. This functionality is provided by the F# static type checker at compile time, but units are erased from compiled code. Consequently, it is not possible to determine value's unit at runtime.
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can create instances of float and integer data which represent these units using the same notation we use with generics:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; let distance = 100.0&lt;m&gt;<br>
				let time = 5.0&lt;s&gt;<br>
				let speed = distance / time;;<br>
				<br>
				val distance : float&lt;m&gt; = 100.0<br>
				val time : float&lt;s&gt; = 5.0<br>
				val speed : float&lt;m/s&gt; = 20.0
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice the that F# automatically derives a new unit,</span> <span class="Teletyped"><span lang="EN-US" style=''>m/s</span></span><span lang="EN-US">, for the value</span> <span class="Teletyped"><span lang="EN-US" style=''>speed</span></span><span lang="EN-US">. Units of measure will multiply, divide, and cancel as needed depending on how they are used. Using these properties, it's very easy to convert between two units:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				[&lt;Measure&gt;] type C<br>
				[&lt;Measure&gt;] type F<br>
				<br>
				let to_fahrenheit (x : float&lt;C&gt;) = x * (9.0&lt;F&gt;/5.0&lt;C&gt;) + 32.0&lt;F&gt;<br>
				let to_celsius (x : float&lt;F&gt;) = (x - 32.0&lt;F&gt;) * (5.0&lt;C&gt;/9.0&lt;F&gt;)
			</p>
			<p class="TextBody">
				<span lang="EN-US">Units of measure are statically checked at compile time for proper usage. For example, if we use a measure where it isn't expected, we get a compilation error:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; [&lt;Measure&gt;] type m<br>
				[&lt;Measure&gt;] type s<br>
				<br>
				let speed (x : float&lt;m&gt;) (y : float&lt;s&gt;) = x / y;;<br>
				<br>
				[&lt;Measure&gt;]<br>
				type m<br>
				[&lt;Measure&gt;]<br>
				type s<br>
				val speed : float&lt;m&gt; -&gt; float&lt;s&gt; -&gt; float&lt;m/s&gt;<br>
				<br>
				&gt; speed 20.0&lt;m&gt; 4.0&lt;s&gt;;; (* should get a speed *)<br>
				val it : float&lt;m/s&gt; = 5.0<br>
				<br>
				&gt; speed 20.0&lt;m&gt; 4.0&lt;m&gt;;; (* boom! *)<br>
				<br>
				&nbsp; speed 20.0&lt;m&gt; 4.0&lt;m&gt;;;<br>
				&nbsp; --------------^^^^^^<br>
				<br>
				stdin(39,15): error FS0001: Type mismatch. Expecting a<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&lt;s&gt;<br>
				but given a<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&lt;m&gt;.<br>
				The unit of measure 's' does not match the unit of measure 'm'
			</p>
			<p class="TextBody">
				<span lang="EN-US">Units can be defined for integral types too:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; [&lt;Measure&gt;] type col<br>
				[&lt;Measure&gt;] type row<br>
				let colOffset (a : int&lt;col&gt;) (b : int&lt;col&gt;) = a - b<br>
				let rowOffset (a : int&lt;row&gt;) (b : int&lt;row&gt;) = a - b;;<br>
				<br>
				[&lt;Measure&gt;]<br>
				type col<br>
				[&lt;Measure&gt;]<br>
				type row<br>
				val colOffset : int&lt;col&gt; -&gt; int&lt;col&gt; -&gt; int&lt;col&gt;<br>
				val rowOffset : int&lt;row&gt; -&gt; int&lt;row&gt; -&gt; int&lt;row&gt;
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Dimensionless Values
			</h2>
			<p class="TextBody">
				<span lang="EN-US">A value without a unit is <em>dimensionless</em>. Dimensionless values are represented implicitly by writing them out without units (i.e.</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>7.0</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>-14</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>200.5</span></span><span lang="EN-US">), or they can be represented explicitly using the</span> <span class="Teletyped"><span lang="EN-US" style=''>&lt;1&gt;</span></span> <span lang="EN-US">type (i.e.</span> <span class="Teletyped"><span lang="EN-US" style=''>7.0&lt;1&gt;</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>-14&lt;1&gt;</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>200.5&lt;1&gt;</span></span><span lang="EN-US">).</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can convert dimensionless units to a specific measure by multiplying by</span> <span class="Teletyped"><span lang="EN-US" style=''>1&lt;</span></span><em><span lang="EN-US">targetMeasure</span></em><span class="Teletyped"><span lang="EN-US" style=''>&gt;</span></span><span lang="EN-US">. We can convert a measure back to a dimensionless unit by passing it to the built-in</span> <span class="Teletyped"><span lang="EN-US" style=''>float</span></span> <span lang="EN-US">or</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">methods:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				[&lt;Measure&gt;] type m<br>
				<br>
				(* val to_meters : (x : float&lt;'u&gt;) -&gt; float&lt;'u m&gt; *)<br>
				let to_meters x = x * 1&lt;m&gt;<br>
				<br>
				(* val of_meters : (x : float&lt;m&gt;) -&gt; float *)<br>
				let of_meters (x : float&lt;m&gt;) = float x
			</p>
			<p class="TextBody">
				<span lang="EN-US">Alternatively, its often easier (and safer) to divide away unneeded units:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let of_meters (x : float&lt;m&gt;) = x / 1.0&lt;m&gt;
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Generalizing Units of Measure
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Since measures and dimensionless values are (or appear to be) generic types, we can write functions which operate on both transparently:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; [&lt;Measure&gt;] type m<br>
				[&lt;Measure&gt;] type kg<br>
				<br>
				let vanillaFloats = [10.0; 15.5; 17.0]<br>
				let lengths = [ for a in [2.0; 7.0; 14.0; 5.0] -&gt; a * 1.0&lt;m&gt; ]<br>
				let masses = [ for a in [155.54; 179.01; 135.90] -&gt; a * 1.0&lt;kg&gt; ]<br>
				let densities = [ for a in [0.54; 1.0; 1.1; 0.25; 0.7] -&gt; a * 1.0&lt;kg/m^3&gt; ]<br>
				<br>
				let average (l : float&lt;'u&gt; list) =<br>
				&nbsp;&nbsp;&nbsp; let sum, count = l |&gt; List.fold (fun (sum, count) x -&gt; sum + x, count + 1.0&lt;_&gt;) (0.0&lt;_&gt;, 0.0&lt;_&gt;)<br>
				&nbsp;&nbsp;&nbsp; sum / count;;<br>
				<br>
				[&lt;Measure&gt;]<br>
				type m<br>
				[&lt;Measure&gt;]<br>
				type kg<br>
				val vanillaFloats : float list = [10.0; 15.5; 17.0]<br>
				val lengths : float&lt;m&gt; list = [2.0; 7.0; 14.0; 5.0]<br>
				val masses : float&lt;kg&gt; list = [155.54; 179.01; 135.9]<br>
				val densities : float&lt;kg/m ^ 3&gt; list = [0.54; 1.0; 1.1; 0.25; 0.7]<br>
				val average : float&lt;'u&gt; list -&gt; float&lt;'u&gt;<br>
				<br>
				&gt; average vanillaFloats, average lengths, average masses, average densities;;<br>
				val it : float * float&lt;m&gt; * float&lt;kg&gt; * float&lt;kg/m ^ 3&gt; =<br>
				&nbsp; (14.16666667, 7.0, 156.8166667, 0.718)
			</p>
			<p class="TextBody">
				<span lang="EN-US">Since units are erased from compiled code, they are not considered a real data type, so they can't be used <em>directly</em> as a type parameter in generic functions and classes. For example, the following code will not compile:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; type triple&lt;'a&gt; = { a : float&lt;'a&gt;; b : float&lt;'a&gt;; c : float&lt;'a&gt;};;<br>
				<br>
				&nbsp; type triple&lt;'a&gt; = { a : float&lt;'a&gt;; b : float&lt;'a&gt;; c : float&lt;'a&gt;};;<br>
				&nbsp; ------------------------------^^<br>
				<br>
				stdin(40,31): error FS0191: Expected unit-of-measure parameter, not type parameter.<br>
				Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute
			</p>
			<p class="TextBody">
				<span lang="EN-US">F# does not infer that</span> <span class="Teletyped"><span lang="EN-US" style=''>'a</span></span> <span lang="EN-US">is a unit of measure above, possibly because the following code <em>appears</em> correct, but it can be used in non-sensical ways:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type quad&lt;'a&gt; = { a : float&lt;'a&gt;; b : float&lt;'a&gt;; c : float&lt;'a&gt;; d : 'a}
			</p>
			<p class="TextBody">
				<span lang="EN-US">The type</span> <span class="Teletyped"><span lang="EN-US" style=''>'a</span></span> <span lang="EN-US">can be a unit of measure <em>or</em> a data type, but not both at the same time. F#'s type checker assumes</span> <span class="Teletyped"><span lang="EN-US" style=''>'a</span></span> <span lang="EN-US">is a type parameter <em>unless otherwise specified</em>. We can use the</span> <span class="Teletyped"><span lang="EN-US" style=''>[&lt;Measure&gt;]</span></span> <span lang="EN-US">attribute to change the</span> <span class="Teletyped"><span lang="EN-US" style=''>'a</span></span> <span lang="EN-US">to a unit of measure:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; type triple&lt;[&lt;Measure&gt;] 'a&gt; = { a : float&lt;'a&gt;; b : float&lt;'a&gt;; c : float&lt;'a&gt;};;<br>
				<br>
				type triple&lt;[&lt;Measure&gt;] 'a&gt; =<br>
				&nbsp; {a: float&lt;'a&gt;;<br>
				&nbsp;&nbsp; b: float&lt;'a&gt;;<br>
				&nbsp;&nbsp; c: float&lt;'a&gt;;}<br>
				<br>
				&gt; { a = 7.0&lt;kg&gt;; b = -10.5&lt;_&gt;; c = 0.5&lt;_&gt; };;<br>
				val it : triple&lt;kg&gt; = {a = 7.0;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b = -10.5;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = 0.5;}
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				F# PowerPack
			</h2>
			<p class="TextBody">
				<span lang="EN-US">The F# PowerPack (FSharp.PowerPack.dll) includes a number of predefined units of measure for scientific applications. These are available in the following modules:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/fsharp.powerpack/Microsoft.FSharp.Math.SI.html"><span style='color:windowtext;text-decoration:none'>Microsoft.FSharp.Math.SI</span></a> - a variety of predefined measures in the International System of Units (SI).</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/fsharp.powerpack/Microsoft.FSharp.Math.PhysicalConstants.html"><span style='color:windowtext;text-decoration:none'>Microsoft.FSharp.Math.PhysicalConstants</span></a> - Fundamental physical constants with units of measure.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				External Resources
			</h2>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Andrew Kennedy's 4-part tutorial on units of measure:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/andrewkennedy/archive/2008/08/29/units-of-measure-in-f-part-one-introducing-units.aspx"><span style='color:windowtext;text-decoration:none'>Part 1: Introducing Units</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/andrewkennedy/archive/2008/09/02/units-of-measure-in-f-part-two-unit-conversions.aspx"><span style='color:windowtext;text-decoration:none'>Part 2: Unit Conversions</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/andrewkennedy/archive/2008/09/04/units-of-measure-in-f-part-three-generic-units.aspx"><span style='color:windowtext;text-decoration:none'>Part 3: Generic Units</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/andrewkennedy/archive/2009/06/09/units-of-measure-in-f_2300_-part-four-parameterized-types.aspx"><span style='color:windowtext;text-decoration:none'>Part 4: Parameterized Types</span></a></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://msdn.microsoft.com/en-us/library/dd233243(VS.100).aspx"><span style='color:windowtext;text-decoration:none'>F# Units of Measure</span></a> (MSDN)</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h1 class="HeadingArticle">
				Caching
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Caching</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">Caching is often useful to re-use data which has already been computed. F# provides a number of built-in techniques to cache data for future use.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Partial Functions
			</h2>
			<p class="TextBody">
				<span lang="EN-US">F# automatically caches the value of any function which takes no parameters. When F# comes across a function with no parameters, F# will only evaluate the function once and reuse its value everytime the function is accessed. Compare the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let isNebraskaCity_bad city =<br>
				&nbsp;&nbsp;&nbsp; let cities =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "Creating cities Set"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ["Bellevue"; "Omaha"; "Lincoln"; "Papillion"]<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Set.ofList<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; cities.Contains(city)<br>
				&nbsp;&nbsp;&nbsp;<br>
				let isNebraskaCity_good =<br>
				&nbsp;&nbsp;&nbsp; let cities =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "Creating cities Set"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ["Bellevue"; "Omaha"; "Lincoln"; "Papillion"]<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Set.ofList<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; fun city -&gt; cities.Contains(city)
			</p>
			<p class="TextBody">
				<span lang="EN-US">Both functions accept and return the same values, but they have very different behavior. Here's a comparison of the output in fsi:</span>
			</p>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">isNebraskaCity_bad</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">isNebraskaCity_good</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
						<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
							&gt; let isNebraskaCity_bad city =<br>
							&nbsp;&nbsp;&nbsp; let cities =<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;printfn "Creating cities Set"<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ["Bellevue"; "Omaha"; "Lincoln"; "Papillion"]<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Set.of_list<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
							&nbsp;&nbsp;&nbsp; cities.Contains(city);;<br>
							<br>
							val isNebraskaCity_bad : string -&gt; bool<br>
							<br>
							&gt; isNebraskaCity_bad "Lincoln";;<br>
							Creating cities Set<br>
							val it : bool = true<br>
							<br>
							&gt; isNebraskaCity_bad "Washington";;<br>
							Creating cities Set<br>
							val it : bool = false<br>
							<br>
							&gt; isNebraskaCity_bad "Bellevue";;<br>
							Creating cities Set<br>
							val it : bool = true<br>
							<br>
							&gt; isNebraskaCity_bad "St. Paul";;<br>
							Creating cities Set<br>
							val it : bool = false
						</p>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
						<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
							&gt; let isNebraskaCity_good =<br>
							&nbsp;&nbsp;&nbsp; let cities =<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "Creating cities Set"<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ["Bellevue"; "Omaha"; "Lincoln"; "Papillion"]<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Set.of_list<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
							&nbsp;&nbsp;&nbsp; fun city -&gt; cities.Contains(city);;<br>
							Creating cities Set<br>
							<br>
							val isNebraskaCity_good : (string -&gt; bool)<br>
							<br>
							&gt; isNebraskaCity_good "Lincoln";;<br>
							val it : bool = true<br>
							<br>
							&gt; isNebraskaCity_good "Washington";;<br>
							val it : bool = false<br>
							<br>
							&gt; isNebraskaCity_good "Bellevue";;<br>
							val it : bool = true<br>
							<br>
							&gt; isNebraskaCity_good "St. Paul";;<br>
							val it : bool = false
						</p>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">The implementation of</span> <span class="Teletyped"><span lang="EN-US" style=''>isNebraskaCity_bad</span></span> <span lang="EN-US">forces F# to re-create the internal set on each call. On the other hand,</span> <span class="Teletyped"><span lang="EN-US" style=''>isNebraskaCity_good</span></span> <span lang="EN-US">is a value initialized to the function</span> <span class="Teletyped"><span lang="EN-US" style=''>fun city -&gt; cities.Contains(city)</span></span><span lang="EN-US">, so it creates its internal set once and reuses it for all successive calls.</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Bold">Note:</span> Internally, <span class="Teletyped"><span style=''>isNebraskaCity_bad</span></span> is compiled as a static function which constructs a set on every call. <span class="Teletyped"><span style=''>isNebraskaCity_good</span></span> is compiled as a static readonly property, where the value is initialized in a static constructor.
			</p>
			<p class="TextBody">
				<span lang="EN-US">This distinction is often subtle, but it can have a huge impact on an application's performance.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Memoization
			</h2>
			<p class="TextBody">
				<span lang="EN-US">"Memoization" is a fancy word meaning that computed values are stored in a lookup table rather than recomputed on every successive call. Long-running pure functions (i.e. functions which have no side-effects) are good candidates for memoization. Consider the recursive definition for computing Fibonacci numbers:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; #time;;<br>
				<br>
				--&gt; Timing now on<br>
				<br>
				&gt; let rec fib n =<br>
				&nbsp;&nbsp;&nbsp; if n = 0I then 0I<br>
				&nbsp;&nbsp;&nbsp; elif n = 1I then 1I<br>
				&nbsp;&nbsp;&nbsp; else fib (n - 1I) + fib(n - 2I);;<br>
				Real: 00:00:00.000, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0<br>
				<br>
				val fib : Math.bigint -&gt; Math.bigint<br>
				<br>
				&gt; fib 35I;;<br>
				Real: 00:00:23.557, CPU: 00:00:23.515, GC gen0: 2877, gen1: 3, gen2: 0<br>
				val it : Math.bigint = 9227465I
			</p>
			<p class="TextBody">
				<span lang="EN-US">Beyond</span> <span class="Teletyped"><span lang="EN-US" style=''>fib 35I</span></span><span lang="EN-US">, the runtime of the function becomes unbearable. Each recursive call to the</span> <span class="Teletyped"><span lang="EN-US" style=''>fib</span></span> <span lang="EN-US">function throws away all of its intermediate calculations to</span> <span class="Teletyped"><span lang="EN-US" style=''>fib(n - 1I)</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>fib(n - 2I)</span></span><span lang="EN-US">, giving it a runtime complexity of about O(2^n). What if we kept all of those intermediate calculations around in a lookup table? Here's the memoized version of the</span> <span class="Teletyped"><span lang="EN-US" style=''>fib</span></span> <span lang="EN-US">function:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; #time;;<br>
				<br>
				--&gt; Timing now on<br>
				<br>
				&gt; let rec fib =<br>
				&nbsp;&nbsp;&nbsp; let dict = new System.Collections.Generic.Dictionary&lt;_,_&gt;()<br>
				&nbsp;&nbsp;&nbsp; fun n -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match dict.TryGetValue(n) with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | true, v -&gt; v<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | false, _ -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let temp =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if n = 0I then 0I<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif n = 1I then 1I<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else fib (n - 1I) + fib(n - 2I)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dict.Add(n, temp)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp;;<br>
				<br>
				val fib : (Math.bigint -&gt; Math.bigint)<br>
				<br>
				&gt; fib 35I;;<br>
				Real: 00:00:00.000, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0<br>
				val it : Math.bigint = 9227465I
			</p>
			<p class="TextBody">
				<span lang="EN-US">Much better! This version of the</span> <span class="Teletyped"><span lang="EN-US" style=''>fib</span></span> <span lang="EN-US">function runs almost instaneously. In fact, since we only calculate the value of any</span> <span class="Teletyped"><span lang="EN-US" style=''>fib(n)</span></span> <span lang="EN-US">precisely once, and dictionary lookups are an</span> <span class="Teletyped"><span lang="EN-US" style=''>O(1)</span></span> <span lang="EN-US">operation, this fib function runs in O(n) time.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice all of the memoization logic is contained in the</span> <span class="Teletyped"><span lang="EN-US" style=''>fib</span></span> <span lang="EN-US">function. We can write a more general function to memoize any function:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let memoize f =<br>
				&nbsp;&nbsp;&nbsp; let dict = new System.Collections.Generic.Dictionary&lt;_,_&gt;()<br>
				&nbsp;&nbsp;&nbsp; fun n -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match dict.TryGetValue(n) with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (true, v) -&gt; v<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | _ -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let temp = f(n)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dict.Add(n, temp)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let rec fib = memoize(fun n -&gt;<br>
				&nbsp;&nbsp;&nbsp; if n = 0I then 0I<br>
				&nbsp;&nbsp;&nbsp; elif n = 1I then 1I<br>
				&nbsp;&nbsp;&nbsp; else fib (n - 1I) + fib (n - 2I) )
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Bold">Note:</span> Its very important to remember that the implementation above is not thread-safe -- the dictionary should be locked before adding/retrieving items if it will be accessed by multiple threads.
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Additionally, although dictionary lookups occur in constant time, the hash function used by the dictionary can take an arbitrarily long time to execute (this is especially true with strings, where the time it takes to hash a string is proportional to its length). For this reason, it is wholly possible for a memoized function to have less performance than an unmemoized function. Always profile code to determine whether optimization is necessary and whether memoization genuinely improves performance.
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Lazy Values
			</h2>
			<p class="TextBody">
				<span lang="EN-US">The F#</span> <span class="Teletyped"><span lang="EN-US" style=''>lazy</span></span> <span lang="EN-US">data type is an interesting primitive which delays evaluation of a value until the value is actually needed. Once computed, lazy values are cached for reuse later:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; let x = lazy(printfn "I'm lazy"; 5 + 5);;<br>
				<br>
				val x : Lazy&lt;int&gt; = &lt;unevaluated&gt;<br>
				<br>
				&gt; x.Force();; (* Should print "I'm lazy" *)<br>
				I'm lazy<br>
				val it : int = 10<br>
				<br>
				&gt; x.Force();; (* Value already computed, should not print "I'm lazy" again *)<br>
				val it : int = 10
			</p>
			<p class="TextBody">
				<span lang="EN-US">F# uses some compiler magic to avoid evaluating the expression</span> <span class="Teletyped"><span lang="EN-US" style=''>(printfn "I'm lazy"; 5 + 5)</span></span> <span lang="EN-US">on declaration. Lazy values are probably the simplest form of caching, however they can be used to create some interesting and sophisticated data structures. For example, two F# data structures are implemented on top of lazy values, namely the F# <a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/fsharp.powerpack/microsoft.fsharp.collections.lazylist.html"><span style='color:windowtext;text-decoration:none'>Lazy List</span></a> and</span> <span class="Teletyped"><span lang="EN-US" style=''>Seq.cache</span></span> <span lang="EN-US">method.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Lazy lists and cached sequences represent arbitrary sequences of potentially infinite numbers of elements. The elements are computed and cached the first time they are accessed, but will not be recomputed when the sequence is enumerated again. Here's a demonstration in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; let x = seq { for a in 1 .. 10 -&gt; printfn "Got %i" a; a } |&gt; Seq.cache;;<br>
				<br>
				val x : seq&lt;int&gt;<br>
				<br>
				&gt; let y = Seq.take 5 x;;<br>
				<br>
				val y : seq&lt;int&gt;<br>
				<br>
				&gt; Seq.reduce (+) y;;<br>
				Got 1<br>
				Got 2<br>
				Got 3<br>
				Got 4<br>
				Got 5<br>
				val it : int = 15<br>
				<br>
				&gt; Seq.reduce (+) y;; (* Should not recompute values *)<br>
				val it : int = 15<br>
				<br>
				&gt; Seq.reduce (+) x;; (* Values 1 through 5 already computed, should only compute 6 through 10 *)<br>
				Got 6<br>
				Got 7<br>
				Got 8<br>
				Got 9<br>
				Got 10<br>
				val it : int = 55
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h1 class="HeadingArticle">
				Active Patterns
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Active Patterns</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<em><span lang="EN-US">Active Patterns</span></em> <span lang="EN-US">allow programmers to wrap arbitrary values in a <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Discriminated_Unions"><span style='color:windowtext;text-decoration:none'>union</span></a>-like data structure for easy pattern matching. For example, its possible wrap <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Classes"><span style='color:windowtext;text-decoration:none'>objects</span></a> with an active pattern, so that you can use objects in pattern matching as easily as any other union type.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Defining Active Patterns
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Active patterns look like functions with a funny name:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let (|name1|name2|...|) = ...
			</p>
			<p class="TextBody">
				<span lang="EN-US">This function defines an ad hoc union data structure, where each union case</span> <span class="Teletyped"><span lang="EN-US" style=''>name</span></span><em><span lang="EN-US">n</span></em> <span lang="EN-US">is separated from the next by a</span> <span class="Teletyped"><span lang="EN-US" style=''>|</span></span> <span lang="EN-US">and the entire list is enclosed between</span> <span class="Teletyped"><span lang="EN-US" style=''>(|</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>|)</span></span> <span lang="EN-US">(humbly called "banana brackets"). In other words, the function does not have a simple name at all, it instead defines a series of union constructors.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">A typical active pattern might look like this:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let (|Even|Odd|) n =<br>
				&nbsp;&nbsp;&nbsp; if n % 2 = 0 then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Even<br>
				&nbsp;&nbsp;&nbsp; else<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Odd
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>Even</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Odd</span></span> <span lang="EN-US">are union constructors, so our active pattern either returns an instance of</span> <span class="Teletyped"><span lang="EN-US" style=''>Even</span></span> <span lang="EN-US">or an instance of</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>Odd</span></span><span lang="EN-US">. The code above is roughly equivalent to the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type numKind =<br>
				&nbsp;&nbsp;&nbsp; | Even<br>
				&nbsp;&nbsp;&nbsp; | Odd<br>
				<br>
				let get_choice n =<br>
				&nbsp;&nbsp;&nbsp; if n % 2 = 0 then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Even<br>
				&nbsp;&nbsp;&nbsp; else<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Odd
			</p>
			<p class="TextBody">
				<span lang="EN-US">Active patterns can also define union constructors which take a set of parameters. For example, consider we can wrap a</span> <span class="Teletyped"><span lang="EN-US" style=''>seq&lt;'a&gt;</span></span> <span lang="EN-US">with an active pattern as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let (|SeqNode|SeqEmpty|) s =<br>
				&nbsp;&nbsp;&nbsp; if Seq.isEmpty s then SeqEmpty<br>
				&nbsp;&nbsp;&nbsp; else SeqNode ((Seq.hd s), Seq.skip 1 s)
			</p>
			<p class="TextBody">
				<span lang="EN-US">This code is, of course, equivalent to the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type 'a seqWrapper =<br>
				&nbsp;&nbsp;&nbsp; | SeqEmpty<br>
				&nbsp;&nbsp;&nbsp; | SeqNode of 'a * seq&lt;'a&gt;<br>
				&nbsp;&nbsp;&nbsp;<br>
				let get_choice s =<br>
				&nbsp;&nbsp;&nbsp; if Seq.isEmpty s then SeqEmpty<br>
				&nbsp;&nbsp;&nbsp; else SeqNode ((Seq.hd s), Seq.skip 1 s)
			</p>
			<p class="TextBody">
				<span lang="EN-US">You've probably noticed the immediate difference between active patterns and explicitly defined unions:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Active patterns define an <em>anonymous</em> union, where the explicit union has a name (</span><span class="Teletyped"><span lang="EN-US" style=''>numKind</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>seqWrapper</span></span><span lang="EN-US">, etc.).</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Active patterns determine their constructor parameters using a kind of type-inference, whereas we need to explicitly define the constructor parameters for each case of our explicit union.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Using Active Patterns
			</h3>
			<p class="TextBody">
				<span lang="EN-US">The syntax for using active patterns looks a little odd, but once you know what's going on, it's very easy to understand. Active patterns are used in pattern matching expressions, for example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; let (|Even|Odd|) n =<br>
				&nbsp;&nbsp;&nbsp; if n % 2 = 0 then Even<br>
				&nbsp;&nbsp;&nbsp; else Odd<br>
				&nbsp;&nbsp;&nbsp;<br>
				let testNum n =<br>
				&nbsp;&nbsp;&nbsp; match n with<br>
				&nbsp;&nbsp;&nbsp; | Even -&gt; printfn "%i is even" n<br>
				&nbsp; &nbsp;&nbsp;| Odd -&gt; printfn "%i is odd" n;;<br>
				<br>
				val ( |Even|Odd| ) : int -&gt; Choice&lt;unit,unit&gt;<br>
				val testNum : int -&gt; unit<br>
				<br>
				&gt; testNum 12;;<br>
				12 is even<br>
				val it : unit = ()<br>
				<br>
				&gt; testNum 17;;<br>
				17 is odd
			</p>
			<p class="TextBody">
				<span lang="EN-US">What's going on here? When the pattern matching function encounters</span> <span class="Teletyped"><span lang="EN-US" style=''>Even</span></span><span lang="EN-US">, it calls</span> <span class="Teletyped"><span lang="EN-US" style=''>(|Even|Odd|)</span></span> <span lang="EN-US">with parameter in the match clause, it's as if you've written:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type numKind =<br>
				&nbsp;&nbsp;&nbsp; | Even<br>
				&nbsp;&nbsp;&nbsp; | Odd<br>
				<br>
				let get_choice n =<br>
				&nbsp;&nbsp;&nbsp; if n % 2 = 0 then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Even<br>
				&nbsp;&nbsp;&nbsp; else<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Odd<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let testNum n =<br>
				&nbsp;&nbsp;&nbsp; match get_choice n with<br>
				&nbsp;&nbsp;&nbsp; | Even -&gt; printfn "%i is even" n<br>
				&nbsp;&nbsp;&nbsp; | Odd -&gt; printfn "%i is odd" n
			</p>
			<p class="TextBody">
				<span lang="EN-US">The parameter in the match clause is always passed as the last argument to the active pattern expression. Using our</span> <span class="Teletyped"><span lang="EN-US" style=''>seq</span></span> <span lang="EN-US">example from earlier, we can write the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; let (|SeqNode|SeqEmpty|) s =<br>
				&nbsp;&nbsp;&nbsp; if Seq.isEmpty s then SeqEmpty<br>
				&nbsp;&nbsp;&nbsp; else SeqNode ((Seq.head s), Seq.skip 1 s)<br>
				&nbsp;&nbsp;&nbsp;<br>
				let perfectSquares = seq { for a in 1 .. 10 -&gt; a * a }<br>
				<br>
				let rec printSeq = function<br>
				&nbsp;&nbsp;&nbsp; | SeqEmpty -&gt; printfn "Done."<br>
				&nbsp;&nbsp;&nbsp; | SeqNode(hd, tl) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf "%A " hd<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printSeq tl;;<br>
				<br>
				val ( |SeqNode|SeqEmpty| ) : seq&lt;'a&gt; -&gt; Choice&lt;('a * seq&lt;'a&gt;),unit&gt;<br>
				val perfectSquares : seq&lt;int&gt;<br>
				val printSeq : seq&lt;'a&gt; -&gt; unit<br>
				<br>
				&gt; printSeq perfectSquares;;<br>
				1 4 9 16 25 36 49 64 81 100 Done.
			</p>
			<p class="TextBody">
				<span lang="EN-US">Traditionally,</span> <span class="Teletyped"><span lang="EN-US" style=''>seq</span></span><span lang="EN-US">'s are resistant to pattern matching, but now we can operate on them just as easily as lists.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Parameterizing Active Patterns
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Its possible to pass arguments to active patterns, for example:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; let (|Contains|) needle (haystack : string) =<br>
				&nbsp;&nbsp;&nbsp; haystack.Contains(needle)<br>
				<br>
				let testString = function<br>
				&nbsp;&nbsp;&nbsp; | Contains "kitty" true -&gt; printfn "Text contains 'kitty'"<br>
				&nbsp;&nbsp;&nbsp; | Contains "doggy" true -&gt; printfn "Text contains 'doggy'"<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt; printfn "Text neither contains 'kitty' nor 'doggy'";;<br>
				<br>
				val ( |Contains| ) : string -&gt; string -&gt; bool<br>
				val testString : string -&gt; unit<br>
				<br>
				&gt; testString "I have a pet kitty and she's super adorable!";;<br>
				Text contains 'kitty'<br>
				val it : unit = ()<br>
				<br>
				&gt; testString "She's fat and purrs a lot :)";;<br>
				Text neither contains 'kitty' nor 'doggy'
			</p>
			<p class="TextBody">
				<span lang="EN-US">The single-case active pattern</span> <span class="Teletyped"><span lang="EN-US" style=''>(|Contains|)</span></span> <span lang="EN-US">wraps the</span> <span class="Teletyped"><span lang="EN-US" style=''>String.Contains</span></span><span lang="EN-US">function. When we call</span> <span class="Teletyped"><span lang="EN-US" style=''>Contains "kitty"</span></span> <span class="Underline"><span lang="EN-US">true</span></span><span lang="EN-US">, F# passes</span> <span class="Teletyped"><span lang="EN-US" style=''>"kitty"</span></span> <span lang="EN-US">and the argument we're matching against to the</span> <span class="Teletyped"><span lang="EN-US" style=''>(|Contains|)</span></span> <span lang="EN-US">active pattern and tests the return value against the value <span class="Underline">true</span>. The code above is equivalent to:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type choice =<br>
				&nbsp;&nbsp;&nbsp; | Contains of bool<br>
				&nbsp;&nbsp;&nbsp;<br>
				let get_choice needle (haystack : string) = Contains(haystack.Contains(needle))<br>
				<br>
				let testString n =<br>
				&nbsp;&nbsp;&nbsp; match get_choice "kitty" n with<br>
				&nbsp;&nbsp;&nbsp; | Contains(true) -&gt; printfn "Text contains 'kitty'"<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match get_choice "doggy" n with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Contains(true) -&gt; printfn "Text contains 'doggy'"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | printfn "Text neither contains 'kitty' nor 'doggy'"
			</p>
			<p class="TextBody">
				<span lang="EN-US">As you can see, the code using the active patterns is much cleaner and easier to read than the equivalent code using the explicitly defined union.</span>
			</p>
			<p class="Blockquote">
				&nbsp;
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Note:</span></span> <span lang="EN-US">Single-case active patterns might not look terribly useful at first, but they can really help to clean up messy code. For example, the active pattern above wraps up the</span> <span class="Teletyped"><span lang="EN-US" style=''>String.Contains</span></span> <span lang="EN-US">method and allows us to invoke it in a pattern matching expression. Without the active pattern, pattern matching quickly becomes messy:</span>
			</p>
			<p class="Blockquote">
				&nbsp;
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let testString = function<br>
				&nbsp;&nbsp;&nbsp; | (n : string) when n.Contains("kitty") -&gt; printfn "Text contains 'kitty'"<br>
				&nbsp;&nbsp;&nbsp; | n when n.Contains("doggy") -&gt; printfn "Text contains 'doggy'"<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt; printfn "Text neither contains 'kitty' nor 'doggy'"
			</p>
			<p class="Blockquote">
				&nbsp;
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Partial Active Patterns
			</h3>
			<p class="TextBody">
				<span lang="EN-US">A partial active pattern is a special class of single-case active patterns: it either returns</span> <span class="Teletyped"><span lang="EN-US" style=''>Some</span></span> <span lang="EN-US">or</span> <span class="Teletyped"><span lang="EN-US" style=''>None</span></span><span lang="EN-US">. For example, a very handy active pattern for working with regex can be defined as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; let (|RegexContains|_|) pattern input =<br>
				&nbsp;&nbsp;&nbsp; let matches = System.Text.RegularExpressions.Regex.Matches(input, pattern)<br>
				&nbsp;&nbsp;&nbsp; if matches.Count &gt; 0 then Some [ for m in matches -&gt; m.Value ]<br>
				&nbsp;&nbsp;&nbsp; else None<br>
				<br>
				let testString = function<br>
				&nbsp;&nbsp;&nbsp; | RegexContains "http://\S+" urls -&gt; printfn "Got urls: %A" urls<br>
				&nbsp;&nbsp;&nbsp; | RegexContains "[^@]@[^.]+\.\W+" emails -&gt; printfn "Got email address: %A" emails<br>
				&nbsp;&nbsp;&nbsp; | RegexContains "\d+" numbers -&gt; printfn "Got numbers: %A" numbers<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt; printfn "Didn't find anything.";;<br>
				<br>
				val ( |RegexContains|_| ) : string -&gt; string -&gt; string list option<br>
				val testString : string -&gt; unit<br>
				<br>
				&gt; testString "867-5309, Jenny are you there?";;<br>
				Got numbers: ["867"; "5309"]
			</p>
			<p class="TextBody">
				<span lang="EN-US">This is equivalent to writing:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type choice =<br>
				&nbsp;&nbsp;&nbsp; | RegexContains of string list<br>
				&nbsp;&nbsp;&nbsp;<br>
				let get_choice pattern input =<br>
				&nbsp;&nbsp;&nbsp; let matches = System.Text.RegularExpressions.Regex.Matches(input, pattern)<br>
				&nbsp;&nbsp;&nbsp; if matches.Count &gt; 0 then Some (RegexContains [ for m in matches -&gt; m.Value ])<br>
				&nbsp;&nbsp;&nbsp; else None<br>
				<br>
				let testString n =<br>
				&nbsp;&nbsp;&nbsp; match get_choice "http://\S+" n with<br>
				&nbsp;&nbsp;&nbsp; | Some(RegexContains(urls)) -&gt; printfn "Got urls: %A" urls<br>
				&nbsp;&nbsp;&nbsp; | None -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match get_choice "[^@]@[^.]+\.\W+" n with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Some(RegexContains emails) -&gt; printfn "Got email address: %A" emails<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | None -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match get_choice "\d+" n with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Some(RegexContains numbers) -&gt; printfn "Got numbers: %A" numbers<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | _ -&gt; printfn "Didn't find anything."
			</p>
			<p class="TextBody">
				<span lang="EN-US">Using partial active patterns, we can test an input against any number of active patterns:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let (|StartsWith|_|) needle (haystack : string) = if haystack.StartsWith(needle) then Some() else None<br>
				let (|EndsWith|_|) needle (haystack : string) = if haystack.EndsWith(needle) then Some() else None<br>
				let (|Equals|_|) x y = if x = y then Some() else None<br>
				let (|EqualsMonkey|_|) = function (* "Higher-order" active pattern *)<br>
				&nbsp;&nbsp;&nbsp; | Equals "monkey" () -&gt; Some()<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt; None<br>
				let (|RegexContains|_|) pattern input =<br>
				&nbsp;&nbsp;&nbsp; let matches = System.Text.RegularExpressions.Regex.Matches(input, pattern)<br>
				&nbsp;&nbsp;&nbsp; if matches.Count &gt; 0 then Some [ for m in matches -&gt; m.Value ]<br>
				&nbsp;&nbsp;&nbsp; else None<br>
				<br>
				let testString n =<br>
				&nbsp;&nbsp;&nbsp; match n with<br>
				&nbsp;&nbsp;&nbsp; | StartsWith "kitty" () -&gt; printfn "starts with 'kitty'"<br>
				&nbsp;&nbsp;&nbsp; | StartsWith "bunny" () -&gt; printfn "starts with 'bunny'"<br>
				&nbsp;&nbsp;&nbsp; | EndsWith "doggy" () -&gt; printfn "ends with 'doggy'"<br>
				&nbsp;&nbsp;&nbsp; | Equals "monkey" () -&gt; printfn "equals 'monkey'"<br>
				&nbsp;&nbsp;&nbsp; | EqualsMonkey -&gt; printfn "EqualsMonkey!" (* Note: EqualsMonkey and EqualsMonkey() are equivalent *)<br>
				&nbsp;&nbsp;&nbsp; | RegexContains "http://\S+" urls -&gt; printfn "Got urls: %A" urls<br>
				&nbsp;&nbsp;&nbsp; | RegexContains "[^@]@[^.]+\.\W+" emails -&gt; printfn "Got email address: %A" emails<br>
				&nbsp;&nbsp;&nbsp; | RegexContains "\d+" numbers -&gt; printfn "Got numbers: %A" numbers<br>
				&nbsp;&nbsp;&nbsp; | _ -&gt; printfn "Didn't find anything."
			</p>
			<p class="TextBody">
				<span lang="EN-US">Partial active patterns don't constrain us to a finite set of cases like traditional unions do, we can use as many partial active patterns in match statement as we need.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Additional Resources
			</h2>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/chrsmith/archive/2008/02/21/Introduction-to-F_2300_-Active-Patterns.aspx"><span style='color:windowtext;text-decoration:none'>Introduction to Active Patterns</span></a> by Chris Smith</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://research.microsoft.com/pubs/79947/p29-syme.pdf"><span style='color:windowtext;text-decoration:none'>Extensible Pattern Matching via Lightweight Language Extension</span></a> by Don Syme</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h1 class="HeadingArticle">
				Advanced Data Structures
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Advanced Data Structures</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">F# comes with its own set of data structures, however its very important to know how to implement data structures from scratch.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Incidentally, hundreds of authors have written thousands of lengthy volumes on this single topic alone, so its unreasonable to provide a comprehensive picture of data structures in the short amount of space available for this book. Instead, this chapter is intended as a cursory introduction to the development of immutable data structures using F#. Readers are encouraged to use the resources listed at the bottom of this page for a more comprehensive treatment of algorithms and data structures.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Stacks
			</h2>
			<p class="TextBody">
				<span lang="EN-US">F#'s built-in <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Lists"><span style='color:windowtext;text-decoration:none'>list</span></a> data structure is essentially an immutable stack. While its certainly usable, for the purposes of writing exploratory code, we're going to implement a stack from scratch. We can represent each node in a stack using a simple union:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type 'a stack =<br>
				&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;&nbsp;&nbsp; | StackNode of 'a * 'a stack
			</p>
			<p class="TextBody">
				<span lang="EN-US">It's easy enough to create an instance of a stack using:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let stack = StackNode(1, StackNode(2, StackNode(3, StackNode(4, StackNode(5, EmptyStack)))))
			</p>
			<p class="TextBody">
				<span lang="EN-US">Each StackNode contains an value and a pointer to the next stack in the list. The resulting data structure can be diagrammed as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				___&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___ |_1_|-&gt;|_2_|-&gt;|_3_|-&gt;|_4_|-&gt;|_5_|-&gt;Empty
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can create a boilerplate stack module as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				module Stack =<br>
				&nbsp;&nbsp;&nbsp; type 'a stack =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode of 'a * 'a stack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let hd = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; failwith "Empty stack"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tl) -&gt; hd<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let tl = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; failwith "Empty stack"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tl) -&gt; tl<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let cons hd tl = StackNode(hd, tl)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let empty = EmptyStack
			</p>
			<p class="TextBody">
				<span lang="EN-US">Let's say we wanted to add a few methods to our stack, such as a method which updates an item at a certain index. Since our nodes are immutable, we can't update our list in place; we need to copy all of the nodes up to the node we want to update.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				Setting item at index 2 to the value 9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___ let x =&nbsp; |_1_|-&gt;|_2_|-&gt;|_3_|-&gt;|_4_|-&gt;|_5_|-&gt;Empty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___ /let y =&nbsp; |_1_|-&gt;|_2_|-&gt;|_9_|
			</p>
			<p class="TextBody">
				<span lang="EN-US">So, we copy all of the nodes up to index 2 and reuse the remaining nodes. A function like this is very easy to write:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let rec update index value s =<br>
				&nbsp;&nbsp;&nbsp; match index, s with<br>
				&nbsp;&nbsp;&nbsp; | index, EmptyStack -&gt; failwith "Index out of range"<br>
				&nbsp;&nbsp;&nbsp; | 0, StackNode(hd, tl) -&gt; StackNode(value, tl)<br>
				&nbsp;&nbsp;&nbsp; | n, StackNode(hd, tl) -&gt; StackNode(hd, update (index - 1) value tl)
			</p>
			<p class="TextBody">
				<span lang="EN-US">Appending items from one stack to the rear of another uses a similar technique. Since we can't modify stacks in place, we append two stacks by copying all of the nodes from the "front" stack and pointing the last copied node to the our "rear" stack, resulting in the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				Append x and y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___ let x =&nbsp; |_1_|-&gt;|_2_|-&gt;|_3_|-&gt;|_4_|-&gt;|_5_|-&gt;Empty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___ let y =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|_6_|-&gt;|_7_|-&gt;|_8_|-&gt;Empty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___&nbsp;&nbsp;&nbsp; ___ /let z =&nbsp; |_1_|-&gt;|_2_|-&gt;|_3_|-&gt;|_4_|-&gt;|_5_|
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can implement this function with minimal effort using the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let rec append x y =<br>
				&nbsp;&nbsp;&nbsp; match x with<br>
				&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; y<br>
				&nbsp;&nbsp;&nbsp; | StackNode(hd, tl) -&gt; StackNode(hd, append tl y)
			</p>
			<p class="TextBody">
				<span lang="EN-US">Stacks are very easy to work with and implement. The principles behind copying nodes to "modify" stacks is fundamentally the same for all persistent data structures.</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Complete Stack Module</span></span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				module Stack =<br>
				&nbsp;&nbsp;&nbsp; type 'a stack =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode of 'a * 'a stack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let hd = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; failwith "Empty stack"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tl) -&gt; hd<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let tl = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; failwith "Emtpy stack"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tl) -&gt; tl<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let cons hd tl = StackNode(hd, tl)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let empty = EmptyStack<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let rec update index value s =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match index, s with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | index, EmptyStack -&gt; failwith "Index out of range"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0, StackNode(hd, tl) -&gt; StackNode(value, tl)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | n, StackNode(hd, tl) -&gt; StackNode(hd, update (index - 1) value tl)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let rec append x y =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match x with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; y<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tl) -&gt; StackNode(hd, append tl y)<br>
				<br>
				&nbsp;&nbsp;&nbsp; let rec map f = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; EmptyStack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tl) -&gt; StackNode(f hd, map f tl)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let rec rev s =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec loop acc = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; acc<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tl) -&gt; loop (StackNode(hd, acc)) tl<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop EmptyStack s<br>
				<br>
				&nbsp;&nbsp;&nbsp; let rec contains x = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; false<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tl) -&gt; hd = x || contains x tl<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let rec fold f seed = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; seed<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tl) -&gt; fold f (f seed hd) tl
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Queues
			</h2>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Naive Queue
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Queues aren't quite as straightforward as stacks. A naive queue can be implemented using a stack, with the caveat that that:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Items are always appended to the end of the list, and dequeued from the head of the stack.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">-OR- Items are prepended to the front of the stack, and dequeued by reversing the stack and getting its head.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				(* AwesomeCollections.fsi *)<br>
				<br>
				type 'a stack =<br>
				&nbsp; | EmptyStack<br>
				&nbsp; | StackNode of 'a * 'a stack<br>
				&nbsp;<br>
				module Stack = begin<br>
				&nbsp; val hd : 'a stack -&gt; 'a<br>
				&nbsp; val tl : 'a stack -&gt; 'a stack<br>
				&nbsp; val cons : 'a -&gt; 'a stack -&gt; 'a stack<br>
				&nbsp; val empty : 'a stack<br>
				&nbsp; val rev : 'a stack -&gt; 'a stack<br>
				end<br>
				<br>
				[&lt;Class&gt;]<br>
				type 'a Queue =<br>
				&nbsp;&nbsp;&nbsp; member hd : 'a<br>
				&nbsp;&nbsp;&nbsp; member tl : 'a Queue<br>
				&nbsp;&nbsp;&nbsp; member enqueue : 'a -&gt; 'a Queue<br>
				&nbsp;&nbsp;&nbsp; static member empty : 'a Queue
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				(* AwesomeCollections.fs *)<br>
				<br>
				type 'a stack =<br>
				&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;&nbsp;&nbsp; | StackNode of 'a * 'a stack<br>
				&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<br>
				module Stack =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let hd = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; failwith "Empty stack"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tl) -&gt; hd<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let tl = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; failwith "Emtpy stack"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tl) -&gt; tl<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let cons hd tl = StackNode(hd, tl)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let empty = EmptyStack<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let rec rev s =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec loop acc = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; acc<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tl) -&gt; loop (StackNode(hd, acc)) tl<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop EmptyStack s<br>
				&nbsp; &nbsp;&nbsp;<br>
				type Queue&lt;'a&gt;(item : stack&lt;'a&gt;) =<br>
				&nbsp;&nbsp;&nbsp; member this.hd<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = Stack.hd (Stack.rev item)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.tl<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = Queue(item |&gt; Stack.rev |&gt; Stack.tl |&gt; Stack.rev)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.enqueue(x) = Queue(StackNode(x, item))<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; override this.ToString() = sprintf "%A" item<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; static member empty = Queue&lt;'a&gt;(Stack.empty)
			</p>
			<p class="TextBody">
				<span lang="EN-US">We use an interface file to hide the</span> <span class="Teletyped"><span lang="EN-US" style=''>Queue</span></span> <span lang="EN-US">class's constructor. Although this technically satisfies the function of a queue, every dequeue is an O(<em>n</em>) operation where <em>n</em> is the number of items in the queue. There are lots of variations on the same approach, but these are often not very practical in practice. We can certainly improve on the implementation of immutable queues.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Queue From Two Stacks
			</h3>
			<p class="TextBody">
				<span lang="EN-US">The implementation above isn't very efficient because it requires reversing our underlying data representation several times. Why not keep those reversed stacks around for future use? Rather than using one stack, we can have two stacks: a front stack</span> <span class="Teletyped"><span lang="EN-US" style=''>f</span></span> <span lang="EN-US">and a rear stack</span> <span class="Teletyped"><span lang="EN-US" style=''>r</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Stack</span> <span class="Teletyped"><span lang="EN-US" style=''>f</span></span> <span lang="EN-US">holds items in the correct order, while stack</span> <span class="Teletyped"><span lang="EN-US" style=''>r</span></span> <span lang="EN-US">holds items in reverse order; this allows the first element in</span> <span class="Teletyped"><span lang="EN-US" style=''>f</span></span> <span lang="EN-US">to be the head of the queue, and the first element in</span> <span class="Teletyped"><span lang="EN-US" style=''>r</span></span> <span lang="EN-US">to be the last item in queue. So, a queue of the numbers 1 .. 6 might be represented with</span> <span class="Teletyped"><span lang="EN-US" style=''>f = [1;2;3]</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>r = [6;5;4]</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">To enqueue a new item, prepend it to the front of</span> <span class="Teletyped"><span lang="EN-US" style=''>r</span></span><span lang="EN-US">; to dequeue an item, pop it off</span> <span class="Teletyped"><span lang="EN-US" style=''>f</span></span><span lang="EN-US">. Both enqueues and dequeues are O(1) operations. Of course, at some point,</span> <span class="Teletyped"><span lang="EN-US" style=''>f</span></span> <span lang="EN-US">will be empty and there will be no more items to dequeue; in this case, simply move all items from</span> <span class="Teletyped"><span lang="EN-US" style=''>r</span></span> <span lang="EN-US">to</span> <span class="Teletyped"><span lang="EN-US" style=''>f</span></span> <span lang="EN-US">and reverse the list. While the queue certainly has O(n) worst-case behavior, it has acceptable O(1) amortized (average case) bounds.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The code for this implementation is straight forward:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type Queue&lt;'a&gt;(f : stack&lt;'a&gt;, r : stack&lt;'a&gt;) =<br>
				&nbsp;&nbsp;&nbsp; let check = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack, r -&gt; Queue(Stack.rev r, EmptyStack)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | f, r -&gt; Queue(f, r)<br>
				<br>
				&nbsp;&nbsp;&nbsp; member this.hd =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match f with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; failwith "empty"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(hd, tl) -&gt; hd<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.tl =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match f, r with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack, _ -&gt; failwith "empty"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StackNode(x, f), r -&gt; check(f, r)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.enqueue(x) = check(f, StackNode(x, r))<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; static member empty = Queue&lt;'a&gt;(Stack.empty, Stack.empty)
			</p>
			<p class="TextBody">
				<span lang="EN-US">This is a simple, common, and useful implementation of an immutable queue. The magic is in the</span> <span class="Teletyped"><span lang="EN-US" style=''>check</span></span> <span lang="EN-US">function which maintains that</span> <span class="Teletyped"><span lang="EN-US" style=''>f</span></span> <span lang="EN-US">always contains items if they are available.</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Bold">Note:</span> The queue's periodic O(n) worst case behavior can give it unpredictable response times, especially in applications which rely heavily on persistence since its possible to hit the pathological case each time the queue is accessed. However, this particular implementation of queues is perfectly adequate for the vast majority of applications which do not require persistence or uniform response times.
			</p>
			<p class="TextBody">
				<span lang="EN-US">As shown above, we often want to wrap our underlying data structure in class for two reasons:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">To simplify the interface to the data structure. For example, clients neither know nor care that our queue uses two stacks; they only know that items in the queue obey the principle of first-in, first-out.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 2.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">To prevent clients from putting the underlying data in the data structure in an invalid state.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Beyond stacks, virtually all data structures are complex enough to require wrapping up class to hide away complex details from clients.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Binary Search Trees
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Binary search trees are similar to stacks, but each node points to two other nodes called the left and right child nodes:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type 'a tree =<br>
				&nbsp;&nbsp;&nbsp; | EmptyTree<br>
				&nbsp;&nbsp;&nbsp; | TreeNode of 'a * 'a tree * 'a tree
			</p>
			<p class="TextBody">
				<span lang="EN-US">Additionally, nodes in the tree are ordered in a particular way: each item in a tree is greater than all items in its left child node and less than all items in its right child node.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Since our tree is immutable, we "insert" into the tree by returning a brand new tree with the node inserted. This process is more efficient than it sounds: we copy nodes as we traverse down the tree, so we only copy nodes which are in the path of our node being inserted. Writing a binary search tree is relatively straightforward:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				(* AwesomeCollections.fsi *)<br>
				<br>
				[&lt;Class&gt;]<br>
				type 'a BinaryTree =<br>
				&nbsp;&nbsp;&nbsp; member hd : 'a<br>
				&nbsp;&nbsp;&nbsp; member exists : 'a -&gt; bool<br>
				&nbsp;&nbsp;&nbsp; member insert : 'a -&gt; 'a BinaryTree
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				(* AwesomeCollections.fs *)<br>
				<br>
				type 'a tree =<br>
				&nbsp;&nbsp;&nbsp; | EmptyTree<br>
				&nbsp;&nbsp;&nbsp; | TreeNode of 'a * 'a tree * 'a tree<br>
				&nbsp;&nbsp;&nbsp;<br>
				module Tree =<br>
				&nbsp;&nbsp;&nbsp; let hd = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyTree -&gt; failwith "empty"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | TreeNode(hd, l, r) -&gt; hd<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let rec exists item = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyTree -&gt; false<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | TreeNode(hd, l, r) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if hd = item then true<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif item &lt; hd then exists item l<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else exists item r<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let rec insert item = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyTree -&gt; TreeNode(item, EmptyTree, EmptyTree)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | TreeNode(hd, l, r) as node -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if hd = item then node<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif item &lt; hd then TreeNode(hd, insert item l, r)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else TreeNode(hd, l, insert item r)<br>
				&nbsp;&nbsp;&nbsp;<br>
				type 'a BinaryTree(inner : 'a tree) =<br>
				&nbsp;&nbsp;&nbsp; member this.hd = Tree.hd inner<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.exists item = Tree.exists item inner<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.insert item = BinaryTree(Tree.insert item inner)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.empty = BinaryTree&lt;'a&gt;(EmptyTree)
			</p>
			<p class="TextBody">
				<span lang="EN-US">We're using an interface and a wrapper class to hide the implementation details of the tree from the user, otherwise the user could construct a tree which invalidates the specific ordering rules used in the binary tree.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This implementation is simple and it allows us to add and lookup any item in the tree in O(log n) best case time. However, it suffers from a pathological case: if we add items in sorted order, or mostly sorted order, then the tree can become heavily unbalanced. For example, the following code:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				[1 .. 7] |&gt; Seq.fold (fun (t : BinaryTree&lt;_&gt;) x -&gt; t.insert(x)) BinaryTree.empty
			</p>
			<p class="TextBody">
				<span lang="EN-US">Results in this tree:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				1&nbsp;&nbsp; / \&nbsp; E&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp; E&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E &nbsp;&nbsp;E
			</p>
			<p class="TextBody">
				<span lang="EN-US">A tree like this isn't much better than our inefficient queue implementation above! Trees are most efficient when they have a minimum height and are as full as possible. Ideally, we'd like to represent the tree above as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				_ 4 _&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 3&nbsp;&nbsp; 5&nbsp;&nbsp; 7&nbsp;&nbsp; / \ / \ / \ / \&nbsp;&nbsp; E E E E E E E E
			</p>
			<p class="TextBody">
				<span lang="EN-US">The minimum height of the tree is ceiling(log n + 1), where n is the number of items in the list. When we insert items into the tree, we want the tree to balance itself to maintain the minimum height. There are a variety of self-balancing tree implementations, many of which are easy to implement as immutable data structures.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Red Black Trees
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Red-black trees are self-balancing trees which attach a "color" attribute to each node in the tree. In addition to the rules defining a binary search tree, red-black trees must maintain the following set of rules:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">A node is either red or black.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 2.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">The root node is always black.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 3.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">No red node has a red child.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 4.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Every simple path from a given node to any of its descendant leaves contains the same number of black nodes.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<img width="277" height="1" src="F_files/image004.gif" alt=" An example of a red-black tree"><br clear="all">
				<span lang="EN-US">We can augment our binary tree with a color field as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type color = R | B&nbsp;&nbsp;&nbsp;<br>
				type 'a tree =<br>
				&nbsp;&nbsp;&nbsp; | E<br>
				&nbsp;&nbsp;&nbsp; | T of color * 'a * 'a tree * 'a tree
			</p>
			<p class="TextBody">
				<span lang="EN-US">When we insert into the tree, we need to rebalance the tree to restore the rules. In particular, we need to remove nodes with a red child. There are four cases cause a red node to have a red child:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				B(z)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R(x)&nbsp; d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp;&nbsp; R(y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B(z)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R(y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp; R(y)&nbsp; d&nbsp;&nbsp;&nbsp; =&gt;&nbsp;&nbsp;&nbsp;&nbsp; B(x) B(z)&nbsp;&nbsp;&nbsp; &lt;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp;&nbsp; R(y)&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp; R(x)&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a b&nbsp; c d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp; R(z)&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \ a&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;&nbsp;&nbsp; d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp;&nbsp; R(z)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R(y)&nbsp; d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp; c
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can modify our binary tree class as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				(* AwesomeCollections.fsi *)<br>
				<br>
				[&lt;Class&gt;]<br>
				type 'a BinaryTree =<br>
				&nbsp;&nbsp;&nbsp; member hd : 'a<br>
				&nbsp;&nbsp;&nbsp; member left : 'a BinaryTree<br>
				&nbsp;&nbsp;&nbsp; member right : 'a BinaryTree<br>
				&nbsp;&nbsp;&nbsp; member exists : 'a -&gt; bool<br>
				&nbsp;&nbsp;&nbsp; member insert : 'a -&gt; 'a BinaryTree<br>
				&nbsp;&nbsp;&nbsp; member print : unit -&gt; unit<br>
				&nbsp;&nbsp;&nbsp; static member empty : 'a BinaryTree
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				(* AwesomeCollections.fs *)<br>
				<br>
				type color = R | B&nbsp;&nbsp;&nbsp;<br>
				type 'a tree =<br>
				&nbsp;&nbsp;&nbsp; | E<br>
				&nbsp;&nbsp;&nbsp; | T of color * 'a tree * 'a * 'a tree<br>
				&nbsp;&nbsp;&nbsp;<br>
				module Tree =<br>
				&nbsp;&nbsp;&nbsp; let hd = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | E -&gt; failwith "empty"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | T(c, l, x, r) -&gt; x<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let left = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | E -&gt; failwith "empty"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | T(c, l, x, r) -&gt; l<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let right = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | E -&gt; failwith "empty"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | T(c, l, x, r) -&gt; r<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let rec exists item = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | E -&gt; false<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | T(c, l, x, r) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if item = x then true<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif item &lt; x then exists item l<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else exists item r<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let balance = function&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(* Red nodes in relation to black root *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | B, T(R, T(R, a, x, b), y, c), z, d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* Left, left *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | B, T(R, a, x, T(R, b, y, c)), z, d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* Left, right *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | B, a, x, T(R, T(R, b, y, c), z, d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* Right, left *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | B, a, x, T(R, b, y, T(R, c, z, d))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* Right, right *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; T(R, T(B, a, x, b), y, T(B, c, z, d))<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | c, l, x, r -&gt; T(c, l, x, r)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let insert item tree =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec ins = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | E -&gt; T(R, E, item, E)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | T(c, a, y, b) as node -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if item = y then node<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif item &lt; y then balance(c, ins a, y, b)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else balance(c, a, y, ins b)<br>
				<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* Forcing root node to be black *)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match ins tree with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | E -&gt; failwith "Should never return empty from an insert"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | T(_, l, x, r) -&gt; T(B, l, x, r)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let rec print (spaces : int) = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | E -&gt; ()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | T(c, l, x, r) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print (spaces + 4) r<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "%s %A%A" (new System.String(' ', spaces)) c x<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print (spaces + 4) l<br>
				&nbsp;&nbsp;&nbsp;<br>
				type 'a BinaryTree(inner : 'a tree) =<br>
				&nbsp;&nbsp;&nbsp; member this.hd = Tree.hd inner<br>
				&nbsp;&nbsp;&nbsp; member this.left = BinaryTree(Tree.left inner)<br>
				&nbsp;&nbsp;&nbsp; member this.right = BinaryTree(Tree.right inner)<br>
				&nbsp;&nbsp;&nbsp; member this.exists item = Tree.exists item inner<br>
				&nbsp;&nbsp;&nbsp; member this.insert item = BinaryTree(Tree.insert item inner)<br>
				&nbsp;&nbsp;&nbsp; member this.print() = Tree.print 0 inner<br>
				&nbsp;&nbsp;&nbsp; static member empty = BinaryTree&lt;'a&gt;(E)
			</p>
			<p class="TextBody">
				<span lang="EN-US">All of the magic that makes this tree work happens in the</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>balance</span></span> <span lang="EN-US">function. We're not performing any terribly complicated transformations to the tree, yet it comes out relatively balanced (in fact, the maximum depth of this tree is 2 * ceiling(log n + 1) ).</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				AVL Trees
			</h3>
			<p class="TextBody">
				<span lang="EN-US">AVL trees are named after its two inventors, G.M. Adelson-Velskii and E.M. Landis. These trees are self-balancing because the heights of the two child subtrees of any node will only differ 0 or 1; therefore, these trees are said to be height-balanced.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">An empty node in a tree has a height of 0; non-empty nodes have a height &gt;= 1. We can store the height of each node in our tree definition:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type 'a tree =<br>
				&nbsp;&nbsp;&nbsp; | Node of int * 'a tree * 'a * 'a tree&nbsp; (* height, left child, value, right child *)<br>
				&nbsp;&nbsp;&nbsp; | Nil
			</p>
			<p class="TextBody">
				<span lang="EN-US">The height of any node is equal to</span> <span class="Teletyped"><span lang="EN-US" style=''>max(left height, right height) + 1</span></span><span lang="EN-US">. For convenience, we'll use the following constructor to create a tree node and initialize its height:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let height = function<br>
				&nbsp;&nbsp;&nbsp; | Node(h, _, _, _) -&gt; h<br>
				&nbsp;&nbsp;&nbsp; | Nil -&gt; 0<br>
				&nbsp;&nbsp;&nbsp;<br>
				let make l x r =<br>
				&nbsp;&nbsp;&nbsp; let h = 1 + max (height l) (height r)<br>
				&nbsp;&nbsp;&nbsp; Node(h, l, x ,r)
			</p>
			<p class="TextBody">
				<span lang="EN-US">Inserting into an AVL tree is very similar to inserting into an unbalanced binary tree with one exception: after we insert a node, we use a series of tree rotations to re-balance the tree. Each node has an implicit property, its <em>balance factor</em>, which refers to the left-child's height minus the right-child's height; a positive balance factor indicates the tree is weighted on the left, negative indicates the tree is weighted on the right, otherwise the tree is balanced.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We only need to rebalance the tree when balance factor for a node is +/-2. There are four scenarios which can cause our tree to become unbalanced:</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Left-left case</span></span><span lang="EN-US">: root balance factor = +2, left-childs balance factor = +1. Balanced by right-rotating the root node:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp; Root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; D&nbsp;&nbsp; Right rotation&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -----&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp; / \&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp; B C&nbsp;&nbsp; D&nbsp; / \ A&nbsp;&nbsp; B
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Left-right case</span></span><span lang="EN-US">: root balance factor = +2, right-child's balance factor = -1. Balanced by left-rotating the left child, then right-rotating the root (this operation is called a double right rotation):</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Left child&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; \&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D&nbsp;&nbsp;&nbsp;&nbsp; Left rotation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Right rotation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -----&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -----&gt;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/ \&nbsp;&nbsp; / \ A&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A&nbsp;&nbsp; B C&nbsp;&nbsp; D&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp; B&nbsp;&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A&nbsp;&nbsp; B
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Right-right case</span></span><span lang="EN-US">: root balance factor = -2, right-child's balance factor = -1. Balanced by left-rotating the root node:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp; /&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; \ A&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Left rotation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -----&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp; B&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A&nbsp;&nbsp; B C&nbsp;&nbsp; D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C &nbsp;&nbsp;D
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Right-left case</span></span><span lang="EN-US">: root balance factor = -2, right-child's balance factor = +1. Balanced by right-rotating the right child, then left-rotating the root (this operation is called a double-left rotation):</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp; /&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Right child&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; \&nbsp; A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Right rotation&nbsp;&nbsp;&nbsp; A&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Left rotation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -----&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -----&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; D&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A&nbsp;&nbsp; B C&nbsp;&nbsp; D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp;&nbsp; B&nbsp;&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&nbsp;&nbsp; D
			</p>
			<p class="TextBody">
				<span lang="EN-US">With this in mind, its very easy to put together the rest of our AVL tree:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				(* AwesomeCollections.fsi *)<br>
				[&lt;Class&gt;]<br>
				type 'a AvlTree =<br>
				&nbsp;&nbsp;&nbsp; member Height : int<br>
				&nbsp;&nbsp;&nbsp; member Left : 'a AvlTree<br>
				&nbsp;&nbsp;&nbsp; member Right : 'a AvlTree<br>
				&nbsp;&nbsp;&nbsp; member Value : 'a<br>
				&nbsp;&nbsp;&nbsp; member Insert : 'a -&gt; 'a AvlTree<br>
				&nbsp;&nbsp;&nbsp; member Contains : 'a -&gt; bool<br>
				<br>
				module AvlTree =<br>
				&nbsp;&nbsp;&nbsp; [&lt;GeneralizableValue&gt;]<br>
				&nbsp;&nbsp;&nbsp; val empty&lt;'a&gt; : AvlTree&lt;'a&gt;
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				(* AwesomeCollections.fs *)<br>
				<br>
				type 'a tree =<br>
				&nbsp;&nbsp;&nbsp; | Node of int * 'a tree * 'a * 'a tree<br>
				&nbsp;&nbsp;&nbsp; | Nil<br>
				&nbsp;&nbsp;&nbsp;<br>
				(*<br>
				&nbsp;&nbsp;&nbsp; Notation:<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h = height<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = left child<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = right child<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lh = left child's height<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lx = left child's value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ll = left child's left child<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lr = left child's right child<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rh = right child's height<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rx = right child's value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rl = right child's left child<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rr = right child's right child<br>
				*)<br>
				&nbsp;&nbsp;&nbsp;<br>
				let height = function<br>
				&nbsp;&nbsp;&nbsp; | Node(h, _, _, _) -&gt; h<br>
				&nbsp;&nbsp;&nbsp; | Nil -&gt; 0<br>
				&nbsp;&nbsp;&nbsp;<br>
				let make l x r =<br>
				&nbsp;&nbsp;&nbsp; let h = 1 + max (height l) (height r)<br>
				&nbsp;&nbsp;&nbsp; Node(h, l, x ,r)<br>
				<br>
				let rotRight = function<br>
				&nbsp;&nbsp;&nbsp; | Node(_, Node(_, ll, lx, lr), x, r) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let r' = make lr x r<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; make ll lx r'<br>
				&nbsp;&nbsp;&nbsp; | node -&gt; node<br>
				&nbsp;&nbsp;&nbsp;<br>
				let rotLeft = function<br>
				&nbsp;&nbsp;&nbsp; | Node(_, l, x, Node(_, rl, rx, rr)) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let l' = make l x rl<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; make l' rx rr<br>
				&nbsp;&nbsp;&nbsp; | node -&gt; node<br>
				&nbsp;&nbsp;&nbsp;<br>
				let doubleRotLeft = function<br>
				&nbsp;&nbsp;&nbsp; | Node(h, l, x, r) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let r' = rotRight r<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let node' = make l x r'<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rotLeft node'<br>
				&nbsp;&nbsp;&nbsp; | node -&gt; node<br>
				&nbsp;&nbsp;&nbsp;<br>
				let doubleRotRight = function<br>
				&nbsp;&nbsp;&nbsp; | Node(h, l, x, r) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let l' = rotLeft l<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let node' = make l' x r<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rotRight node'<br>
				&nbsp;&nbsp;&nbsp; | node -&gt; node<br>
				&nbsp;&nbsp;&nbsp;<br>
				let balanceFactor = function<br>
				&nbsp;&nbsp;&nbsp; | Nil -&gt; 0<br>
				&nbsp;&nbsp;&nbsp; | Node(_, l, _, r) -&gt; (height l) - (height r)<br>
				&nbsp;&nbsp;&nbsp;<br>
				let balance = function<br>
				&nbsp;&nbsp;&nbsp; (* left unbalanced *)<br>
				&nbsp;&nbsp;&nbsp; | Node(h, l, x, r) as node when balanceFactor node &gt;= 2 -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if balanceFactor l &gt;= 1 then rotRight node&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* left left case *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else doubleRotRight node&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* left right case *)<br>
				&nbsp;&nbsp;&nbsp; (* right unbalanced *)<br>
				&nbsp;&nbsp;&nbsp; | Node(h, l, x, r) as node when balanceFactor node &lt;= -2 -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if balanceFactor r &lt;= -1 then rotLeft node&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* right right case *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else doubleRotLeft node&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* right left case *)<br>
				&nbsp;&nbsp;&nbsp; | node -&gt; node<br>
				&nbsp;&nbsp;&nbsp;<br>
				let rec insert v = function<br>
				&nbsp;&nbsp;&nbsp; | Nil -&gt; Node(1, Nil, v, Nil)<br>
				&nbsp;&nbsp;&nbsp; | Node(_, l, x, r) as node -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if v = x then node<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let l', r' = if v &lt; x then insert v l, r else l, insert v r<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let node' = make l' x r'<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; balance &lt;| node'<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let rec contains v = function<br>
				&nbsp;&nbsp;&nbsp; | Nil -&gt; false<br>
				&nbsp;&nbsp;&nbsp; | Node(_, l, x, r) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;if v = x then true<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if v &lt; x then contains v l<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else contains v r<br>
				<br>
				type 'a AvlTree(tree : 'a tree) =<br>
				&nbsp;&nbsp;&nbsp; member this.Height = height tree<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Left =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match tree with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Node(_, l, _, _) -&gt; new AvlTree&lt;'a&gt;(l)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Nil -&gt; failwith "Empty tree"<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Right =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match tree with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Node(_, _, _, r) -&gt; new AvlTree&lt;'a&gt;(r)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Nil -&gt; failwith "Empty tree"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Value =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match tree with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Node(_, _, x, _) -&gt; x<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Nil -&gt; failwith "Empty tree"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Insert(x) = new AvlTree&lt;'a&gt;(insert x tree)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Contains(v) = contains v tree<br>
				&nbsp;&nbsp;&nbsp;<br>
				module AvlTree =<br>
				&nbsp;&nbsp;&nbsp; [&lt;GeneralizableValue&gt;]<br>
				&nbsp;&nbsp;&nbsp; let empty&lt;'a&gt; : AvlTree&lt;'a&gt; = new AvlTree&lt;'a&gt;(Nil)
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Bold">Note:</span> The <span class="Teletyped"><span style=''>[&lt;GeneralizableValue&gt;]</span></span> attribute indicates to F# that the construct can give rise to generic code through type inference . Without the attribute, F# will infer the type of <span class="Teletyped"><span style=''>AvlTree.empty</span></span> as the undefined type <span class="Teletyped"><span style=''>AvlTree&lt;'_a&gt;</span></span>, resulting in a "value restriction" error at compilation.
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Bold">Optimization tip:</span> The tree supports inserts and lookups in <span class="Teletyped"><span style=''>log(n)</span></span> time, where <span class="Teletyped"><span style=''>n</span></span> is the number of nodes in the tree. This is already pretty good, but we can make it faster by eliminating unnecessary comparisons. Notice when we insert a node into the left side of the tree, we can only add weight to the left child; however, the <span class="Teletyped"><span style=''>balance</span></span> function checks both sides of the tree for each insert. By re-writing <span class="Teletyped"><span style=''>balance</span></span> into a <span class="Teletyped"><span style=''>balance_left</span></span> and <span class="Teletyped"><span style=''>balance_right</span></span> function to handle, we can handle left- and right-child inserts separately. Similar optimizations are possible on the red-black tree implementation as well.
			</p>
			<p class="TextBody">
				<span lang="EN-US">An AVL trees height is limited to</span> <span class="Teletyped"><span lang="EN-US" style=''>1.44 * log(n)</span></span><span lang="EN-US">, whereas a red-black tree's height is limited to</span> <span class="Teletyped"><span lang="EN-US" style=''>2 * log(n)</span></span><span lang="EN-US">. The AVL trees smaller height and more rigid balancing leads to slower insert/removal but faster retrieval than red-black trees. In practice, the difference will be hardly noticeable: a lookup on a 10,000,000 node AVL tree lookup requires at most 34 comparisons, compared to 47 comparisons on a red-black tree.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Heaps
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Binary search trees can efficiently find arbitrary elements in a set, however it can be occasionally useful to access the <em>minimum</em> element in set. Heaps are special data structure which satisfy the <em>heap property</em>: the value of every node is greater than the value of any of its child nodes. Additionally, we can keep the tree approximately balanced using the <em>leftist property</em>, meaning that the height of any left child heap is at least as large as its right sibling. We can hold the height of each tree in each heap node.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Finally, since heaps can be implemented as min- or max-heaps, where the root element will either be the largest or smallest element in the set, we support both types of heaps by passing in an ordering function into heap's constructor as such:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type 'a heap =<br>
				&nbsp;&nbsp;&nbsp; | EmptyHeap<br>
				&nbsp;&nbsp;&nbsp; | HeapNode of int * 'a * 'a heap * 'a heap<br>
				&nbsp;&nbsp;&nbsp;<br>
				type 'a BinaryHeap(comparer : 'a -&gt; 'a -&gt; int, inner : 'a heap) =<br>
				&nbsp;&nbsp;&nbsp; static member make(comparer) = BinaryHeap&lt;_&gt;(comparer, EmptyHeap)
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Bold">Note:</span> the functionality we gain by passing the <span class="Teletyped"><span style=''>comparer</span></span> function into the <span class="Teletyped"><span style=''>BinaryHeap</span></span> constructor approximates OCaml functors, although its not quite as elegant.
			</p>
			<p class="TextBody">
				<span lang="EN-US">An interesting consequence of the leftist property is that elements along any path in a heap are stored in sorted order. This means we can merge any two heaps by merging their right spines and swapping children as necessary to restore the leftist property. Since each right spine contains at least as many nodes as the left spine, the height of each right spine is proportional to the logarithm of the number of elements in the heap, so merging two heaps can be performed in O(log n) time. We can implement all of the properties of our heap as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				(* AwesomeCollections.fsi *)<br>
				<br>
				[&lt;Class&gt;]<br>
				type 'a BinaryHeap =<br>
				&nbsp;&nbsp;&nbsp; member hd : 'a<br>
				&nbsp;&nbsp;&nbsp; member tl : 'a BinaryHeap<br>
				&nbsp;&nbsp;&nbsp; member insert : 'a -&gt; 'a BinaryHeap<br>
				&nbsp;&nbsp;&nbsp; member merge : 'a BinaryHeap -&gt; 'a BinaryHeap<br>
				&nbsp;&nbsp;&nbsp; interface System.Collections.IEnumerable<br>
				&nbsp;&nbsp;&nbsp; interface System.Collections.Generic.IEnumerable&lt;'a&gt;<br>
				&nbsp;&nbsp;&nbsp; static member make : ('b -&gt; 'b -&gt; int) -&gt; 'b BinaryHeap
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				(* AwesomeCollections.fs *)<br>
				<br>
				type 'a heap =<br>
				&nbsp;&nbsp;&nbsp; | EmptyHeap<br>
				&nbsp;&nbsp;&nbsp; | HeapNode of int * 'a * 'a heap * 'a heap<br>
				&nbsp;<br>
				module Heap =<br>
				&nbsp;&nbsp;&nbsp; let height = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyHeap -&gt; 0<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | HeapNode(h, _, _, _) -&gt; h<br>
				&nbsp;<br>
				&nbsp;&nbsp;&nbsp; (* Helper function to restore the leftist property *)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let makeT (x, a, b) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if height a &gt;= height b then HeapNode(height b + 1, x, a, b)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else HeapNode(height a + 1, x, b, a)<br>
				&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let rec merge comparer = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | x, EmptyHeap -&gt; x<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyHeap, x -&gt; x<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (HeapNode(_, x, l1, r1) as h1), (HeapNode(_, y, l2, r2) as h2) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if comparer x y &lt;= 0 then makeT(x, l1, merge comparer (r1, h2))<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else makeT (y, l2, merge comparer (h1, r2))<br>
				&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let hd = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyHeap -&gt; failwith "empty"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | HeapNode(h, x, l, r) -&gt; x<br>
				&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let tl comparer = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyHeap -&gt; failwith "empty"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | HeapNode(h, x, l, r) -&gt; merge comparer (l, r)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let rec to_seq comparer = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyHeap -&gt; Seq.empty<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | HeapNode(h, x, l, r) as node -&gt; seq { yield x; yield! to_seq comparer (tl comparer node) }<br>
				&nbsp;<br>
				type 'a BinaryHeap(comparer : 'a -&gt; 'a -&gt; int, inner : 'a heap) =<br>
				&nbsp;&nbsp;&nbsp; (* private *)<br>
				&nbsp;&nbsp;&nbsp; member this.inner = inner<br>
				&nbsp;<br>
				&nbsp;&nbsp;&nbsp; (* public *)<br>
				&nbsp;&nbsp;&nbsp; member this.hd = Heap.hd inner<br>
				&nbsp;&nbsp;&nbsp; member this.tl = BinaryHeap(comparer, Heap.tl comparer inner)<br>
				&nbsp;&nbsp;&nbsp; member this.merge (other : BinaryHeap&lt;_&gt;) = BinaryHeap(comparer, Heap.merge comparer (inner, other.inner))<br>
				&nbsp;&nbsp;&nbsp; member this.insert x = BinaryHeap(comparer, Heap.merge comparer (inner,(HeapNode(1, x, EmptyHeap, EmptyHeap))))<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; interface System.Collections.Generic.IEnumerable&lt;'a&gt; with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.GetEnumerator() = (Heap.to_seq comparer inner).GetEnumerator()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; interface System.Collections.IEnumerable with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.GetEnumerator() = (Heap.to_seq comparer inner :&gt; System.Collections.IEnumerable).GetEnumerator()<br>
				&nbsp;<br>
				&nbsp;&nbsp;&nbsp; static member make(comparer) = BinaryHeap&lt;_&gt;(comparer, EmptyHeap)
			</p>
			<p class="TextBody">
				<span lang="EN-US">This heap implements the</span> <span class="Teletyped"><span lang="EN-US" style=''>IEnumerable&lt;'a&gt;</span></span> <span lang="EN-US">interface, allowing us to iterate through it like a</span> <span class="Teletyped"><span lang="EN-US" style=''>seq</span></span><span lang="EN-US">. In addition to the leftist heap shown above, its very easy to implement immutable versions of splay heaps, binomial heaps, Fibonacci heaps, pairing heaps, and a variety other tree-like data structures in F#.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Lazy Data Structures
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Its worth noting that some purely functional data structures above are not as efficient as their imperative implementations. For example, appending two immutable stacks</span> <span class="Teletyped"><span lang="EN-US" style=''>x</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>y</span></span> <span lang="EN-US">together takes O(<em>n</em>) time, where <em>n</em> is the number of elements in stack</span> <span class="Teletyped"><span lang="EN-US" style=''>x</span></span><span lang="EN-US">. However, we can exploit <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Caching%23Lazy_Values"><span style='color:windowtext;text-decoration:none'>laziness</span></a> in ways which make purely functional data structures just as efficient as their imperative counterparts.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">For example, its easy to create a stack-like data structure which delays all computation until its really needed:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type 'a lazyStack =<br>
				&nbsp;&nbsp;&nbsp; | Node of Lazy&lt;'a * 'a lazyStack&gt;<br>
				&nbsp;&nbsp;&nbsp; | EmptyStack<br>
				&nbsp;<br>
				module LazyStack =<br>
				&nbsp;&nbsp;&nbsp; let (|Cons|Nil|) = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Node(item) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let hd, tl = item.Force()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cons(hd, tl)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EmptyStack -&gt; Nil<br>
				&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let hd = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Cons(hd, tl) -&gt; hd<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Nil -&gt; failwith "empty"<br>
				&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let tl = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Cons(hd, tl) -&gt; tl<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Nil -&gt; failwith "empty"<br>
				&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let cons(hd, tl) = Node(lazy(hd, tl))<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let empty = EmptyStack<br>
				&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let rec append x y =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match x with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Cons(hd, tl) -&gt; Node(lazy(printfn "appending... got %A" hd; hd, append tl y))<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Nil -&gt; y<br>
				&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let rec iter f = function<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Cons(hd, tl) -&gt; f(hd); iter f tl<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Nil -&gt; ()
			</p>
			<p class="TextBody">
				<span lang="EN-US">In the example above, the</span> <span class="Teletyped"><span lang="EN-US" style=''>append</span></span> <span lang="EN-US">operation returns one node delays the rest of the computation, so appending two lists will occur in constant time. A</span> <span class="Teletyped"><span lang="EN-US" style=''>printfn</span></span> <span lang="EN-US">statement above has been added to demonstrate that we really don't compute appended values until the first time they're accessed:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; open LazyStack;;<br>
				&gt; let x = cons(1, cons(2, cons(3, cons(4, EmptyStack))));;<br>
				<br>
				val x : int lazyStack = Node &lt;unevaluated&gt;<br>
				<br>
				&gt; let y = cons(5, cons(6, cons(7, EmptyStack)));;<br>
				<br>
				val y : int lazyStack = Node &lt;unevaluated&gt;<br>
				<br>
				&gt; let z = append x y;;<br>
				<br>
				val z : int lazyStack = Node &lt;unevaluated&gt;<br>
				<br>
				&gt; hd z;;<br>
				appending... got 1<br>
				val it : int = 1<br>
				<br>
				&gt; hd (tl (tl z) );;<br>
				appending... got 2<br>
				appending... got 3<br>
				val it : int = 3<br>
				<br>
				&gt; iter (fun x -&gt; printfn "%i" x) z;;<br>
				1<br>
				2<br>
				3<br>
				appending... got 4<br>
				4<br>
				5<br>
				6<br>
				7<br>
				val it : unit = ()
			</p>
			<p class="TextBody">
				<span lang="EN-US">Interestingly, the</span> <span class="Teletyped"><span lang="EN-US" style=''>append</span></span> <span lang="EN-US">method clearly runs in O(1) time because the actual appending operation is delayed until a user grabs the head of the list. At the same time, grabbing the head of the list may have the side effect of triggering, at most, one call to the append method without causing a monolithic rebuilding the rest of the data structure, so grabbing the head is itself an O(1) operation. This stack implementation supports supports constant-time consing and appending, and linear time lookups.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Similarly, implementations of lazy queues exists which support O(1) worst-case behavior for all operations.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Additional Resources
			</h2>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504"><span style='color:windowtext;text-decoration:none'>Purely Functional Data Structures</span></a> by Chris Okasaki. Highly recommended. Provides techniques and analysis of immutable data structures using SML.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://www.amazon.com/Algorithm-Design-Manual-Steve-Skiena/dp/0387948600"><span style='color:windowtext;text-decoration:none'>The Algorithm Design Manual</span></a> by Steven S. Skiena. Highly recommended. Provides language-agnostic description of a variety of algorithms, data structures, and techniques for solving hard problems in computer science.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Tutorial on immutable data structures using C#:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; a)&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/ericlippert/archive/2007/11/13/immutability-in-c-part-one-kinds-of-immutability.aspx"><span style='color:windowtext;text-decoration:none'>Kinds of Immutability</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; b)&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/ericlippert/archive/2007/12/04/immutability-in-c-part-two-a-simple-immutable-stack.aspx"><span style='color:windowtext;text-decoration:none'>A Simple Immutable Stack</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; c)&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/ericlippert/archive/2007/12/06/immutability-in-c-part-three-a-covariant-immutable-stack.aspx"><span style='color:windowtext;text-decoration:none'>A Covariant Immutable Stack</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; d)&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/ericlippert/archive/2007/12/10/immutability-in-c-part-four-an-immutable-queue.aspx"><span style='color:windowtext;text-decoration:none'>An Immutable Queue</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; e)&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/ericlippert/archive/2007/12/13/immutability-in-c-part-five-lolz.aspx"><span style='color:windowtext;text-decoration:none'>LOLZ!</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; f)&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/ericlippert/archive/2007/12/18/immutability-in-c-part-six-a-simple-binary-tree.aspx"><span style='color:windowtext;text-decoration:none'>A Simple Binary Tree</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; g)&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/ericlippert/archive/2007/12/19/immutability-in-c-part-seven-more-on-binary-trees.aspx"><span style='color:windowtext;text-decoration:none'>More on Binary Trees</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; h)&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/ericlippert/archive/2008/01/18/immutability-in-c-part-eight-even-more-on-binary-trees.aspx"><span style='color:windowtext;text-decoration:none'>Even More on Binary Trees</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; i)&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx"><span style='color:windowtext;text-decoration:none'>AVL Tree Implementation</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; j)&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/ericlippert/archive/2008/01/22/immutability-in-c-part-10-a-double-ended-queue.aspx"><span style='color:windowtext;text-decoration:none'>A Double-ended Queue</span></a></span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; k)&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://blogs.msdn.com/ericlippert/archive/2008/02/12/immutability-in-c-part-eleven-a-working-double-ended-queue.aspx"><span style='color:windowtext;text-decoration:none'>A Working Double-ended Queue</span></a></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h1 class="HeadingArticle">
				Reflection
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Reflection</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Reflection</span></span> <span lang="EN-US">allows programmers to inspect types and invoke methods of objects at runtime without knowing their data type at compile time.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">At first glance, reflection seems to go against the spirit of ML as it is inherently not type-safe, so typing errors using reflection are not discovered until runtime. However, .NET's typing philosophy is best stated as <em>static typing where possible, dynamic typing when needed</em>, where reflection serves to bring in the most desirable behaviors of dynamic typing into the static typing world. In fact, dynamic typing can be a huge time saver, often promotes the design of more expressive APIs, and allows code to be refactored much further than possible with static typing.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This section is intended as a cursory overview of reflection, not a comprehensive tutorial.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Inspecting Types
			</h2>
			<p class="TextBody">
				<span lang="EN-US">There are a variety of ways to inspect the type of an object. The most direct way is calling the</span> <span class="Teletyped"><span lang="EN-US" style=''>.GetType()</span></span> <span lang="EN-US">method (inherited from</span> <span class="Teletyped"><span lang="EN-US" style=''>System.Object</span></span><span lang="EN-US">) on any non-null object:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; "hello world".GetType();;<br>
				val it : System.Type =<br>
				&nbsp; System.String<br>
				&nbsp;&nbsp;&nbsp; {Assembly = mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; AssemblyQualifiedName = "System.String, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";<br>
				&nbsp;&nbsp;&nbsp;&nbsp; Attributes = AutoLayout, AnsiClass, Class, Public, Sealed, Serializable, BeforeFieldInit;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; BaseType = System.Object;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; ContainsGenericParameters = false;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; DeclaringMethod = ?;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; DeclaringType = null;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; FullName = "System.String";<br>
				&nbsp;&nbsp;&nbsp;&nbsp; GUID = 296afbff-1b0b-3ff5-9d6c-4e7e599f8b57;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; GenericParameterAttributes = ?;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; GenericParameterPosition = ?;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; ...
			</p>
			<p class="TextBody">
				<span lang="EN-US">Its also possible to get type information without an actual object using the built-in</span> <span class="Teletyped"><span lang="EN-US" style=''>typeof</span></span><span lang="EN-US">method:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; typeof&lt;System.IO.File&gt;;;<br>
				val it : System.Type =<br>
				&nbsp; System.IO.File<br>
				&nbsp;&nbsp;&nbsp; {Assembly = mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; AssemblyQualifiedName = "System.IO.File, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";<br>
				&nbsp;&nbsp;&nbsp;&nbsp; Attributes = AutoLayout, AnsiClass, Class, Public, Abstract, Sealed, BeforeFieldInit;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; BaseType = System.Object;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; ContainsGenericParameters = false;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; DeclaringMethod = ?;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; DeclaringType = null;<br>
				&nbsp;&nbsp;&nbsp;&nbsp; FullName = "System.IO.File";<br>
				&nbsp;&nbsp;&nbsp;&nbsp; ...
			</p>
			<p class="TextBody">
				<em><span lang="EN-US">object</span></em><span class="Teletyped"><span lang="EN-US" style=''>.GetType</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>typeof</span></span> <span lang="EN-US">return an instance of</span> <span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/system.type_members.aspx"><span style='color:windowtext;text-decoration:none'>System.Type</span></a></span></span><span lang="EN-US">, which has a variety of useful properties such as:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Teletyped"><span lang="EN-US" style=''>val Name : string</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Returns the name of the type.
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Teletyped"><span lang="EN-US" style=''>val GetConstructors : unit -&gt; ConstructorInfo array</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Returns an array of constructors defined on the type.
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Teletyped"><span lang="EN-US" style=''>val GetMembers : unit -&gt; MemberInfo array</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Returns an array of members defined on the type.
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span class="Teletyped"><span lang="EN-US" style=''>val InvokeMember : (name : string, invokeAttr : BindingFlags, binder : Binder, target : obj, args : obj) -&gt; obj</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Invokes the specified member, using the specified binding constraints and matching the specified argument list
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Example: Reading Properties
			</h3>
			<p class="TextBody">
				<span lang="EN-US">The following program will print out the properties of any object passed into it:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type Car(make : string, model : string, year : int) =<br>
				&nbsp;&nbsp;&nbsp; member this.Make = make<br>
				&nbsp;&nbsp;&nbsp; member this.Model = model<br>
				&nbsp;&nbsp;&nbsp; member this.Year = year<br>
				&nbsp;&nbsp;&nbsp; member this.WheelCount = 4<br>
				&nbsp;&nbsp;&nbsp;<br>
				type Cat() =<br>
				&nbsp;&nbsp;&nbsp; let mutable age = 3<br>
				&nbsp;&nbsp;&nbsp; let mutable name = System.String.Empty<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Purr() = printfn "Purrr"<br>
				&nbsp;&nbsp;&nbsp; member this.Age<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = age<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(v) = age &lt;- v<br>
				&nbsp;&nbsp;&nbsp; member this.Name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with get() = name<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and set(v) = name &lt;- v<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				let printProperties x =<br>
				&nbsp;&nbsp;&nbsp; let t = x.GetType()<br>
				&nbsp;&nbsp;&nbsp; let properties = t.GetProperties()<br>
				&nbsp;&nbsp;&nbsp; printfn "-----------"<br>
				&nbsp;&nbsp;&nbsp; printfn "%s" t.FullName<br>
				&nbsp;&nbsp;&nbsp; properties |&gt; Array.iter (fun prop -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if prop.CanRead then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let value = prop.GetValue(x, null)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "%s: %O" prop.Name value<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "%s: ?" prop.Name)<br>
				<br>
				let carInstance = new Car("Ford", "Focus", 2009)<br>
				let catInstance =<br>
				&nbsp;&nbsp;&nbsp; let temp = new Cat()<br>
				&nbsp;&nbsp;&nbsp; temp.Name &lt;- "Mittens"<br>
				&nbsp;&nbsp;&nbsp; temp<br>
				&nbsp;&nbsp;&nbsp;<br>
				printProperties carInstance<br>
				printProperties catInstance
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				-----------Program+CarWheelCount: 4Year: 2009Model: FocusMake: Ford-----------Program+CatName: MittensAge: 3
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Example: Setting Private Fields
			</h3>
			<p class="TextBody">
				<span lang="EN-US">In addition to discovering types, we can dynamically invoke methods and set properties:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let dynamicSet x propName propValue =<br>
				&nbsp;&nbsp;&nbsp; let property = x.GetType().GetProperty(propName)<br>
				&nbsp;&nbsp;&nbsp; property.SetValue(x, propValue, null)
			</p>
			<p class="TextBody">
				<span lang="EN-US">Reflection is particularly remarkable in that it can read/write private fields, even on objects which appear to be immutable. In particular, we can explore and manipulate the underlying properties of an F# list:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; open System.Reflection<br>
				let x = [1;2;3;4;5]<br>
				let lastNode = x.Tail.Tail.Tail.Tail;;<br>
				<br>
				val x : int list = [1; 2; 3; 4; 5]<br>
				val lastNode : int list = [5]<br>
				<br>
				&gt; lastNode.GetType().GetFields(BindingFlags.NonPublic ||| BindingFlags.Instance) |&gt; Array.map (fun field -&gt; field.Name);;<br>
				val it : string array = [|"__Head"; "__Tail"|]<br>
				&gt; let tailField = lastNode.GetType().GetField("__Tail", BindingFlags.NonPublic ||| BindingFlags.Instance);;<br>
				<br>
				val tailField : FieldInfo =<br>
				&nbsp; Microsoft.FSharp.Collections.FSharpList`1[System.Int32] __Tail<br>
				<br>
				&gt; tailField.SetValue(lastNode, x);; (* circular list *)<br>
				val it : unit = ()<br>
				&gt; x |&gt; Seq.take 20 |&gt; Seq.to_list;;<br>
				val it : int list =<br>
				&nbsp; [1; 2; 3; 4; 5; 1; 2; 3; 4; 5; 1; 2; 3; 4; 5; 1; 2; 3; 4; 5]
			</p>
			<p class="TextBody">
				<span lang="EN-US">The example above mutates the list in place and to produce a circularly linked list. In .NET, "immutable" doesn't really mean <em>immutable</em> and private members are mostly an illusion.</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Bold">Note:</span> The power of reflection has definite security implications, but a full discussion of reflection security is far outside of the scope of this section. Readers are encouraged to visit the <a href="http://msdn.microsoft.com/en-us/library/stfy7tfc(VS.100).aspx"><span style='color:windowtext;text-decoration:none'>Security Considerations for Reflection</span></a> article on MSDN for more information.
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Microsoft.FSharp.Reflection Namespace
			</h2>
			<p class="TextBody">
				<span lang="EN-US">While .NET's built-in reflection API is useful, the F# compiler performs a lot of magic which makes built-in types like unions, tuples, functions, and other built-in types appear strange using vanilla reflection. The <a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/fsharp.core/microsoft.fsharp.reflection.html"><span style='color:windowtext;text-decoration:none'>Microsoft.FSharp.Reflection namespace</span></a> provides a wrapper for exploring F# types.</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				open System.Reflection<br>
				open Microsoft.FSharp.Reflection<br>
				<br>
				let explore x =<br>
				&nbsp;&nbsp;&nbsp; let t = x.GetType()<br>
				&nbsp;&nbsp;&nbsp; if FSharpType.IsTuple(t) then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let fields =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FSharpValue.GetTupleFields(x)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Array.map string<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; fun strings -&gt; System.String.Join(", ", strings)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "Tuple: (%s)" fields<br>
				&nbsp;&nbsp;&nbsp; elif FSharpType.IsUnion(t) then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let union, fields =&nbsp; FSharpValue.GetUnionFields(x, t)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "Union: %s(%A)" union.Name fields<br>
				&nbsp;&nbsp; &nbsp;else<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "Got another type"
			</p>
			<p class="TextBody">
				<span lang="EN-US">Using fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; explore (Some("Hello world"));;<br>
				Union: Some([|"Hello world"|])<br>
				val it : unit = ()<br>
				<br>
				&gt; explore (7, "Hello world");;<br>
				Tuple: (7, Hello world)<br>
				val it : unit = ()<br>
				<br>
				&gt; explore (Some("Hello world"));;<br>
				Union: Some([|"Hello world"|])<br>
				val it : unit = ()<br>
				<br>
				&gt; explore [1;2;3;4];;<br>
				Union: Cons([|1; [2; 3; 4]|])<br>
				val it : unit = ()<br>
				<br>
				&gt; explore "Hello world";;<br>
				Got another type
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Working With Attributes
			</h2>
			<p class="TextBody">
				<span lang="EN-US">.NET attributes and reflection go hand-in-hand. Attributes allow programmers to decorate classes, methods, members, and other source code with metadata used at runtime. Many .NET classes use attributes to annotate code in a variety of ways; it is only possible to access and interpret attributes through reflection. This section will provide a brief overview of attributes. Readers interested in a more complete overview are encouraged to read MSDN's <a href="http://msdn.microsoft.com/en-us/library/5x6cd29c(VS.100).aspx"><span style='color:windowtext;text-decoration:none'>Extending Metadata With Attributes</span></a> series.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Attributes are defined using</span> <span class="Teletyped"><span lang="EN-US" style=''>[&lt;AttributeName&gt;]</span></span><span lang="EN-US">, a notation already seen in a variety of places in previous chapters of this book. The .NET framework includes a number of built-in attributes, including:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://msdn.microsoft.com/en-us/library/system.obsoleteattribute.aspx"><span style='color:windowtext;text-decoration:none'>System.ObsoleteAttribute</span></a> - used to mark source code intended to be removed in future versions.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://msdn.microsoft.com/en-us/library/system.flagsattribute.aspx"><span style='color:windowtext;text-decoration:none'>System.FlagsAttribute</span></a> - indicates that an enumeration can be treated as a bit field.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://msdn.microsoft.com/en-us/library/system.serializableattribute.aspx"><span style='color:windowtext;text-decoration:none'>System.SerializableAttribute</span></a> - indicates that class can be serialized.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://msdn.microsoft.com/en-us/library/system.diagnostics.debuggerstepthroughattribute.aspx"><span style='color:windowtext;text-decoration:none'>System.Diagnostics.DebuggerStepThroughAttribute</span></a> - indicates that the debugger should not step into a method unless it contains a break point.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can create custom attributes by defining a new type which inherits from</span> <span class="Teletyped"><span lang="EN-US" style=''><a href="http://msdn.microsoft.com/en-us/library/system.attribute.aspx"><span style='color:windowtext;text-decoration:none'>System.Attribute</span></a></span></span><span lang="EN-US">:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type MyAttribute(text : string) =<br>
				&nbsp;&nbsp;&nbsp; inherit System.Attribute()<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; do printfn "MyAttribute created. Text: %s" text<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Text = text<br>
				<br>
				[&lt;MyAttribute("Hello world")&gt;]&nbsp;&nbsp;&nbsp;<br>
				type MyClass() =<br>
				&nbsp;&nbsp;&nbsp; member this.SomeProperty = "This is a property"
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can access attribute using reflection:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; let x = new MyClass();;<br>
				<br>
				val x : MyClass<br>
				<br>
				&gt; x.GetType().GetCustomAttributes(true);;<br>
				MyAttribute created. Text: Hello world<br>
				val it : obj [] =<br>
				&nbsp; [|System.SerializableAttribute {TypeId = System.SerializableAttribute;};<br>
				&nbsp;&nbsp;&nbsp; FSI_0028+MyAttribute {Text = "Hello world";<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TypeId = FSI_0028+MyAttribute;};<br>
				&nbsp;&nbsp;&nbsp; Microsoft.FSharp.Core.CompilationMappingAttribute<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {SequenceNumber = 0;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SourceConstructFlags = ObjectType;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TypeId = Microsoft.FSharp.Core.CompilationMappingAttribute;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VariantNumber = 0;}|]
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>MyAttribute</span></span><span lang="EN-US">class has the side-effect of printing to the console on instantiation, demonstrating that</span> <span class="Teletyped"><span lang="EN-US" style=''>MyAttribute</span></span> <span lang="EN-US">does not get constructed when instances of</span> <span class="Teletyped"><span lang="EN-US" style=''>MyClass</span></span> <span lang="EN-US">are created.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Example: Encapsulating Singleton Design Pattern
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Attributes are often used to decorate classes with any kind of ad-hoc functionality. For example, let's say we wanted to control whether single or multiple instances of classes are created based on an attribute:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type ConstructionAttribute(singleInstance : bool) =<br>
				&nbsp;&nbsp;&nbsp; inherit System.Attribute()<br>
				&nbsp;&nbsp;&nbsp; member this.IsSingleton = singleInstance<br>
				<br>
				let singletons = new System.Collections.Generic.Dictionary&lt;System.Type,obj&gt;()<br>
				let make() : 'a =<br>
				&nbsp;&nbsp;&nbsp; let newInstance() = System.Activator.CreateInstance&lt;'a&gt;()<br>
				&nbsp;&nbsp;&nbsp; let attributes = typeof&lt;'a&gt;.GetCustomAttributes(typeof&lt;ConstructionAttribute&gt;, true)<br>
				&nbsp;&nbsp;&nbsp; let singleInstance =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if attributes.Length &gt; 0 then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let contructionAttribute = attributes.[0] :?&gt; ConstructionAttribute<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; contructionAttribute.IsSingleton<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else false<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; if singleInstance then<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match singletons.TryGetValue(typeof&lt;'a&gt;) with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | true, v -&gt; v :?&gt; 'a<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | _ -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let instance = newInstance()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; singletons.Add(typeof&lt;'a&gt;, instance)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instance<br>
				&nbsp;&nbsp;&nbsp; else newInstance()<br>
				<br>
				[&lt;ConstructionAttribute(true)&gt;]<br>
				type SingleOnly() =<br>
				&nbsp;&nbsp;&nbsp; do printfn "SingleOnly contructor"<br>
				<br>
				[&lt;ConstructionAttribute(false)&gt;]<br>
				type NewAlways() =<br>
				&nbsp;&nbsp;&nbsp; do printfn "NewAlways constructor"<br>
				<br>
				let x = make&lt;SingleOnly&gt;()<br>
				let x' = make&lt;SingleOnly&gt;()<br>
				let y = make&lt;NewAlways&gt;()<br>
				let y' = make&lt;NewAlways&gt;()<br>
				<br>
				printfn "x = x': %b" (x = x')<br>
				printfn "y = y': %b" (y = y')<br>
				System.Console.ReadKey(true) |&gt; ignore
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				SingleOnly constructorNewAlways constructorNewAlways constructorx = x': truey = y': false
			</p>
			<p class="TextBody">
				<span lang="EN-US">Using the attribute above, we've completely abstracted away the implementation details of the singleton design pattern, reducing it down to a single attribute. Its worth noting that the program above hard-codes a value of</span> <span class="Teletyped"><span lang="EN-US" style=''>true</span></span> <span lang="EN-US">or</span> <span class="Teletyped"><span lang="EN-US" style=''>false</span></span> <span lang="EN-US">into the attribute constructor; if we wanted to, we could pass a string representing a key from the application's config file and make class construction dependent on the config file.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h1 class="HeadingArticle">
				Computation Expressions
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Computation Expressions</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Computation expressions</span></span> <span lang="EN-US">are easily the most difficult, yet most powerful language constructs to understand in F#.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Monad Primer
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Computation expressions are inspired by Haskell monads, which in turn are inspired by the mathematical concept of a monads in category theory. To avoid all of the abstract technical and mathematical theory underlying monads, a "monad" is, in very simple terms, a scary sounding word which means <em>execute this function and pass its return value to this other function</em>.</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Bold">Note:</span> The designers of F# use term "computation expression" and "workflow" because it's less obscure and daunting than the word "monad." The author of this book prefers "monad" because to emphasize the parallel between the F# and Haskell (and, strictly as an aside, its just a neat sounding five-dollar word).
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Monads in Haskell</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Haskell is interesting because it's a functional programming language where all statements are executed lazily, meaning Haskell doesn&rsquo;t compute values until they are actually needed. While this gives Haskell some unique features such as the capacity to define <a href="http://www.haskell.org/tutorial/functions.html#tut-infinite"><span style='color:windowtext;text-decoration:none'>"infinite" data structures</span></a>, it also makes it hard to reason about the execution of programs since you can't guarantee that lines of code will be executed in any particular order (if at all).</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Consequently, it's quite a challenge to do things which need to be executed in a sequence, which includes any form of I/O, acquiring locks objects in multithreaded code, reading/writing to sockets, and any conceivable action which has a side-effect on any memory elsewhere in our application. Haskell manages sequential operations using something called a monad, which can be used to simulate state in an immutable environment.</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Visualizing Monads with F#</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">To visualize monads, let's take some everyday F# code written in imperative style:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let read_line() = System.Console.ReadLine()<br>
				let print_string(s) = printf "%s" s<br>
				<br>
				print_string "What's your name? "<br>
				let name = read_line()<br>
				print_string ("Hello, " + name)
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can re-write the</span> <span class="Teletyped"><span lang="EN-US" style=''>read_line</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>print_string</span></span> <span lang="EN-US">functions to take an extra parameter, namely a function to execute once our computation completes. We&rsquo;d end up with something that looks more like this:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let read_line(f) = f(System.Console.ReadLine())<br>
				let print_string(s, f) = f(printf "%s" s)<br>
				<br>
				print_string("What's your name? ", fun () -&gt;<br>
				&nbsp;&nbsp;&nbsp; read_line(fun name -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_string("Hello, " + name, fun () -&gt; () ) ) )
			</p>
			<p class="TextBody">
				<span lang="EN-US">If you can understand this much, then you can understand any monad.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Of course, its perfectly reasonable to say <em>what masochistic reason would anyone have for writing code like that? All it does it print out "Hello, Steve" to the console!</em> After all, C#, Java, C++, or other languages we know and love execute code in exactly the order specified -- in other words, monads solve a problem in Haskell which simply doesn't exist in imperative languages. Consequently, the monad design pattern is virtually unknown in imperative languages.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">However, monads are occasionally useful for modeling computations which are difficult to capture in an imperative style.</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">The Maybe Monad</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">A well-known monad, the Maybe monad, represents a short-circuited computation which should "bail out" if any part of the computation fails. Using a simple example, let&rsquo;s say we wanted to write a function which asks the user for 3 integer inputs between 0 and 100 (inclusive) -- if at any point, the user enters an input which is non-numeric or falls out of our range, the entire computation should be aborted. Traditionally, we might represent this kind of program using the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let addThreeNumbers() =<br>
				&nbsp;&nbsp;&nbsp; let getNum msg =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf "%s" msg<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match System.Int32.TryParse(System.Console.ReadLine()) with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (true, n) when n &gt;= 0 &amp;&amp; n &lt;= 100 -&gt; Some(n)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | _ -&gt; None<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; match getNum "#1: " with<br>
				&nbsp;&nbsp;&nbsp; | Some(x) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match getNum "#2: " with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Some(y) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match getNum "#3: " with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Some(z) -&gt; Some(x + y + z)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None -&gt; None<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | None -&gt; None<br>
				&nbsp;&nbsp;&nbsp; | None -&gt; None
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Bold">Note:</span> Admittedly, the simplicity of this program -- grabbing a few integers -- is ridiculous, and there are many more concise ways to write this code by grabbing all of the values up front. However, it might help to imagine that <span class="Teletyped"><span style=''>getNum</span></span> was a relatively expensive operation (maybe it executes a query against a database, sends and receives data over a network, initializes a complex data structure), and the most efficient way to write this program requires us to bail out as soon on the <em>first</em> invalid value.
			</p>
			<p class="TextBody">
				<span lang="EN-US">This code is very ugly and redundant. However, we can simplify this code by converting it to monadic style:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let addThreeNumbers() =<br>
				&nbsp;&nbsp;&nbsp; let bind(input, rest) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match System.Int32.TryParse(input()) with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (true, n) when n &gt;= 0 &amp;&amp; n &lt;= 100 -&gt; rest(n)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | _ -&gt; None<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let createMsg msg = fun () -&gt; printf "%s" msg; System.Console.ReadLine()<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; bind(createMsg "#1: ", fun x -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bind(createMsg "#2: ", fun y -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bind(createMsg "#3: ", fun z -&gt; Some(x + y + z) ) ) )
			</p>
			<p class="TextBody">
				<span lang="EN-US">The magic is in the</span> <span class="Teletyped"><span lang="EN-US" style=''>bind</span></span> <span lang="EN-US">method. We extract the return value from our function</span> <span class="Teletyped"><span lang="EN-US" style=''>input</span></span> <span lang="EN-US">and pass it (or bind it) as the first parameter to</span> <span class="Teletyped"><span lang="EN-US" style=''>rest</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Why use monads?</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The code above is still quite extravagant and verbose for practical use, however monads are especially useful for modeling calculations which are difficult to capture sequentially. Multithreaded code, for example, is notoriously resistant to efforts to write in an imperative style; however it becomes remarkably concise and easy to write in monadic style. Let's modify our bind method above as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				open System.Threading<br>
				let bind(input, rest) =<br>
				&nbsp;&nbsp;&nbsp; ThreadPool.QueueUserWorkItem(new WaitCallback( fun _ -&gt; rest(input()) )) |&gt; ignore
			</p>
			<p class="TextBody">
				<span lang="EN-US">Now our bind method will execute a function in its own thread. Using monads, we can write multithreaded code in a safe, imperative style. Here's an example in fsi demonstrating this technique:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; open System.Threading<br>
				open System.Text.RegularExpressions<br>
				<br>
				let bind(input, rest) =<br>
				&nbsp;&nbsp;&nbsp; ThreadPool.QueueUserWorkItem(new WaitCallback( fun _ -&gt; rest(input()) )) |&gt; ignore<br>
				&nbsp;&nbsp;&nbsp;<br>
				let downloadAsync (url : string) =<br>
				&nbsp;&nbsp;&nbsp; let printMsg msg = printfn "ThreadID = %i, Url = %s, %s" (Thread.CurrentThread.ManagedThreadId) url msg<br>
				&nbsp;&nbsp;&nbsp; bind( (fun () -&gt; printMsg "Creating webclient..."; new System.Net.WebClient()), fun webclient -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bind( (fun () -&gt; printMsg "Downloading url..."; webclient.DownloadString(url)), fun html -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bind( (fun () -&gt; printMsg "Extracting urls..."; Regex.Matches(html, @"http://\S+") ), fun matches -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printMsg ("Found " + matches.Count.ToString() + " links")<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				["http://www.google.com/"; "http://microsoft.com/"; "http://www.wordpress.com/"; "http://www.peta.org"] |&gt; Seq.iter downloadAsync;;<br>
				<br>
				val bind : (unit -&gt; 'a) * ('a -&gt; unit) -&gt; unit<br>
				val downloadAsync : string -&gt; unit<br>
				<br>
				&gt;<br>
				ThreadID = 5, Url = http://www.google.com/, Creating webclient...<br>
				ThreadID = 11, Url = http://microsoft.com/, Creating webclient...<br>
				ThreadID = 5, Url = http://www.peta.org, Creating webclient...<br>
				ThreadID = 11, Url = http://www.wordpress.com/, Creating webclient...<br>
				ThreadID = 5, Url = http://microsoft.com/, Downloading url...<br>
				ThreadID = 11, Url = http://www.google.com/, Downloading url...<br>
				ThreadID = 11, Url = http://www.peta.org, Downloading url...<br>
				ThreadID = 13, Url = http://www.wordpress.com/, Downloading url...<br>
				ThreadID = 11, Url = http://www.google.com/, Extracting urls...<br>
				ThreadID = 11, Url = http://www.google.com/, Found 21 links<br>
				ThreadID = 11, Url = http://www.peta.org, Extracting urls...<br>
				ThreadID = 11, Url = http://www.peta.org, Found 111 links<br>
				ThreadID = 5, Url = http://microsoft.com/, Extracting urls...<br>
				ThreadID = 5, Url = http://microsoft.com/, Found 1 links<br>
				ThreadID = 13, Url = http://www.wordpress.com/, Extracting urls...<br>
				ThreadID = 13, Url = http://www.wordpress.com/, Found 132 links
			</p>
			<p class="TextBody">
				<span lang="EN-US">Its interesting to notice that Google starts downloading on thread 5 and finishes on thread 11. Additionally, thread 11 is shared between Microsoft, Peta, and Google at some point. Each time we call</span> <span class="Teletyped"><span lang="EN-US" style=''>bind</span></span><span lang="EN-US">, we pull a thread out of .NET's threadpool, when the function returns the thread is released back to the threadpool where another thread might pick it up again -- its wholly possible for async functions to hop between any number of threads throughout their lifetime.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This technique is so powerful that it's baked into F# library in the form of the <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Async_Workflows"><span style='color:windowtext;text-decoration:none'>async workflow</span></a>.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Defining Computation Expressions
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Computation expressions are fundamentally the same concept as seen above, although they hide the complexity of monadic syntax behind a thick layer of syntactic sugar. A monad is a special kind of class which must have the following methods:</span> <span class="Teletyped"><span lang="EN-US" style=''>Bind</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>Delay</span></span><span lang="EN-US">, and</span> <span class="Teletyped"><span lang="EN-US" style=''>Return</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can rewrite our Maybe monad described earlier as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type MaybeBuilder() =<br>
				&nbsp;&nbsp;&nbsp; member this.Bind(x, f) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match x with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Some(x) when x &gt;= 0 &amp;&amp; x &lt;= 100 -&gt; f(x)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | _ -&gt; None<br>
				&nbsp;&nbsp;&nbsp; member this.Delay(f) = f()<br>
				&nbsp;&nbsp;&nbsp; member this.Return(x) = Some x
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can test this class in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; type MaybeBuilder() =<br>
				&nbsp;&nbsp;&nbsp; member this.Bind(x, f) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "this.Bind: %A" x<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match x with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Some(x) when x &gt;= 0 &amp;&amp; x &lt;= 100 -&gt; f(x)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | _ -&gt; None<br>
				&nbsp;&nbsp;&nbsp; member this.Delay(f) = f()<br>
				&nbsp;&nbsp;&nbsp; member this.Return(x) = Some x<br>
				<br>
				let maybe = MaybeBuilder();;<br>
				<br>
				type MaybeBuilder =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; new : unit -&gt; MaybeBuilder<br>
				&nbsp;&nbsp;&nbsp; member Bind : x:int option * f:(int -&gt; 'a0 option) -&gt; 'a0 option<br>
				&nbsp;&nbsp;&nbsp; member Delay : f:(unit -&gt; 'a0) -&gt; 'a0<br>
				&nbsp;&nbsp;&nbsp; member Return : x:'a0 -&gt; 'a0 option<br>
				&nbsp; end<br>
				val maybe : MaybeBuilder<br>
				<br>
				&gt; maybe.Delay(fun () -&gt;<br>
				&nbsp;&nbsp;&nbsp; let x = 12<br>
				&nbsp;&nbsp;&nbsp; maybe.Bind(Some 11, fun y -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maybe.Bind(Some 30, fun z -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maybe.Return(x + y + z)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp; );;<br>
				this.Bind: Some 11<br>
				this.Bind: Some 30<br>
				val it : int option = Some 53<br>
				<br>
				&gt; maybe.Delay(fun () -&gt;<br>
				&nbsp;&nbsp;&nbsp; let x = 12<br>
				&nbsp;&nbsp;&nbsp; maybe.Bind(Some -50, fun y -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maybe.Bind(Some 30, fun z -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maybe.Return(x + y + z)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
				&nbsp;&nbsp;&nbsp; );;<br>
				this.Bind: Some -50<br>
				val it : int option = None
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Syntax Sugar
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Monads are powerful, but beyond two or three variables, the number of nested functions becomes cumbersome to work with. F# provides syntactic sugar which allows us to write the same code in a more readable fashion. Workflows are evaluated using the form</span> <span class="Teletyped"><span lang="EN-US" style=''>builder { comp-expr }</span></span><span lang="EN-US">. For example, the following pieces of code are equivalent:</span>
			</p>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Sugared syntax</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">De-sugared syntax</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
						<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
							let maybe = new MaybeBuilder()<br>
							let sugared =<br>
							&nbsp;&nbsp;&nbsp; maybe {<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let x = 12<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let! y = Some 11<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let! z = Some 30<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x + y + z<br>
							&nbsp;&nbsp;&nbsp; }
						</p>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
						<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
							let maybe = new MaybeBuilder()<br>
							let desugared =<br>
							&nbsp;&nbsp;&nbsp; maybe.Delay(fun () -&gt;<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let x = 12<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maybe.Bind(Some 11, fun y -&gt;<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maybe.Bind(Some 30, fun z -&gt;<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maybe.Return(x + y + z)<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
						</p>
						<p class="TextBody">
							<span lang="EN-US">&nbsp;</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Bold">Note:</span> You probably noticed that the sugared syntax is strikingly similar to the syntax used to declare <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Sequences"><span style='color:windowtext;text-decoration:none'>sequence expressions</span></a>, <span class="Teletyped"><span style=''>seq { expr }</span></span>. This is not a coincidence. In the F# library, sequences are defined as computation expressions and used as such. The <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Async_Workflows"><span style='color:windowtext;text-decoration:none'>async workflow</span></a> is another computation expression you'll encounter while learning F#.
			</p>
			<p class="TextBody">
				<span lang="EN-US">The sugared form reads like normal F#. The code</span> <span class="Teletyped"><span lang="EN-US" style=''>let x = 12</span></span> <span lang="EN-US">behaves as expected, but what is</span> <span class="Teletyped"><span lang="EN-US" style=''>let!</span></span> <span lang="EN-US">doing? Notice that we say</span> <span class="Teletyped"><span lang="EN-US" style=''>let! y = Some 11</span></span><span lang="EN-US">, but the value</span> <span class="Teletyped"><span lang="EN-US" style=''>y</span></span> <span lang="EN-US">has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>int</span></span> <span lang="EN-US">rather than</span> <span class="Teletyped"><span lang="EN-US" style=''>int option</span></span><span lang="EN-US">. The construct</span> <span class="Teletyped"><span lang="EN-US" style=''>let! y =</span></span> <em><span lang="EN-US">...</span></em> <span lang="EN-US">invokes a function called</span> <span class="Teletyped"><span lang="EN-US" style=''>maybe.Bind(x, f)</span></span><span lang="EN-US">, where the value</span> <span class="Teletyped"><span lang="EN-US" style=''>y</span></span> <span lang="EN-US">is bound to parameter passed into the</span> <span class="Teletyped"><span lang="EN-US" style=''>f</span></span> <span lang="EN-US">function.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Similarly,</span> <span class="Teletyped"><span lang="EN-US" style=''>return</span></span> <span class="Bold"><span lang="EN-US">...</span></span> <span lang="EN-US">invokes a function called</span> <span class="Teletyped"><span lang="EN-US" style=''>maybe.Return(x)</span></span><span lang="EN-US">. Several new keywords de-sugar to some other construct, including ones you've already seen in sequence expressions like</span> <span class="Teletyped"><span lang="EN-US" style=''>yield</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>yield!</span></span><span lang="EN-US">, as well as new ones like</span> <span class="Teletyped"><span lang="EN-US" style=''>use</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>use!</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">This fsi sample shows how easy it is to use our maybe monad with computation expression syntax:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; type MaybeBuilder() =<br>
				&nbsp;&nbsp;&nbsp; member this.Bind(x, f) =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "this.Bind: %A" x<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match x with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Some(x) when x &gt;= 0 &amp;&amp; x &lt;= 100 -&gt; f(x)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | _ -&gt; None<br>
				&nbsp;&nbsp;&nbsp; member this.Delay(f) = f()<br>
				&nbsp;&nbsp;&nbsp; member this.Return(x) = Some x<br>
				<br>
				let maybe = MaybeBuilder();;<br>
				<br>
				type MaybeBuilder =<br>
				&nbsp; class<br>
				&nbsp;&nbsp;&nbsp; new : unit -&gt; MaybeBuilder<br>
				&nbsp;&nbsp;&nbsp; member Bind : x:int option * f:(int -&gt; 'a0 option) -&gt; 'a0 option<br>
				&nbsp;&nbsp;&nbsp; member Delay : f:(unit -&gt; 'a0) -&gt; 'a0<br>
				&nbsp;&nbsp;&nbsp; member Return : x:'a0 -&gt; 'a0 option<br>
				&nbsp; end<br>
				val maybe : MaybeBuilder<br>
				<br>
				&gt; maybe {<br>
				&nbsp;&nbsp;&nbsp; let x = 12<br>
				&nbsp;&nbsp;&nbsp; let! y = Some 11<br>
				&nbsp;&nbsp;&nbsp; let! z = Some 30<br>
				&nbsp;&nbsp;&nbsp; return x + y + z<br>
				};;<br>
				this.Bind: Some 11<br>
				this.Bind: Some 30<br>
				val it : int option = Some 53<br>
				<br>
				&gt; maybe {<br>
				&nbsp;&nbsp;&nbsp; let x = 12<br>
				&nbsp;&nbsp;&nbsp; let! y = Some -50<br>
				&nbsp;&nbsp;&nbsp; let! z = Some 30<br>
				&nbsp;&nbsp;&nbsp; return x + y + z<br>
				};;<br>
				this.Bind: Some -50<br>
				val it : int option = None
			</p>
			<p class="TextBody">
				<span lang="EN-US">This code does the same thing as the desugared code, only its much much easier to read.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Dissecting Syntax Sugar
			</h3>
			<p class="TextBody">
				<span lang="EN-US">According the <a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec2.aspx#_Toc207785614"><span style='color:windowtext;text-decoration:none'>F# spec</span></a>, workflows may be defined with the following members:</span>
			</p>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Member</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Description</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>member Bind : M&lt;'a&gt; * ('a -&gt; M&lt;'b&gt;) -&gt; M&lt;'b&gt;</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Required member. Used to de-sugar</span> <span class="Teletyped"><span lang="EN-US" style=''>let!</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>do!</span></span> <span lang="EN-US">within computation expressions.</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>member Return : 'a -&gt; M&lt;'a&gt;</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Required member. Used to de-sugar</span> <span class="Teletyped"><span lang="EN-US" style=''>return</span></span> <span lang="EN-US">within computation expressions.</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>member Delay : (unit -&gt; M&lt;'a&gt;) -&gt; M&lt;'a&gt;</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Required member. Used to ensure side effects within a computation expression are performed when expected.</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>member Yield : 'a -&gt; M&lt;'a&gt;</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Optional member. Used to de-sugar</span> <span class="Teletyped"><span lang="EN-US" style=''>yield</span></span> <span lang="EN-US">within computation expressions.</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>member For : seq&lt;'a&gt; * ('a -&gt; M&lt;'b&gt;) -&gt; M&lt;'b&gt;</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Optional member. Used to de-sugar</span> <span class="Teletyped"><span lang="EN-US" style=''>for ... do ...</span></span> <span lang="EN-US">within computation expressions.</span> <span class="Teletyped"><span lang="EN-US" style=''>M&lt;'b&gt;</span></span> <span lang="EN-US">can optionally be</span> <span class="Teletyped"><span lang="EN-US" style=''>M&lt;unit&gt;</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>member While : (unit -&gt; bool) * M&lt;'a&gt; -&gt; M&lt;'a&gt;</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Optional member. Used to de-sugar</span> <span class="Teletyped"><span lang="EN-US" style=''>while ... do ...</span></span> <span lang="EN-US">within computation expressions.</span> <span class="Teletyped"><span lang="EN-US" style=''>M&lt;'b&gt;</span></span> <span lang="EN-US">can optionally be</span> <span class="Teletyped"><span lang="EN-US" style=''>M&lt;unit&gt;</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>member Using : 'a * ('a -&gt; M&lt;'b&gt;) -&gt; M&lt;'b&gt; when 'a :&gt; IDisposable</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Optional member. Used to de-sugar</span> <span class="Teletyped"><span lang="EN-US" style=''>use</span></span> <span lang="EN-US">bindings within computation expressions.</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>member Combine : M&lt;'a&gt; -&gt; M&lt;'a&gt; -&gt; M&lt;'a&gt;</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Optional member. Used to de-sugar sequencing within computation expressions. The first</span> <span class="Teletyped"><span lang="EN-US" style=''>M&lt;'a&gt;</span></span> <span lang="EN-US">can optionally be</span> <span class="Teletyped"><span lang="EN-US" style=''>M&lt;unit&gt;</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>member Zero : unit -&gt; M&lt;'a&gt;</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Optional member. Used to de-sugar empty</span> <span class="Teletyped"><span lang="EN-US" style=''>else</span></span> <span lang="EN-US">branches of</span> <span class="Teletyped"><span lang="EN-US" style=''>if/then</span></span> <span lang="EN-US">within computation expressions.</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>member TryWith : M&lt;'a&gt; -&gt; M&lt;'a&gt; -&gt; M&lt;'a&gt;</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Optional member. Used to de-sugar empty</span> <span class="Teletyped"><span lang="EN-US" style=''>try/with</span></span> <span lang="EN-US">bindings within computation expressions.</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>member TryFinally : M&lt;'a&gt; -&gt; M&lt;'a&gt; -&gt; M&lt;'a&gt;</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Optional member. Used to de-sugar</span> <span class="Teletyped"><span lang="EN-US" style=''>try/finally</span></span> <span lang="EN-US">bindings within computation expressions.</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">These sugared constructs are de-sugared as follows:</span>
			</p>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">Construct</span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">De-sugared Form</span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>let</span></span> <em><span lang="EN-US">pat</span></em> <span class="Teletyped"><span lang="EN-US" style=''>=</span></span> <em><span lang="EN-US">expr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>in</span></span> <em><span lang="EN-US">cexpr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>let</span></span> <em><span lang="EN-US">pat</span></em> <span class="Teletyped"><span lang="EN-US" style=''>=</span></span> <em><span lang="EN-US">expr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>in</span></span> <em><span lang="EN-US">cexpr</span></em>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>let!</span></span> <em><span lang="EN-US">pat</span></em> <span class="Teletyped"><span lang="EN-US" style=''>=</span></span> <em><span lang="EN-US">expr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>in</span></span> <em><span lang="EN-US">cexpr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>b.Bind(</span></span><em><span lang="EN-US">expr</span></em><span class="Teletyped"><span lang="EN-US" style=''>, (fun</span></span> <em><span lang="EN-US">pat</span></em> <span class="Teletyped"><span lang="EN-US" style=''>-&gt;</span></span> <em><span lang="EN-US">cexpr</span></em><span class="Teletyped"><span lang="EN-US" style=''>))</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>return</span></span> <em><span lang="EN-US">expr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>b.Return(</span></span><em><span lang="EN-US">expr</span></em><span class="Teletyped"><span lang="EN-US" style=''>)</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>return!</span></span> <em><span lang="EN-US">expr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>b.ReturnFrom(</span></span><em><span lang="EN-US">expr</span></em><span class="Teletyped"><span lang="EN-US" style=''>)</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>yield</span></span> <em><span lang="EN-US">expr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>b.Yield(</span></span><em><span lang="EN-US">expr</span></em><span class="Teletyped"><span lang="EN-US" style=''>)</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>yield!</span></span> <em><span lang="EN-US">expr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>b.YieldFrom(</span></span><em><span lang="EN-US">expr</span></em><span class="Teletyped"><span lang="EN-US" style=''>)</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>use</span></span> <em><span lang="EN-US">pat</span></em> <span class="Teletyped"><span lang="EN-US" style=''>=</span></span> <em><span lang="EN-US">expr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>in</span></span> <em><span lang="EN-US">cexpr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>b.Using(</span></span><em><span lang="EN-US">expr</span></em><span class="Teletyped"><span lang="EN-US" style=''>, (fun</span></span> <em><span lang="EN-US">pat</span></em> <span class="Teletyped"><span lang="EN-US" style=''>-&gt;</span></span> <em><span lang="EN-US">cexpr</span></em><span class="Teletyped"><span lang="EN-US" style=''>))</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>use!</span></span> <em><span lang="EN-US">pat</span></em> <span class="Teletyped"><span lang="EN-US" style=''>=</span></span> <em><span lang="EN-US">expr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>in</span></span> <em><span lang="EN-US">cexpr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>b.Bind(</span></span><em><span lang="EN-US">expr</span></em><span class="Teletyped"><span lang="EN-US" style=''>, (fun x -&gt; b.Using(x, fun</span></span> <em><span lang="EN-US">pat</span></em> <span class="Teletyped"><span lang="EN-US" style=''>-&gt;</span></span> <em><span lang="EN-US">cexpr</span></em><span class="Teletyped"><span lang="EN-US" style=''>))</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>do!</span></span> <em><span lang="EN-US">expr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>in</span></span> <em><span lang="EN-US">cexpr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>b.Bind(</span></span><em><span lang="EN-US">expr</span></em><span class="Teletyped"><span lang="EN-US" style=''>, (fun () -&gt;</span></span> <em><span lang="EN-US">cexpr</span></em><span class="Teletyped"><span lang="EN-US" style=''>))</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>for</span></span> <em><span lang="EN-US">pat</span></em> <span class="Teletyped"><span lang="EN-US" style=''>in</span></span> <em><span lang="EN-US">expr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>do</span></span> <em><span lang="EN-US">cexpr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>b.For(</span></span><em><span lang="EN-US">expr</span></em><span class="Teletyped"><span lang="EN-US" style=''>, (fun</span></span> <em><span lang="EN-US">pat</span></em> <span class="Teletyped"><span lang="EN-US" style=''>-&gt;</span></span> <em><span lang="EN-US">cexpr</span></em><span class="Teletyped"><span lang="EN-US" style=''>))</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>while</span></span> <em><span lang="EN-US">expr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>do</span></span> <em><span lang="EN-US">cexpr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>b.While((fun () -&gt;</span></span> <em><span lang="EN-US">expr</span></em><span class="Teletyped"><span lang="EN-US" style=''>), b.Delay( fun () -&gt;</span></span> <em><span lang="EN-US">cexpr</span></em><span class="Teletyped"><span lang="EN-US" style=''>))</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>if</span></span> <em><span lang="EN-US">expr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>then</span></span> <em><span lang="EN-US">cexpr1</span></em> <span class="Teletyped"><span lang="EN-US" style=''>else</span></span> <em><span lang="EN-US">cexpr2</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>if</span></span> <em><span lang="EN-US">expr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>then</span></span> <em><span lang="EN-US">cexpr1</span></em> <span class="Teletyped"><span lang="EN-US" style=''>else</span></span> <em><span lang="EN-US">cexpr2</span></em>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>if</span></span> <em><span lang="EN-US">expr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>then</span></span> <em><span lang="EN-US">cexpr</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>if</span></span> <em><span lang="EN-US">expr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>then</span></span> <em><span lang="EN-US">cexpr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>else b.Zero()</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">cexpr1</span></em><span class="Teletyped"><span lang="EN-US" style=''><br></span></span> <em><span lang="EN-US">cexpr2</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>b.Combine(</span></span><em><span lang="EN-US">cexpr1</span></em><span class="Teletyped"><span lang="EN-US" style=''>, b.Delay(fun () -&gt;</span></span> <em><span lang="EN-US">cexpr2</span></em><span class="Teletyped"><span lang="EN-US" style=''>))</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>try</span></span> <em><span lang="EN-US">cexpr</span></em> <span class="Teletyped"><span lang="EN-US" style=''>with</span></span> <em><span lang="EN-US">patn</span></em> <span class="Teletyped"><span lang="EN-US" style=''>-&gt;</span></span> <em><span lang="EN-US">cexprn</span></em>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>b.TryWith(</span></span><em><span lang="EN-US">expr</span></em><span class="Teletyped"><span lang="EN-US" style=''>, fun v -&gt; match v with</span></span> <em><span lang="EN-US">(patn:ext)</span></em> <span class="Teletyped"><span lang="EN-US" style=''>-&gt;</span></span> <em><span lang="EN-US">cexprn</span></em> <span class="Teletyped"><span lang="EN-US" style=''>| _ raise exn)</span></span>
						</p>
					</td>
				</tr>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<em><span lang="EN-US">try</span></em> <span class="Teletyped"><span lang="EN-US" style=''>cexpr</span></span> <em><span lang="EN-US">finally</span></em> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>expr</span></span>
						</p>
					</td>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>b.TryFinally(</span></span><em><span lang="EN-US">cexpr</span></em><span class="Teletyped"><span lang="EN-US" style=''>, (fun () -&gt;</span></span> <em><span lang="EN-US">expr</span></em><span class="Teletyped"><span lang="EN-US" style=''>))</span></span>
						</p>
					</td>
				</tr>
			</table>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				What are Computation Expressions Used For?
			</h2>
			<p class="TextBody">
				<span lang="EN-US">F# encourages of a programming style called <em>language oriented programming</em> to solve problems. In contrast to general purpose programming style, language oriented programming centers around the programmers identifying problems they want to solve, then writing domain specific mini-languages to tackle the problem, and finally solve problem in the new mini-language.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Computation expressions are one of several tools F# programmers have at their disposal for designing mini-languages. Its surprising how often computation expressions and monad-like constructs occur in practice. For example, the <a href="http://spbhug.folding-maps.org/wiki/MonadsEn"><span style='color:windowtext; text-decoration:none'>Haskell User Group</span></a> has a collection of common and uncommon monads, including those which compute distributions of integers and parse text. Another significant example, an F# implementation of software transactional memory, is available on <a href="http://cs.hubfs.net/blogs/hell_is_other_languages/archive/2008/01/16/4565.aspx"><span style='color:windowtext;text-decoration:none'>hubFS</span></a>.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Additional Resources
			</h2>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US"><a href="http://www.haskell.org/haskellwiki/All_About_Monads"><span style='color:windowtext;text-decoration:none'>Haskell.org: All About Monads</span></a> - Another collection of monads in Haskell.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h1 class="HeadingArticle">
				Async Workflows
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Async Workflows</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<em><span lang="EN-US">Async workflows</span></em> <span lang="EN-US">allow programmers to convert single-threaded code into multi-threaded code with minimal code changes.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Defining Async Workflows
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Async workflows are defined using <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Computation_Expressions%23Defining_Computation_Expressions"><span style='color:windowtext;text-decoration:none'>computation expression notation</span></a>:</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>async { comp-exprs }</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here's an example using fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; let asyncAdd x y = async { return x + y };;<br>
				<br>
				val asyncAdd : int -&gt; int -&gt; Async&lt;int&gt;
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice the return type of</span> <span class="Teletyped"><span lang="EN-US" style=''>asyncAdd</span></span><span lang="EN-US">. It does not actually run a function; instead, it returns an</span> <span class="Teletyped"><span lang="EN-US" style=''>async&lt;int&gt;</span></span><span lang="EN-US">, which is a special kind of wrapper around our function.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				The Async Module
			</h3>
			<p class="TextBody">
				<span lang="EN-US">The <a href="http://msdn.microsoft.com/en-us/library/ee370232.aspx"><span style='color:windowtext;text-decoration:none'>Async Module</span></a> is used for operating on</span> <span class="Teletyped"><span lang="EN-US" style=''>async&lt;'a&gt;</span></span><span lang="EN-US">objects. It contains several useful methods including, the most important of which are:</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>member RunSynchronously : computation:Async&lt;'T&gt; * ?timeout:int -&gt; 'T</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Run the asynchronous computation and await its result. If an exception occurs in the asynchronous computation then an exception is re-raised by this function. Run as part of the default AsyncGroup.
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>member Parallel : computationList:seq&lt;Async&lt;'T&gt;&gt; -&gt; Async&lt;'T array&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Specify an asynchronous computation that, when run, executes all the given asynchronous computations, initially queueing each in the thread pool. If any raise an exception then the overall computation will raise an exception, and attempt to cancel the others. All the sub-computations belong to an AsyncGroup that is a subsidiary of the AsyncGroup of the outer computations.
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>member Start : computation:Async&lt;unit&gt; -&gt; unit</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Start the asynchronous computation in the thread pool. Do not await its result. Run as part of the default AsyncGroup
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>Async.RunSynchronously</span></span> <span lang="EN-US">is used to run</span> <span class="Teletyped"><span lang="EN-US" style=''>async&lt;'a&gt;</span></span> <span lang="EN-US">blocks and wait for them to return,</span> <span class="Teletyped"><span lang="EN-US" style=''>Run.Parallel</span></span> <span lang="EN-US">automatically runs each</span> <span class="Teletyped"><span lang="EN-US" style=''>async&lt;'a&gt;</span></span> <span lang="EN-US">on as many processors as the CPU has, and</span> <span class="Teletyped"><span lang="EN-US" style=''>Async.Start</span></span> <span lang="EN-US">runs without waiting for the operation to complete. To use the canonical example, downloading a web page, we can write code for downloading a web page asyncronously as follows in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; let extractLinks url =<br>
				&nbsp;&nbsp;&nbsp; async {<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let webClient = new System.Net.WebClient()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "Downloading %s" url<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let html = webClient.DownloadString(url : string)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "Got %i bytes" html.Length<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let matches = System.Text.RegularExpressions.Regex.Matches(html, @"http://\S+")<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "Got %i links" matches.Count<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return url, matches.Count<br>
				&nbsp;&nbsp;&nbsp; };;<br>
				<br>
				val extractLinks : string -&gt; Async&lt;string * int&gt;<br>
				<br>
				&gt; Async.RunSynchronously (extractLinks "http://www.msn.com/");;<br>
				Downloading http://www.msn.com/<br>
				Got 50742 bytes<br>
				Got 260 links<br>
				val it : string * int = ("http://www.msn.com/", 260)
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				async&lt;'a&gt; Members
			</h3>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>async&lt;'a&gt;</span></span> <span lang="EN-US">objects are constructed from the <a href="http://msdn.microsoft.com/en-us/library/ee340369.aspx"><span style='color:windowtext;text-decoration:none'>AsyncBuilder</span></a>, which has the following important members:</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>member Bind : p:Async&lt;'a&gt; * f:('a -&gt; Async&lt;'b&gt;) -&gt; Async&lt;'b&gt;</span></span> <span lang="EN-US">/</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>let!</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Specify an asynchronous computation that, when run, runs 'p', and when 'p' generates a result 'res', runs 'f res'.
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>member Return : v:'a -&gt; Async&lt;'a&gt;</span></span> <span lang="EN-US">/</span> <span class="Teletyped"><span lang="EN-US" style=''>return</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Specify an asynchronous computation that, when run, returns the result 'v'
			</p>
			<p class="TextBody">
				<span lang="EN-US">In other words,</span> <span class="Teletyped"><span lang="EN-US" style=''>let!</span></span> <span lang="EN-US">executes an async workflow and binds its return value to an identifier,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>return</span></span> <span lang="EN-US">simply returns a result, and</span> <span class="Teletyped"><span lang="EN-US" style=''>return!</span></span> <span lang="EN-US">executes an async workflow and returns its return value as a result.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">These primitives allow us to compose async blocks within one another. For example, we can improve on the code above by downloading a web page asyncronously and extracting its urls asyncronously as well:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let extractLinksAsync html =<br>
				&nbsp;&nbsp;&nbsp; async {<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return System.Text.RegularExpressions.Regex.Matches(html, @"http://\S+")<br>
				&nbsp;&nbsp;&nbsp; }<br>
				&nbsp;&nbsp;&nbsp;<br>
				let downloadAndExtractLinks url =<br>
				&nbsp;&nbsp;&nbsp; async {<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let webClient = new System.Net.WebClient()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let html = webClient.DownloadString(url : string)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let! links = extractLinksAsync html<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return url, links.Count<br>
				&nbsp;&nbsp;&nbsp; }
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice that</span> <span class="Teletyped"><span lang="EN-US" style=''>let!</span></span> <span lang="EN-US">takes an</span> <span class="Teletyped"><span lang="EN-US" style=''>async&lt;'a&gt;</span></span> <span lang="EN-US">and binds its return value to an identifier of type</span> <span class="Teletyped"><span lang="EN-US" style=''>'a</span></span><span lang="EN-US">. We can test this code in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; let links = downloadAndExtractLinks "http://www.wordpress.com/";;<br>
				<br>
				val links : Async&lt;string * int&gt;<br>
				<br>
				&gt; Async.Run links;;<br>
				val it : string * int = ("http://www.wordpress.com/", 132)
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">What does</span></span> <span class="Teletyped"><span lang="EN-US" style=''>let!</span></span> <span class="Bold"><span lang="EN-US">do?</span></span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>let!</span></span> <span lang="EN-US">runs an</span> <span class="Teletyped"><span lang="EN-US" style=''>async&lt;'a&gt;</span></span> <span lang="EN-US">object on its own thread, then it immediately releases the current thread back to the threadpool. When</span> <span class="Teletyped"><span lang="EN-US" style=''>let!</span></span> <span lang="EN-US">returns, execution of the workflow will continue on the new thread, which may or may not be the same thread that the workflow started out on. As a result, async workflows tend to "hop" between threads, an interesting effect demonstrated explicitly <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Computation_Expressions%23Monad_Primer"><span style='color:windowtext;text-decoration:none'>here</span></a>, but this is not generally regarded as a bad thing.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Async Examples
			</h2>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Parallel Map
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Consider the function</span> <span class="Teletyped"><span lang="EN-US" style=''>Seq.map</span></span><span lang="EN-US">. This function is synchronous, however there is no real reason why it <em>needs</em> to be synchronous, since each element can be mapped in parallel (provided we're not sharing any mutable state). Using a <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Modules_and_Namespaces%23Extending_Types_and_Modules"><span style='color:windowtext;text-decoration:none'>module extension</span></a>, we can write a parallel version of</span> <span class="Teletyped"><span lang="EN-US" style=''>Seq.map</span></span> <span lang="EN-US">with minimal effort:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				module Seq =&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let pmap f l =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seq { for a in l -&gt; async { return f a } }<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Async.Parallel<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&gt; Async.Run
			</p>
			<p class="TextBody">
				<span lang="EN-US">Parallel mapping can have a dramatic impact on the speed of map operations. We can compare serial and parallel mapping directly using the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				open System.Text.RegularExpressions<br>
				open System.Net<br>
				&nbsp;&nbsp;&nbsp;<br>
				let download url =<br>
				&nbsp;&nbsp;&nbsp; let webclient = new System.Net.WebClient()<br>
				&nbsp;&nbsp;&nbsp; webclient.DownloadString(url : string)<br>
				<br>
				let extractLinks html = Regex.Matches(html, @"http://\S+")<br>
				<br>
				let downloadAndExtractLinks url =<br>
				&nbsp;&nbsp;&nbsp; let links = (url |&gt; download |&gt; extractLinks)<br>
				&nbsp;&nbsp;&nbsp; url, links.Count<br>
				&nbsp;&nbsp;&nbsp;<br>
				let urls =<br>
				&nbsp;&nbsp;&nbsp;&nbsp; [@"http://www.craigslist.com/";<br>
				&nbsp;&nbsp;&nbsp;&nbsp; @"http://www.msn.com/";<br>
				&nbsp;&nbsp;&nbsp;&nbsp; @"http://en.wikibooks.org/wiki/Main_Page";<br>
				&nbsp;&nbsp;&nbsp;&nbsp; @"http://www.wordpress.com/";<br>
				&nbsp;&nbsp;&nbsp;&nbsp; @"http://news.google.com/";]<br>
				<br>
				let pmap f l =<br>
				&nbsp;&nbsp;&nbsp; seq { for a in l -&gt; async { return f a } }<br>
				&nbsp;&nbsp;&nbsp; |&gt; Async.Parallel<br>
				&nbsp;&nbsp;&nbsp; |&gt; Async.Run<br>
				&nbsp;&nbsp;&nbsp;<br>
				let testSynchronous() = List.map downloadAndExtractLinks urls<br>
				let testAsynchronous() = pmap downloadAndExtractLinks urls<br>
				<br>
				let time msg f =<br>
				&nbsp;&nbsp;&nbsp; let stopwatch = System.Diagnostics.Stopwatch.StartNew()<br>
				&nbsp;&nbsp;&nbsp; let temp = f()<br>
				&nbsp;&nbsp;&nbsp; stopwatch.Stop()<br>
				&nbsp;&nbsp;&nbsp; printfn "(%f ms) %s: %A" stopwatch.Elapsed.TotalMilliseconds msg temp<br>
				&nbsp;&nbsp;&nbsp;<br>
				let main() =<br>
				&nbsp;&nbsp;&nbsp; printfn "Start..."<br>
				&nbsp;&nbsp;&nbsp; time "Synchronous" testSynchronous<br>
				&nbsp;&nbsp;&nbsp; time "Asynchronous" testAsynchronous<br>
				&nbsp;&nbsp;&nbsp; printfn "Done."<br>
				&nbsp;&nbsp;&nbsp;<br>
				main()
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program has the following types:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				val download : string -&gt; string<br>
				val extractLinks : string -&gt; MatchCollection<br>
				val downloadAndExtractLinks : string -&gt; string * int<br>
				val urls : string list<br>
				val pmap : ('a -&gt; 'b) -&gt; seq&lt;'a&gt; -&gt; 'b array<br>
				val testSynchronous : unit -&gt; (string * int) list<br>
				val testAsynchronous : unit -&gt; (string * int) array<br>
				val time : string -&gt; (unit -&gt; 'a) -&gt; unit<br>
				val main : unit -&gt; unit
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program outputs the following:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				Start...(4276.190900 ms) Synchronous: [("http://www.craigslist.com/", 185); ("http://www.msn.com/", 262); ("http://en.wikibooks.org/wiki/Main_Page", 190); ("http://www.wordpress.com/", 132); ("http://news.google.com/", 296)](1939.117900 ms) Asynchronous: [|("http://www.craigslist.com/", 185); ("http://www.msn.com/", 261);&nbsp; ("http://en.wikibooks.org/wiki/Main_Page", 190);&nbsp; ("http://www.wordpress.com/", 132); ("http://news.google.com/", 294)|]Done.
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The code using</span> <span class="Teletyped"><span lang="EN-US" style=''>pmap</span></span> <span lang="EN-US">ran about 2.2x faster because web pages are downloaded in parallel, rather than serially.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Concurrency with Functional Programming
			</h2>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Why Concurrency Matters
			</h3>
			<p class="TextBody">
				<span lang="EN-US">For the first 50 years of software development, programmers could take comfort in the fact that computer hardware roughly doubled in power every 18 months. If a program was slow today, one could just wait a few months and the program would run at double the speed with no change to the source code. This trend continued well into the early 2000s, where commodity desktop machines in 2003 had more processing power than the fastest supercomputers in 1993. However, after the publication of a well-known article, <a href="http://www.gotw.ca/publications/concurrency-ddj.htm"><span style='color:windowtext;text-decoration:none'>The Free Lunch is Over: A Fundamental Turn Toward Concurrency in Software</span></a> by Herb Sutter, processors have peaked at around 3.7 GHz in 2005. The theoretical cap in in computing speed is limited by the speed of light and the laws of physics, and we've very nearly reached that limit. Since CPU designers are unable to design faster CPUs, they have turned toward designing processors with multiple cores and better support for multithreading. Programmers no longer have the luxury of their applications running twice as fast with improving hardware -- the free lunch is over.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Clockrates are not getting any faster, however the amount of data businesses process each year grows exponentially (usually at a rate of 10-20% per year). To meet the growing processing demands of business, the future of all software development is tending toward the development of highly parallel, multithreaded applications which take advantage of multicores processors, distributed systems, and cloud computing.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Problems with Mutable State
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Multithreaded programming has a reputation for being notoriously difficult to get right and having a rather steep learning curve. Why does it have this reputation? To put it simply, mutable shared state makes programs difficult to reason about. When two threads are mutating the same variables, it is very easy to put the variable in an invalid state.</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Race Conditions</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">As a demonstration, here's how to increment a global variable using shared state (non-threaded version):</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let test() =<br>
				&nbsp;&nbsp;&nbsp; let counter = ref 0m<br>
				<br>
				&nbsp;&nbsp;&nbsp; let IncrGlobalCounter numberOfTimes =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in 1 .. numberOfTimes do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; counter := !counter + 1m<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; IncrGlobalCounter 1000000<br>
				&nbsp;&nbsp;&nbsp; IncrGlobalCounter 1000000<br>
				<br>
				&nbsp;&nbsp;&nbsp; !counter // returns 2000000M
			</p>
			<p class="TextBody">
				<span lang="EN-US">This works, but some programmer might notice that both calls to</span> <span class="Teletyped"><span lang="EN-US" style=''>IncrGlobalCounter</span></span> <span lang="EN-US">could be computed in parallel since there's no real reason to wait for one call to finish before the other. Using the .NET threading primitives in the <a href="http://msdn.microsoft.com/en-us/library/system.threading.aspx"><span style='color:windowtext;text-decoration:none'>System.Threading</span></a> namespace, a programmer can re-write this as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				open System.Threading<br>
				<br>
				let testAsync() =<br>
				&nbsp;&nbsp;&nbsp; let counter = ref 0m<br>
				<br>
				&nbsp;&nbsp;&nbsp; let IncrGlobalCounter numberOfTimes =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in 1 .. numberOfTimes do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; counter := !counter + 1m<br>
				<br>
				&nbsp;&nbsp;&nbsp; let AsyncIncrGlobalCounter numberOfTimes =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Thread(fun () -&gt; IncrGlobalCounter(numberOfTimes))<br>
				<br>
				&nbsp;&nbsp;&nbsp; let t1 = AsyncIncrGlobalCounter 1000000<br>
				&nbsp;&nbsp;&nbsp; let t2 = AsyncIncrGlobalCounter 1000000<br>
				&nbsp;&nbsp;&nbsp; t1.Start() // runs t1 asyncronously<br>
				&nbsp;&nbsp;&nbsp; t2.Start() // runs t2 asyncronously<br>
				&nbsp;&nbsp;&nbsp; t1.Join()&nbsp; // waits until t1 finishes<br>
				&nbsp;&nbsp;&nbsp; t2.Join()&nbsp; // waits until t2 finishes<br>
				<br>
				&nbsp;&nbsp;&nbsp; !counter
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program <em>should</em> do the same thing as the previous program, only it should run in ~1/2 the time. Here are the results of 5 test runs in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; [for a in 1 .. 5 -&gt; testAsync()];;<br>
				val it : decimal list = [1498017M; 1509820M; 1426922M; 1504574M; 1420401M]
			</p>
			<p class="TextBody">
				<span lang="EN-US">The program is computationally sound, but it produces a different result everytime its run. What happened?</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">It takes several machine instructions increment a decimal value. In particular, the .NET IL for incrementing a decimal looks like this:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				// pushes static field onto evaluation stack<br>
				L_0004: ldsfld valuetype [mscorlib]System.Decimal ConsoleApplication1.Program::i<br>
				<br>
				// executes Decimal.op_Increment method<br>
				L_0009: call valuetype [mscorlib]System.Decimal [mscorlib]System.Decimal::op_Increment(valuetype [mscorlib]System.Decimal)<br>
				<br>
				// replaces static field with value from evaluation stack<br>
				L_000e: stsfld valuetype [mscorlib]System.Decimal ConsoleApplication1.Program::i
			</p>
			<p class="TextBody">
				<span lang="EN-US">Imagine that we have two threads calling this code (calls made by Thread1 and Thread2 are interleaved):</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				Thread1: Loads value "100" onto its evaluation stack.Thread1: Call add with "100" and "1"Thread2: Loads value "100" onto its evaluation stack.Thread1: Writes "101" back out to static variableThread2: Call add with "100" and "1"Thread2: Writes "101" back out to static variable (Oops, we've incremented an old value and wrote it back out)Thread1: Loads value "101" onto its evaluation stack.Thread2: Loads value "101" onto its evaluation stack.(Now we let Thread1 get a little further ahead of Thread2)Thread1: Call add with "101" and "1"Thread1: Writes "102" back out to static variable.Thread1: Loads value "102" to evaluation stackThread1: Call add with "102" and "1"Thread1: Writes "103" back out to static variable.Thread2: Call add with "101" and "1Thread2: Writes "102" back out to static variable (Oops, now we've completely overwritten work done by Thread1!)
			</p>
			<p class="TextBody">
				<span lang="EN-US">This kind of bug is called a <em>race condition</em> and it occurs all the time in multithreaded applications. Unlike normal bugs, race-conditions are often non-deterministic, making them extremely difficult to track down.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Usually, programmers solve race conditions by introducing locks. When an object is "locked", all other threads are forced to wait until the object is "unlocked" before they proceed. We can re-write the code above using a block access to the</span> <span class="Teletyped"><span lang="EN-US" style=''>counter</span></span> <span lang="EN-US">variable while each thread writes to it:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				open System.Threading<br>
				<br>
				let testAsync() =<br>
				&nbsp;&nbsp;&nbsp; let counter = ref 0m<br>
				&nbsp;&nbsp;&nbsp; let IncrGlobalCounter numberOfTimes =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in 1 .. numberOfTimes do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock counter (fun () -&gt; counter := !counter + 1m)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* lock is a function in F# library. It automatically unlocks "counter" when 'fun () -&gt; ...' completes *)<br>
				<br>
				&nbsp;&nbsp;&nbsp; let AsyncIncrGlobalCounter numberOfTimes =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Thread(fun () -&gt; IncrGlobalCounter(numberOfTimes))<br>
				<br>
				&nbsp;&nbsp;&nbsp; let t1 = AsyncIncrGlobalCounter 1000000<br>
				&nbsp;&nbsp;&nbsp; let t2 = AsyncIncrGlobalCounter 1000000<br>
				&nbsp;&nbsp;&nbsp; t1.Start() // runs t1 asyncronously<br>
				&nbsp;&nbsp;&nbsp; t2.Start() // runs t2 asyncronously<br>
				&nbsp;&nbsp;&nbsp; t1.Join()&nbsp; // waits until t1 finishes<br>
				&nbsp;&nbsp;&nbsp; t2.Join()&nbsp; // waits until t2 finishes<br>
				<br>
				&nbsp;&nbsp;&nbsp; !counter
			</p>
			<p class="TextBody">
				<span lang="EN-US">The lock guarantees each thread exclusive access to shared state and forces each thread to wait on the other while the code</span> <span class="Teletyped"><span lang="EN-US" style=''>counter := !counter + 1m</span></span> <span lang="EN-US">runs to completion. This function now produces the expected result.</span>
			</p>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Deadlocks</span></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Locks force threads to wait until an object is unlocked. However, locks often lead to a new problem: Let's say we have ThreadA and ThreadB which operate on two corresponding pieces of shared state, StateA and StateB. ThreadA locks stateA and stateB, ThreadB locks stateB and stateA. If the timing is right, when ThreadA needs to access stateB, its waits until ThreadB unlocks stateB; when ThreadB needs to access stateA, it can't proceed either since stateA is locked by ThreadA. Both threads mutually block one another, and they are unable to proceed any further. This is called a deadlock.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Here's some simple code which demonstrates a deadlock:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				open System.Threading<br>
				<br>
				let testDeadlock() =<br>
				&nbsp;&nbsp;&nbsp; let stateA = ref "Shared State A"<br>
				&nbsp;&nbsp;&nbsp; let stateB = ref "Shared State B"<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let threadA = new Thread(fun () -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "threadA started"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;lock stateA (fun () -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "stateA: %s" !stateA<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.Sleep(100) // pauses thread for 100 ms. Simimulates busy processing<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock stateB (fun () -&gt; printfn "stateB: %s" !stateB))<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "threadA finished")<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let threadB = new Thread(fun () -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "threadB started"<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock stateB (fun () -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "stateB: %s" !stateB<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.Sleep(100) // pauses thread for 100 ms. Simimulates busy processing<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock stateA (fun () -&gt; printfn "stateA: %s" !stateA))<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printfn "threadB finished")<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printfn "Starting..."<br>
				&nbsp;&nbsp;&nbsp; threadA.Start()<br>
				&nbsp;&nbsp;&nbsp; threadB.Start()<br>
				&nbsp;&nbsp;&nbsp; threadA.Join()<br>
				&nbsp;&nbsp;&nbsp; threadB.Join()<br>
				&nbsp;&nbsp;&nbsp; printfn "Finished..."
			</p>
			<p class="TextBody">
				<span lang="EN-US">These kinds of bugs occur all the time in multithreaded code, although they usually aren't quite as explicit as the code shown above.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Why Functional Programming Matters
			</h3>
			<p class="TextBody">
				<span lang="EN-US">To put it bluntly, mutable state is enemy of multithreaded code. Functional programming often simplifies multithreading tremendously: since values are immutable by default, programmers don't need to worry about one thread mutating the value of shared state between two threads, so it eliminates a whole class of multithreading bugs related to race conditions. Since there are no race conditions, there's no reason to use locks either, so immutability eliminates another whole class of bugs related to deadlocks as well.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h1 class="HeadingArticle">
				MailboxProcessor
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : MailboxProcessor Class</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span lang="EN-US">F#'s <span class="Bold">MailboxProcessor class</span> is essentially a dedicated message queue running on its own thread. Any thread can send the MailboxProcessor a message asynchronously or synchronously, allowing threads to communicate between one another through message passing. This style of message-passing concurrency is inspired by the Erlang programming language.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Defining MailboxProcessors
			</h2>
			<p class="TextBody">
				<span lang="EN-US">MailboxProcessors are created using the <a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/FSharp.Core/Microsoft.FSharp.Control.type_MailboxProcessor-1.html"><span style='color:windowtext;text-decoration:none'>MailboxProcessor.Start</span></a> method which has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>Start : initial:(MailboxProcessor&lt;'msg&gt; -&gt; Async&lt;unit&gt;) * ?asyncGroup:AsyncGroup -&gt; MailboxProcessor&lt;'msg&gt;</span></span><span lang="EN-US">:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				let counter =<br>
				&nbsp;&nbsp;&nbsp; MailboxProcessor.Start(fun inbox -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec loop n =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; async { do printfn "n = %d, waiting..." n<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let! msg = inbox.Receive()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return! loop(n+msg) }<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop 0)
			</p>
			<p class="TextBody">
				<span lang="EN-US">The value</span> <span class="Teletyped"><span lang="EN-US" style=''>inbox</span></span> <span lang="EN-US">has the type</span> <span class="Teletyped"><span lang="EN-US" style=''>MailboxProcessor&lt;'msg&gt;</span></span> <span lang="EN-US">and represents the message queue. The method</span> <span class="Teletyped"><span lang="EN-US" style=''>inbox.Receive()</span></span> <span lang="EN-US">dequeues the first message from the message queue and binds it to the</span> <span class="Teletyped"><span lang="EN-US" style=''>msg</span></span> <span lang="EN-US">identifier. If there are no messages in queue,</span> <span class="Teletyped"><span lang="EN-US" style=''>Receive</span></span> <span lang="EN-US">releases the thread back to the threadpool and waits for further messages. No threads are blocked while</span> <span class="Teletyped"><span lang="EN-US" style=''>Receive</span></span><span lang="EN-US">waits for further messages.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can experiment with</span> <span class="Teletyped"><span lang="EN-US" style=''>counter</span></span> <span lang="EN-US">in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; let counter =<br>
				&nbsp;&nbsp;&nbsp; MailboxProcessor.Start(fun inbox -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec loop n =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; async { do printfn "n = %d, waiting..." n<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let! msg = inbox.Receive()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return! loop(n+msg) }<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop 0);;<br>
				<br>
				val counter : MailboxProcessor&lt;int&gt;<br>
				<br>
				n = 0, waiting...<br>
				&gt; counter.Post(5);;<br>
				n = 5, waiting...<br>
				val it : unit = ()<br>
				&gt; counter.Post(20);;<br>
				n = 25, waiting...<br>
				val it : unit = ()<br>
				&gt; counter.Post(10);;<br>
				n = 35, waiting...<br>
				val it : unit = ()
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				MailboxProcessor Methods
			</h2>
			<p class="TextBody">
				<span lang="EN-US">There are several useful methods in the MailboxProcessor class:</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>static member Start : initial:(MailboxProcessor&lt;'msg&gt; -&gt; Async&lt;unit&gt;) * ?asyncGroup:AsyncGroup -&gt; MailboxProcessor&lt;'msg&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Create and start an instance of a MailboxProcessor. The asynchronous computation executed by the processor is the one returned by the 'initial' function.
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>member Post : message:'msg -&gt; unit</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Post a message to the message queue of the MailboxProcessor, asynchronously.
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>member PostAndReply : buildMessage:(AsyncReplyChannel&lt;'reply&gt; -&gt; 'msg) * ?timeout:int * ?exitContext:bool -&gt; 'reply</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Post a message to the message queue of the MailboxProcessor and await a reply on the channel. The message is produced by a single call to the first function which must build a message containing the reply channel. The receiving MailboxProcessor must process this message and invoke the Reply method on the reply channel precisely once.
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>member Receive : ?timeout:int -&gt; Async&lt;'msg&gt;</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> Return an asynchronous computation which will consume the first message in arrival order. No thread is blocked while waiting for further messages. Raise a TimeoutException if the timeout is exceeded.
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Two-way Communication
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Just as easily as we can send messages to MailboxProcessors, a MailboxProcessor can send replies back to consumers. For example, we can interrogate the value of a MailboxProcessor using the</span> <span class="Teletyped"><span lang="EN-US" style=''>PostAndReply</span></span> <span lang="EN-US">method as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type msg =<br>
				&nbsp;&nbsp;&nbsp; | Incr of int<br>
				&nbsp;&nbsp;&nbsp; | Fetch of AsyncReplyChannel&lt;int&gt;<br>
				<br>
				let counter =<br>
				&nbsp;&nbsp;&nbsp; MailboxProcessor.Start(fun inbox -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec loop n =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; async { let! msg = inbox.Receive()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match msg with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Incr(x) -&gt; return! loop(n + x)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Fetch(replyChannel) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;replyChannel.Reply(n)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return! loop(n) }<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop 0)
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>msg</span></span> <span lang="EN-US">union wraps two types of messages: we can tell the MailboxProcessor to increment, or have it send its contents to a reply channel. The type</span> <span class="Teletyped"><span lang="EN-US" style=''><a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/FSharp.Core/Microsoft.FSharp.Control.type_AsyncReplyChannel-1.html"><span style='color:windowtext;text-decoration:none'>AsyncReplyChannel&lt;'a&gt;</span></a></span></span> <span lang="EN-US">exposes a single method,</span> <span class="Teletyped"><span lang="EN-US" style=''>member Reply : 'reply -&gt; unit</span></span><span lang="EN-US">. We can use this class in fsi as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; counter.Post(Incr 7);;<br>
				val it : unit = ()<br>
				&gt; counter.Post(Incr 50);;<br>
				val it : unit = ()<br>
				&gt; counter.PostAndReply(fun replyChannel -&gt; Fetch replyChannel);;<br>
				val it : int = 57
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice that</span> <span class="Teletyped"><span lang="EN-US" style=''>PostAndReply</span></span><span lang="EN-US">is a syncronous method.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Encapsulating MailboxProcessors with Objects
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Often, we don't want to expose the implementation details of our classes to consumers. For example, we can re-write the example above as a class which exposes a few select methods:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type countMsg =<br>
				&nbsp;&nbsp;&nbsp; | Die<br>
				&nbsp;&nbsp;&nbsp; | Incr of int<br>
				&nbsp;&nbsp;&nbsp; | Fetch of AsyncReplyChannel&lt;int&gt;<br>
				&nbsp;&nbsp;&nbsp;<br>
				type counter() =<br>
				&nbsp;&nbsp;&nbsp; let innerCounter =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MailboxProcessor.Start(fun inbox -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec loop n =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; async { let! msg = inbox.Receive()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match msg with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Die -&gt; return ()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Incr x -&gt; return! loop(n + x)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Fetch(reply) -&gt;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reply.Reply(n);<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return! loop n }<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop 0)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Incr(x) = innerCounter.Post(Incr x)<br>
				&nbsp;&nbsp;&nbsp; member this.Fetch() = innerCounter.PostAndReply((fun reply -&gt; Fetch(reply)), timeout = 2000)<br>
				&nbsp;&nbsp;&nbsp; member this.Die() = innerCounter.Post(Die)
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				MailboxProcessor Examples
			</h2>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Prime Number Sieve
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Rob Pike delivered a <a href="http://video.google.com/videoplay?docid=810232012617965344"><span style='color:windowtext;text-decoration:none'>fascinating presentation</span></a> at a Google TechTalk on the NewSqueak programming language. NewSqueak's approach to concurrency uses channels, analogous to MailboxProcessors, for inter-thread communication. Toward the end of the presentation, he demonstrates how to implement a prime number sieve using these channels. The following is an implementation of prime number sieve based on Pike's NewSqueak code:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				type 'a seqMsg =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | Die&nbsp;&nbsp;<br>
				&nbsp;&nbsp; &nbsp;| Next of AsyncReplyChannel&lt;'a&gt;&nbsp;&nbsp;<br>
				&nbsp;<br>
				type primes() =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let counter(init) =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MailboxProcessor.Start(fun inbox -&gt;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec loop n =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; async { let! msg = inbox.Receive()&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match msg with&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Die -&gt; return ()&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Next(reply) -&gt;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reply.Reply(n)&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return! loop(n + 1) }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop init)&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; let filter(c : MailboxProcessor&lt;'a seqMsg&gt;, pred) =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MailboxProcessor.Start(fun inbox -&gt;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec loop() =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; async {&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let! msg = inbox.Receive()&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match msg with&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Die -&gt;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c.Post(Die)&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return()&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Next(reply) -&gt;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec filter' n =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if pred n then async { return n }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; async {let! m = c.PostAndAsyncReply(Next)&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return! filter' m }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let! testItem = c.PostAndAsyncReply(Next)&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let! filteredItem = filter' testItem&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reply.Reply(filteredItem)&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return! loop()&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop()&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;&nbsp;<br>
				<br>
				&nbsp;&nbsp;&nbsp; let processor = MailboxProcessor.Start(fun inbox -&gt;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let rec loop (oldFilter : MailboxProcessor&lt;int seqMsg&gt;) prime =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; async {&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let! msg = inbox.Receive()&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match msg with&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Die -&gt;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldFilter.Post(Die)&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return()&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Next(reply) -&gt;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reply.Reply(prime)&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let newFilter = filter(oldFilter, (fun x -&gt; x % prime &lt;&gt; 0))&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let! newPrime = oldFilter.PostAndAsyncReply(Next)&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return! loop newFilter newPrime&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop (counter(3)) 2)&nbsp;&nbsp;<br>
				&nbsp;<br>
				&nbsp;&nbsp;&nbsp; member this.Next() = processor.PostAndReply( (fun reply -&gt; Next(reply)), timeout = 2000)<br>
				&nbsp;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; interface System.IDisposable with<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member this.Dispose() = processor.Post(Die)<br>
				<br>
				&nbsp;&nbsp;&nbsp; static member upto max =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ use p = new primes()<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let lastPrime = ref (p.Next())<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while !lastPrime &lt;= max do<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield !lastPrime<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lastPrime := p.Next() ]
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>counter</span></span> <span lang="EN-US">represents an infinite list of numbers from n..infinity.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>filter</span></span> <span lang="EN-US">is simply a filter for another MailboxProcessor. Its analogous to</span> <span class="Teletyped"><span lang="EN-US" style=''>Seq.filter</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>processor</span></span> <span lang="EN-US">is essentially an iterative filter: we seed our prime list with the first prime,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>2</span></span> <span lang="EN-US">and a infinite list of numbers from 3..infinity. Each time we process a message, we return the prime number, then replace our infinite list with a new list which filters out all numbers divisible by our prime. The head of each new filtered list is the next prime number.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">So, the first time we call</span> <span class="Teletyped"><span lang="EN-US" style=''>Next</span></span><span lang="EN-US">, we get back a 2 and replace our infinite list with all numbers not divisible by two. We call next again, we get back the next prime, 3, and filter our list again for all numbers divisible by 3. We call next again, we get back the next prime, 5 (we skip 4 since its divisible by 2), and filter all numbers divisible by 5. This process repeats indefinitely. The end result is a prime number sieve with an identical implementation to the Sieve of Eratosthenes.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can test this class in fsi:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				&gt; let p = new primes();;<br>
				<br>
				val p : primes<br>
				<br>
				&gt; p.Next();;<br>
				val it : int = 2<br>
				&gt; p.Next();;<br>
				val it : int = 3<br>
				&gt; p.Next();;<br>
				val it : int = 5<br>
				&gt; p.Next();;<br>
				val it : int = 7<br>
				&gt; p.Next();;<br>
				val it : int = 11<br>
				&gt; p.Next();;<br>
				val it : int = 13<br>
				&gt; p.Next();;<br>
				val it : int = 17<br>
				&gt; primes.upto 100;;<br>
				val it : int list<br>
				= [2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71;<br>
				&nbsp;&nbsp; 73; 79; 83; 89; 97]
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h1 class="HeadingArticle">
				Lexing and Parsing
			</h1>
			<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style='margin-left:-.5pt;border-collapse:collapse'>
				<tr>
					<td width="96" valign="top" style='width:72.0pt;padding:0cm .5pt 0cm .5pt'>
						<p class="TextBody">
							<span lang="EN-US">F# : Lexing and Parsing</span>
						</p>
					</td>
				</tr>
			</table>
			<p class="TextBody">
				<span class="Bold"><span lang="EN-US">Lexing and parsing</span></span> <span lang="EN-US">is a very handy way to convert source-code (or other human-readable input which has a well-defined syntax) into an abstract syntax tree (AST) which represents the source-code. F# comes with two tools, FsLex and FsYacc, which are used to convert input into an AST.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">FsLex and FsYacc have more or less the same specification as <a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual026.html"><span style='color:windowtext;text-decoration:none'>OCamlLex and OCamlYacc</span></a>, which in turn are based on the <a href="http://dinosaur.compilertools.net/"><span style='color:windowtext;text-decoration:none'>Lex and Yacc</span></a> family of lexer/parser generators. Virtually all material concerned with OCamlLex/OCamlYacc can transfer seamlessly over to FsLex/FsYacc. With that in mind, SooHyoung Oh's <a href="http://pllab.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/index.html"><span style='color:windowtext;text-decoration:none'>OCamlYacc tutorial</span></a> and companion <a href="http://pllab.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamllex-tutorial/index.html"><span style='color:windowtext;text-decoration:none'>OCamlLex Tutorial</span></a> are the single best online resources to learn how to use the lexing and parsing tools which come with F# (and OCaml for that matter!).</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Lexing and Parsing from a Highlevel View
			</h2>
			<p class="TextBody">
				<span lang="EN-US">Transforming input into a well-defined abstract syntax tree requires (at minimum) two transformations:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 1.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">A lexer uses regular expressions to convert each syntactical element from the input into a token, essentially mapping the input to a stream of tokens.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&nbsp; 2.&nbsp; <span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">A parser reads in a stream of tokens and attempts to match tokens to a set of rules, where the end result maps the token stream to an abstract syntax tree.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Its certainly possible to write a lexer which generates the abstract syntax tree directly, but this only works for the most simplistic grammars. If a grammar contains balanced parentheses or other recursive constructs, optional tokens, repeating groups of tokens, operator precedence, or anything which can't be captured by regular expressions, then its easiest to write a parser in addition to a lexer.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">With F#, its possible to custom file formats, domain specific languages, and even write full-blown compilers for your new language.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h2 class="Heading1">
				Extended Example: Parsing SQL
			</h2>
			<p class="TextBody">
				<span lang="EN-US">The following code will demonstrate step-by-step how to define a simple lexer/parser for a subset of SQL. If you're using Visual Studio, you should add a reference to</span> <span class="Teletyped"><span lang="EN-US" style=''>FSharp.PowerPack.dll</span></span> <span lang="EN-US">to your project. If you're compiling on the commandline, use the</span> <span class="Teletyped"><span lang="EN-US" style=''>-r</span></span> <span lang="EN-US">flag to reference the aforemented F# powerpack assembly.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Step 1: Define the Abstract Syntax Tree
			</h3>
			<p class="TextBody">
				<span lang="EN-US">We want to parse the following SQL statement:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				SELECT x, y, z&nbsp;&nbsp;<br>
				FROM t1&nbsp;&nbsp;<br>
				LEFT JOIN t2&nbsp;&nbsp;<br>
				INNER JOIN t3 ON t3.ID = t2.ID&nbsp;&nbsp;<br>
				WHERE x = 50 AND y = 20&nbsp;&nbsp;<br>
				ORDER BY x ASC, y DESC, z
			</p>
			<p class="TextBody">
				<span lang="EN-US">This is a pretty simple query, and while it doesn't demonstrate everything you can do with the language, it's a good start. We can model everything in this query using the following definitions in F#:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				// Sql.fs<br>
				&nbsp;<br>
				type value =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | Int of int&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | Float of float&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | String of string&nbsp;<br>
				&nbsp;<br>
				type dir = Asc | Desc&nbsp;&nbsp;<br>
				type op = Eq | Gt | Ge | Lt | Le&nbsp;&nbsp;&nbsp; // =, &gt;, &gt;=, &lt;, &lt;=&nbsp;&nbsp;<br>
				&nbsp;<br>
				type order = string * dir&nbsp;&nbsp;<br>
				&nbsp;<br>
				type where =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | Cond of (value * op * value)&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | And of where * where&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | Or of where * where&nbsp;&nbsp;<br>
				&nbsp;<br>
				type joinType = Inner | Left | Right&nbsp;&nbsp;<br>
				&nbsp;<br>
				type join = string * joinType * where option&nbsp;&nbsp;&nbsp; // table name, join, optional "on" clause&nbsp;&nbsp;<br>
				&nbsp;<br>
				type sqlStatement =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; { Table : string;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Columns : string list;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Joins : join list;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Where : where option;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderBy : order list }
			</p>
			<p class="TextBody">
				<span lang="EN-US">A record type neatly groups all of our related values into a single object. When we finish our parser, it should be able to convert a string in an object of type</span> <span class="Teletyped"><span lang="EN-US" style=''>sqlStatement</span></span><span lang="EN-US">.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Step 2: Define the parser tokens
			</h3>
			<p class="TextBody">
				<span lang="EN-US">A token is any single identifiable element in a grammar. Let's look at the string we're trying to parse:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				SELECT x, y, z&nbsp;&nbsp;<br>
				FROM t1&nbsp;&nbsp;<br>
				LEFT JOIN t2&nbsp;&nbsp;<br>
				INNER JOIN t3 ON t3.ID = t2.ID&nbsp;&nbsp;<br>
				WHERE x = 50 AND y = 20&nbsp;&nbsp;<br>
				ORDER BY x ASC, y DESC, z
			</p>
			<p class="TextBody">
				<span lang="EN-US">So far, we have several keywords (by convention, all keywords are uppercase):</span> <span class="Teletyped"><span lang="EN-US" style=''>SELECT</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>FROM</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>LEFT</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>INNER</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>RIGHT</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>JOIN</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>ON</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>WHERE</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>AND</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>OR</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>ORDER</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>BY</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>ASC</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>DESC</span></span><span lang="EN-US">, and</span> <span class="Teletyped"><span lang="EN-US" style=''>COMMA</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">There are also a few comparison operators:</span> <span class="Teletyped"><span lang="EN-US" style=''>EQ</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>GT</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>GE</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>LT</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>LE</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We also have non-keyword identifiers composed of strings and numeric literals. which we&rsquo;ll represent using the keyword</span> <span class="Teletyped"><span lang="EN-US" style=''>ID</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>INT</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>FLOAT</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Finally, there is one more token,</span> <span class="Teletyped"><span lang="EN-US" style=''>EOF</span></span><span lang="EN-US">, which indicates the end of our input stream.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Now we can create a basic parser file for FsYacc, name the file SqlParser.fsp:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				%{&nbsp;&nbsp;<br>
				open Sql&nbsp;&nbsp;<br>
				%}&nbsp;&nbsp;<br>
				&nbsp;<br>
				%token &lt;string&gt; ID&nbsp;&nbsp;<br>
				%token &lt;int&gt; INT&nbsp;&nbsp;<br>
				%token &lt;float&gt; FLOAT&nbsp;&nbsp;<br>
				&nbsp;<br>
				%token AND OR&nbsp;&nbsp;<br>
				%token COMMA&nbsp;&nbsp;<br>
				%token EQ LT LE GT GE&nbsp;&nbsp;<br>
				%token JOIN INNER LEFT RIGHT ON&nbsp;&nbsp;<br>
				%token SELECT FROM WHERE ORDER BY&nbsp;&nbsp;<br>
				%token ASC DESC&nbsp;&nbsp;<br>
				%token EOF&nbsp;&nbsp;<br>
				&nbsp;<br>
				// start&nbsp;&nbsp;<br>
				%start start&nbsp;&nbsp;<br>
				%type &lt;string&gt; start&nbsp;&nbsp;<br>
				&nbsp;<br>
				%%&nbsp;&nbsp;<br>
				&nbsp;<br>
				start:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { "Nothing to see here" }&nbsp;&nbsp;<br>
				%%
			</p>
			<p class="TextBody">
				<span lang="EN-US">This is boilerplate code with the section for tokens filled in.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Compile the parser using the following command line:</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>fsyacc SqlParser.fsp</span></span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Bold">Tips:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">If you haven't done so already, you should <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Getting_Set_Up%23Adding_to_the_PATH_Environment_Variable"><span style='color:windowtext;text-decoration:none'>add the F# bin directory to your PATH environment variable</span></a>.</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US"><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">If you're using Visual Studio, you can automatically generate your parser code on each compile. Right-click on your project file and choose "Properties". Navigate to the Build Events tab, and add the following to the 'Pre-build event command line' and use the following:</span> <span class="Teletyped"><span lang="EN-US" style=''>fsyacc "$(ProjectDir)SqlParser.fsp"</span></span><span lang="EN-US">. Also remember to exclude this file from the build process: right-click the file, choose "Properties" and select "None" against "Build Action".</span>
			</p>
			<p class="IndentedSingle">
				&nbsp;
			</p>
			<p class="TextBody">
				<span lang="EN-US">If everything works, FsYacc will generate two files, SqlParser.fsi and SqlParser.fs. You'll need to add these files to your project if they don't already exist. If you open the SqlParser.fsi file, you'll notice the tokens you defined in your .fsl file have been converted into a union type.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Step 3: Defining the lexer rules
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Lexers convert text inputs into a stream of tokens. We can start with the following boiler plate code:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				{&nbsp;&nbsp;<br>
				// header: any valid F# can appear here.&nbsp;&nbsp;<br>
				open Lexing&nbsp;&nbsp;<br>
				}&nbsp;&nbsp;<br>
				&nbsp;<br>
				// regex macros&nbsp;&nbsp;<br>
				let char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = ['a'-'z' 'A'-'Z']&nbsp;&nbsp;<br>
				let digit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = ['0'-'9']&nbsp;&nbsp;<br>
				let int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = '-'?digit+&nbsp;&nbsp;<br>
				let float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = '-'?digit+ '.' digit+&nbsp;&nbsp;<br>
				let whitespace&nbsp; = [' ' '\t']&nbsp;&nbsp;<br>
				let newline&nbsp;&nbsp;&nbsp;&nbsp; = "\n\r" | '\n' | '\r' &nbsp;<br>
				&nbsp;<br>
				// rules&nbsp;&nbsp;<br>
				rule tokenize = parse&nbsp;&nbsp;<br>
				| whitespace&nbsp;&nbsp;&nbsp; { tokenize lexbuf }&nbsp;&nbsp;<br>
				| newline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { lexbuf.EndPos &lt;- lexbuf.EndPos.NextLine; tokenize lexbuf; }&nbsp;&nbsp;<br>
				| eof&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { () }
			</p>
			<p class="TextBody">
				<span lang="EN-US">This is not "real" F# code, but rather a special language used by FsLex.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The</span> <span class="Teletyped"><span lang="EN-US" style=''>let</span></span> <span lang="EN-US">bindings at the top of the file are used to define regular expression macros.</span> <span class="Teletyped"><span lang="EN-US" style=''>eof</span></span> <span lang="EN-US">is a special marker used to identify the end of a string buffer input.</span>
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>rule ... = parse ...</span></span> <span lang="EN-US">defines our lexing function, called</span> <span class="Teletyped"><span lang="EN-US" style=''>tokenize</span></span> <span lang="EN-US">above. Our lexing function consists of a series of rules, which has two pieces: 1) a regular expression, 2) an expression to evaluate if the regex matches, such as returning a token. Text is read from the token stream one character at a time until it matches a regular expression and returns a token.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can fill in the remainder of our lexer by adding more matching expressions:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				{&nbsp;&nbsp;<br>
				open Lexing&nbsp;&nbsp;<br>
				&nbsp;<br>
				// opening the SqlParser module to give us access to the tokens it defines&nbsp;&nbsp;<br>
				open SqlParser&nbsp;&nbsp;<br>
				}&nbsp;&nbsp;<br>
				&nbsp;<br>
				let char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = ['a'-'z' 'A'-'Z']&nbsp;&nbsp;<br>
				let digit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = ['0'-'9']&nbsp;&nbsp;<br>
				let int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = '-'?digit+&nbsp;&nbsp;<br>
				let float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = '-'?digit+ '.' digit+&nbsp;&nbsp;<br>
				let identifier&nbsp; = char(char|digit|['-' '_' '.'])*&nbsp;&nbsp;<br>
				let whitespace&nbsp; = [' ' '\t']&nbsp;&nbsp;<br>
				let newline&nbsp;&nbsp;&nbsp;&nbsp; = "\n\r" | '\n' | '\r'&nbsp;<br>
				&nbsp;<br>
				rule tokenize = parse&nbsp;&nbsp;<br>
				| whitespace&nbsp;&nbsp;&nbsp; { tokenize lexbuf }&nbsp;&nbsp;<br>
				| newline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { lexbuf.EndPos &lt;- lexbuf.EndPos.NextLine; tokenize lexbuf; }&nbsp;&nbsp;<br>
				| int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { INT(Int32.Parse(lexeme lexbuf)) }&nbsp;&nbsp;<br>
				| float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { FLOAT(Double.Parse(lexeme lexbuf)) }&nbsp;&nbsp;<br>
				| ','&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { COMMA }&nbsp;&nbsp;<br>
				| eof&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { EOF }
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice the code between the</span> <span class="Teletyped"><span lang="EN-US" style=''>{</span></span><span lang="EN-US">'s and</span> <span class="Teletyped"><span lang="EN-US" style=''>}</span></span><span lang="EN-US">'s consists of plain old F# code. Also notice we are returning the same tokens (</span><span class="Teletyped"><span lang="EN-US" style=''>INT</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>FLOAT</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>COMMA</span></span> <span lang="EN-US">and</span> <span class="Teletyped"><span lang="EN-US" style=''>EOF</span></span><span lang="EN-US">) that we defined in SqlParser.fsl. As you can probably infer, the code</span> <span class="Teletyped"><span lang="EN-US" style=''>lexeme lexbuf</span></span> <span lang="EN-US">returns the string our parser matched. The</span> <span class="Teletyped"><span lang="EN-US" style=''>tokenize</span></span> <span lang="EN-US">function will be converted into function which has a return type of</span> <span class="Teletyped"><span lang="EN-US" style=''>SqlParser.token</span></span><span lang="EN-US">.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can fill in the rest of the lexer rules fairly easily:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				{&nbsp;&nbsp;<br>
				open System&nbsp;&nbsp;<br>
				open SqlParser&nbsp;&nbsp;<br>
				open Lexing&nbsp;&nbsp;<br>
				&nbsp;<br>
				let keywords =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; [&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SELECT", SELECT;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "FROM", FROM; &nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "WHERE", WHERE;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ORDER", ORDER;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "BY", BY;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "JOIN", JOIN;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "INNER", INNER;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "LEFT", LEFT;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "RIGHT", RIGHT;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ASC", ASC;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "DESC", DESC;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "AND", AND;&nbsp;&nbsp;<br>
				&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"OR", OR;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ON", ON;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; ] |&gt; Map.of_list&nbsp;&nbsp;<br>
				&nbsp;<br>
				let ops =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; [&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "=",&nbsp;&nbsp;&nbsp; EQ;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&lt;",&nbsp;&nbsp;&nbsp; LT;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&lt;=",&nbsp;&nbsp; LE;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&gt;",&nbsp;&nbsp;&nbsp; GT;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&gt;=",&nbsp;&nbsp; GE;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; ] |&gt; Map.of_list&nbsp;&nbsp;<br>
				}&nbsp;&nbsp;<br>
				&nbsp;<br>
				let char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = ['a'-'z' 'A'-'Z']&nbsp;&nbsp;<br>
				let digit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = ['0'-'9']&nbsp;&nbsp;<br>
				let int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = '-'?digit+&nbsp;&nbsp;<br>
				let float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = '-'?digit+ '.' digit+&nbsp;&nbsp;<br>
				let identifier&nbsp; = char(char|digit|['-' '_' '.'])*&nbsp;&nbsp;<br>
				let whitespace&nbsp; = [' ' '\t']&nbsp;&nbsp;<br>
				let newline&nbsp;&nbsp;&nbsp;&nbsp; = "\n\r" | '\n' | '\r'&nbsp;<br>
				let operator&nbsp;&nbsp;&nbsp; = "&gt;" | "&gt;=" | "&lt;" | "&lt;=" | "="&nbsp;<br>
				&nbsp;<br>
				rule tokenize = parse&nbsp;&nbsp;<br>
				| whitespace&nbsp;&nbsp;&nbsp; { tokenize lexbuf }&nbsp;&nbsp;<br>
				| newline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { lexbuf.EndPos &lt;- lexbuf.EndPos.NextLine; tokenize lexbuf; }&nbsp;&nbsp;<br>
				| int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { INT(Int32.Parse(lexeme lexbuf)) }&nbsp;&nbsp;<br>
				| float&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ FLOAT(Double.Parse(lexeme lexbuf)) }&nbsp;&nbsp;<br>
				| operator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { ops.[lexeme lexbuf] }&nbsp;&nbsp;<br>
				| identifier&nbsp;&nbsp;&nbsp; { match keywords.TryFind(lexeme lexbuf) with&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Some(token) -&gt; token&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | None -&gt; ID(lexeme lexbuf) }&nbsp;&nbsp;<br>
				| ','&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { COMMA }&nbsp;&nbsp;<br>
				| eof&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { EOF }
			</p>
			<p class="TextBody">
				<span lang="EN-US">Notice we've created a few <a href="http://en.wikibooks.org/w/index.php?title=F_Sharp_Programming/Sets_and_Maps%23Maps"><span style='color:windowtext;text-decoration:none'>maps</span></a>, one for keywords and one for operators. While we certainly can define these as rules in our lexer, its generally recommended to have a very small number of rules to avoid a "state explosion".</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">To compile this lexer, execute the following code on the commandline:</span> <span class="Teletyped"><span lang="EN-US" style=''>fslex SqlLexer.fsl</span></span><span lang="EN-US">. (Try adding this file to your project's Build Events as well.) Then, add the file SqlLexer.fs to the project. We can experiment with the lexer now with some sample input:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				open System&nbsp;&nbsp;<br>
				open Sql&nbsp;&nbsp;<br>
				&nbsp;<br>
				let x = "&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; SELECT x, y, z&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; FROM t1&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; LEFT JOIN t2&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; INNER JOIN t3 ON t3.ID = t2.ID&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; WHERE x = 50 AND y = 20&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; ORDER BY x ASC, y DESC, z&nbsp;&nbsp;<br>
				"&nbsp;&nbsp;<br>
				&nbsp;<br>
				let lexbuf = Lexing.from_string x&nbsp;&nbsp;<br>
				while not lexbuf.IsPastEndOfStream do&nbsp;<br>
				&nbsp;&nbsp;&nbsp; printfn "%A" (SqlLexer.tokenize lexbuf)&nbsp;&nbsp;<br>
				&nbsp;<br>
				Console.WriteLine("(press any key)")&nbsp;&nbsp;<br>
				Console.ReadKey(true) |&gt; ignore
			</p>
			<p class="TextBody">
				<span lang="EN-US">This program will print out a list of tokens matched by the string above.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Step 4: Define the parser rules
			</h3>
			<p class="TextBody">
				<span lang="EN-US">A parser converts a stream of tokens into an abstract syntax tree. We can modify our boilerplate parser as follows (will not compile):</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				%{&nbsp;&nbsp;<br>
				open Sql&nbsp;&nbsp;<br>
				%}&nbsp;&nbsp;<br>
				&nbsp;<br>
				%token &lt;string&gt; ID&nbsp;&nbsp;<br>
				%token &lt;int&gt; INT&nbsp;&nbsp;<br>
				%token &lt;float&gt; FLOAT&nbsp;&nbsp;<br>
				&nbsp;<br>
				%token AND OR&nbsp;&nbsp;<br>
				%token COMMA&nbsp;&nbsp;<br>
				%token EQ LT LE GT GE&nbsp;&nbsp;<br>
				%token JOIN INNER LEFT RIGHT ON&nbsp;&nbsp;<br>
				%token SELECT FROM WHERE ORDER BY&nbsp;&nbsp;<br>
				%token ASC DESC&nbsp;&nbsp;<br>
				%token EOF&nbsp;&nbsp;<br>
				&nbsp;<br>
				// start&nbsp;&nbsp;<br>
				%start start&nbsp;&nbsp;<br>
				%type &lt;Sql.sqlStatement&gt; start&nbsp;&nbsp;<br>
				&nbsp;<br>
				%%&nbsp;&nbsp;<br>
				&nbsp;<br>
				start:&nbsp; SELECT columnList&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM ID&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; joinList&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; whereClause&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orderByClause&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ Table = $4;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Columns = $2;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Joins = $5;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Where = $6;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderBy = $7 }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>
				&nbsp;<br>
				value:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Int($1) }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | FLOAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Float($1) }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { String($1) }&nbsp;&nbsp;<br>
				%%
			</p>
			<p class="TextBody">
				<span lang="EN-US">Let's examine the</span> <span class="Teletyped"><span lang="EN-US" style=''>start:</span></span> <span lang="EN-US">function. You can immediately see that we have a list of tokens which gives a rough outline of a select statement. In addition to that, you can see the F# code contained between</span> <span class="Teletyped"><span lang="EN-US" style=''>{</span></span><span lang="EN-US">'s and</span> <span class="Teletyped"><span lang="EN-US" style=''>}</span></span><span lang="EN-US">'s which will be executed when the code successfully matches -- in this case, its returning an instance of the</span> <span class="Teletyped"><span lang="EN-US" style=''>Sql.sqlStatement</span></span> <span lang="EN-US">record.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">The F# code contains "$1", "$2", :$3", etc. which vaguely resembles regex replace syntax. Each "$<em>#</em>" corresponds to the index (starting at 1) of the token in our matching rule. The indexes become obvious when they&rsquo;re annotated as follows:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $1&nbsp;&nbsp;&nbsp;&nbsp; $2&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)<br>
				start:&nbsp; SELECT columnList&nbsp;&nbsp;<br>
				&nbsp;<br>
				(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $3&nbsp;&nbsp; $4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM ID&nbsp;&nbsp;<br>
				&nbsp;<br>
				(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; joinList&nbsp;&nbsp;<br>
				&nbsp;<br>
				(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; whereClause&nbsp;&nbsp;<br>
				&nbsp;<br>
				(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orderByClause&nbsp;&nbsp;<br>
				&nbsp;<br>
				(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Table = $4;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Columns = $2;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Joins = $5;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Where = $6;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderBy = $7 }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
			</p>
			<p class="TextBody">
				<span lang="EN-US">So, the</span> <span class="Teletyped"><span lang="EN-US" style=''>start</span></span> <span lang="EN-US">rule breaks our tokens into a basic shape, which we then use to map to our</span> <span class="Teletyped"><span lang="EN-US" style=''>sqlStatement</span></span> <span lang="EN-US">record. You're probably wondering where the</span> <span class="Teletyped"><span lang="EN-US" style=''>columnList</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style='font-size: 10.0pt'>joinList</span></span><span lang="EN-US">,</span> <span class="Teletyped"><span lang="EN-US" style=''>whereClause</span></span><span lang="EN-US">, and</span> <span class="Teletyped"><span lang="EN-US" style=''>orderByClause</span></span> <span lang="EN-US">come from -- these are not tokens, but are rather additional parse rules which we'll have to define. Let&rsquo;s start with the first rule:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				columnList:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { [$1]}&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ID COMMA columnList&nbsp;&nbsp; { $1 :: $3 }
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>columnList</span></span> <span lang="EN-US">matches text in the style of "</span><span class="Teletyped"><span lang="EN-US" style=''>a, b, c, ... z</span></span><span lang="EN-US">" and returns the results as a list. Notice this rule is defined recursively (also notice the order of rules is not significant). FsYacc's match algorithm is "greedy", meaning it will try to match as many tokens as possible. When FsYacc receives an</span> <span class="Teletyped"><span lang="EN-US" style=''>ID</span></span> <span lang="EN-US">token, it will match the first rule, but it also matches part of the second rule as well. FsYacc then performs a one-token lookahead: it the next token is a</span> <span class="Teletyped"><span lang="EN-US" style=''>COMMA</span></span><span lang="EN-US">, then it will attempt to match additional tokens until the full rule can be satisfied.</span>
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <span class="Bold">Note:</span> The definition of columnList above is not tail recursive, so it may throw a stack overflow exception for exceptionally large inputs. A tail recursive version of this rule can be defined as follows:
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="Blockquote">
				&nbsp;
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				start:&nbsp; ...&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ Table = $4;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Columns = List.rev $2;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Joins = $5;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Where = $6;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderBy = $7 }&nbsp;&nbsp;<br>
				&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>
				&nbsp;<br>
				columnList:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { [$1]}&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | columnList COMMA ID&nbsp; { $3 :: $1 }
			</p>
			<p class="Blockquote">
				&nbsp;
			</p>
			<p class="IndentedSingle" style='text-indent:0cm'>
				&nbsp;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> The tail-recursive version creates the list backwards, so we have to reverse when we return our final output from the parser.
			</p>
			<p class="TextBody">
				<span lang="EN-US">We can treat the JOIN clause in the same way, however its a little more complicated:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				// join clause&nbsp;&nbsp;<br>
				joinList:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { [] } // empty rule, matches 0 tokens&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | joinClause&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { [$1] }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | joinClause joinList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { $1 :: $2 }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;<br>
				joinClause:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | INNER JOIN ID joinOnClause&nbsp;&nbsp;&nbsp; { $3, Inner, $4 }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | LEFT JOIN ID joinOnClause&nbsp;&nbsp;&nbsp;&nbsp; { $3, Left, $4 }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | RIGHT JOIN ID joinOnClause&nbsp;&nbsp;&nbsp; { $3, Right, $4 }&nbsp;&nbsp;<br>
				&nbsp;<br>
				joinOnClause:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ None }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ON conditionList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Some($2) }&nbsp;&nbsp;<br>
				&nbsp;<br>
				conditionList:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | value op value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Cond($1, $2, $3) }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | value op value AND conditionList&nbsp; { And(Cond($1, $2, $3), $5) }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | value op value OR conditionList&nbsp;&nbsp; { Or(Cond($1, $2, $3), $5) }
			</p>
			<p class="TextBody">
				<span class="Teletyped"><span lang="EN-US" style=''>joinList</span></span> <span lang="EN-US">is defined in terms of several functions. This results because there are repeating groups of tokens (such as multiple tables being joined) and optional tokens (the optional "ON" clause). You've already seen that we handle repeating groups of tokens using recursive rules. To handle optional tokens, we simply break the optional syntax into a separate function, and create an empty rule to represent 0 tokens.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">With this strategy in mind, we can write the remaining parser rules:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				%{&nbsp;&nbsp;<br>
				open Sql&nbsp;&nbsp;<br>
				%}&nbsp;&nbsp;<br>
				&nbsp;<br>
				%token &lt;string&gt; ID&nbsp;&nbsp;<br>
				%token &lt;int&gt; INT&nbsp;&nbsp;<br>
				%token &lt;float&gt; FLOAT&nbsp;&nbsp;<br>
				&nbsp;<br>
				%token AND OR&nbsp;&nbsp;<br>
				%token COMMA&nbsp;&nbsp;<br>
				%token EQ LT LE GT GE&nbsp;&nbsp;<br>
				%token JOIN INNER LEFT RIGHT ON&nbsp;&nbsp;<br>
				%token SELECT FROM WHERE ORDER BY&nbsp;&nbsp;<br>
				%token ASC DESC&nbsp;&nbsp;<br>
				%token EOF&nbsp;&nbsp;<br>
				&nbsp;<br>
				// start&nbsp;&nbsp;<br>
				%start start&nbsp;&nbsp;<br>
				%type &lt;Sql.sqlStatement&gt; start&nbsp;&nbsp;<br>
				&nbsp;<br>
				%%&nbsp;&nbsp;<br>
				&nbsp;<br>
				start:&nbsp; SELECT columnList&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM ID&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; joinList&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; whereClause&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orderByClause&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Table = $4;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Columns = List.rev $2;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Joins = $5;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Where = $6;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderBy = $7 }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br>
				columnList:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { [$1]}&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | columnList COMMA ID&nbsp; { $3 :: $1 }&nbsp;&nbsp;<br>
				&nbsp;<br>
				// join clause&nbsp;&nbsp;<br>
				joinList:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { [] }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | joinClause&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ [$1] }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | joinClause joinList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { $1 :: $2 }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;<br>
				joinClause:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | INNER JOIN ID joinOnClause&nbsp;&nbsp;&nbsp; { $3, Inner, $4 }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | LEFT JOIN ID joinOnClause&nbsp;&nbsp;&nbsp;&nbsp; { $3, Left, $4 }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | RIGHT JOIN ID joinOnClause&nbsp;&nbsp;&nbsp; { $3, Right, $4 }&nbsp;&nbsp;<br>
				&nbsp;<br>
				joinOnClause:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { None }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ON conditionList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Some($2) }&nbsp;&nbsp;<br>
				&nbsp;<br>
				conditionList:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | value op value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Cond($1, $2, $3) }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | value op value AND conditionList&nbsp; { And(Cond($1, $2, $3), $5) }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | value op value OR conditionList&nbsp;&nbsp; { Or(Cond($1, $2, $3), $5) }&nbsp;&nbsp;<br>
				&nbsp;<br>
				// where clause&nbsp;&nbsp;<br>
				whereClause:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { None }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | WHERE conditionList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Some($2) }&nbsp;&nbsp;<br>
				&nbsp;<br>
				op: EQ { Eq } | LT { Lt } | LE { Le } | GT { Gt } | GE { Ge }&nbsp;&nbsp;<br>
				&nbsp;<br>
				value:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Int($1) }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | FLOAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Float($1) }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { String($1) }&nbsp;&nbsp;<br>
				&nbsp;<br>
				// order by clause&nbsp;&nbsp;<br>
				&nbsp;<br>
				orderByClause:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ [] }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ORDER BY orderByList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { $3 }&nbsp;&nbsp;<br>
				&nbsp;<br>
				orderByList:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | orderBy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { [$1] }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | orderBy COMMA orderByList&nbsp;&nbsp;&nbsp;&nbsp; { $1 :: $3 }&nbsp;&nbsp;<br>
				&nbsp;<br>
				orderBy:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { $1, Asc }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ID ASC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { $1, Asc }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ID DESC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { $1, Desc}&nbsp;&nbsp;<br>
				&nbsp;<br>
				%%
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Step 5: Piecing Everything Together
			</h3>
			<p class="TextBody">
				<span lang="EN-US">Here is the complete code for our lexer/parser:</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">SqlParser.fsp</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				%{&nbsp;&nbsp;<br>
				open Sql&nbsp;&nbsp;<br>
				%}&nbsp;&nbsp;<br>
				&nbsp;<br>
				%token &lt;string&gt; ID&nbsp;&nbsp;<br>
				%token &lt;int&gt; INT&nbsp;&nbsp;<br>
				%token &lt;float&gt; FLOAT&nbsp;&nbsp;<br>
				&nbsp;<br>
				%token AND OR&nbsp;&nbsp;<br>
				%token COMMA&nbsp;&nbsp;<br>
				%token EQ LT LE GT GE&nbsp;&nbsp;<br>
				%token JOIN INNER LEFT RIGHT ON&nbsp;&nbsp;<br>
				%token SELECT FROM WHERE ORDER BY&nbsp;&nbsp;<br>
				%token ASC DESC&nbsp;&nbsp;<br>
				%token EOF&nbsp;&nbsp;<br>
				&nbsp;<br>
				// start&nbsp;&nbsp;<br>
				%start start&nbsp;&nbsp;<br>
				%type &lt;Sql.sqlStatement&gt; start&nbsp;&nbsp;<br>
				&nbsp;<br>
				%%&nbsp;&nbsp;<br>
				&nbsp;<br>
				start:&nbsp; SELECT columnList&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM ID&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; joinList&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; whereClause&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orderByClause&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Table = $4;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Columns = List.rev $2;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Joins = $5;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Where = $6;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrderBy = $7 }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br>
				columnList:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ID&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ [$1]}&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | columnList COMMA ID&nbsp; { $3 :: $1 }&nbsp;&nbsp;<br>
				&nbsp;<br>
				// join clause&nbsp;&nbsp;<br>
				joinList:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { [] }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | joinClause&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { [$1] }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | joinClause joinList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { $1 :: $2 }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				&nbsp;<br>
				joinClause:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | INNER JOIN ID joinOnClause&nbsp;&nbsp;&nbsp; { $3, Inner, $4 }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | LEFT JOIN ID joinOnClause&nbsp;&nbsp;&nbsp;&nbsp; { $3, Left, $4 }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | RIGHT JOIN ID joinOnClause&nbsp;&nbsp;&nbsp; { $3, Right, $4 }&nbsp;&nbsp;<br>
				&nbsp;<br>
				joinOnClause:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { None }&nbsp;&nbsp;<br>
				&nbsp; &nbsp;&nbsp;| ON conditionList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Some($2) }&nbsp;&nbsp;<br>
				&nbsp;<br>
				conditionList:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | value op value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Cond($1, $2, $3) }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | value op value AND conditionList&nbsp; { And(Cond($1, $2, $3), $5) }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | value op value OR conditionList&nbsp;&nbsp; { Or(Cond($1, $2, $3), $5) }&nbsp;&nbsp;<br>
				&nbsp;<br>
				// where clause&nbsp;&nbsp;<br>
				whereClause:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { None }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | WHERE conditionList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Some($2) }&nbsp;&nbsp;<br>
				&nbsp;<br>
				op: EQ { Eq } | LT { Lt } | LE { Le } | GT { Gt } | GE { Ge }&nbsp;&nbsp;<br>
				&nbsp;<br>
				value:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | INT&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ Int($1) }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | FLOAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Float($1) }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { String($1) }&nbsp;&nbsp;<br>
				&nbsp;<br>
				// order by clause&nbsp;&nbsp;<br>
				&nbsp;<br>
				orderByClause:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { [] }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ORDER BY orderByList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { $3 } &nbsp;&nbsp;<br>
				&nbsp;<br>
				orderByList:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | orderBy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { [$1] }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | orderBy COMMA orderByList&nbsp;&nbsp;&nbsp;&nbsp; { $1 :: $3 }&nbsp;&nbsp;<br>
				&nbsp;<br>
				orderBy:&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { $1, Asc }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ID ASC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { $1, Asc }&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; | ID DESC&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ $1, Desc}&nbsp;&nbsp;<br>
				&nbsp;<br>
				%%
			</p>
			<p class="TextBody">
				<span lang="EN-US">SqlLexer.fsl</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				{&nbsp;&nbsp;<br>
				open System&nbsp;&nbsp;<br>
				open SqlParser&nbsp;&nbsp;<br>
				open Lexing&nbsp;&nbsp;<br>
				&nbsp;<br>
				let keywords =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; [&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SELECT", SELECT;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "FROM", FROM;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "WHERE", WHERE;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ORDER", ORDER;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "BY", BY;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "JOIN", JOIN;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "INNER", INNER;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "LEFT", LEFT;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "RIGHT", RIGHT;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ASC", ASC;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "DESC", DESC;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "AND", AND;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "OR", OR;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ON", ON;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; ] |&gt; Map.of_list&nbsp;&nbsp;<br>
				&nbsp;<br>
				let ops =&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; [&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "=",&nbsp;&nbsp;&nbsp; EQ;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&lt;",&nbsp;&nbsp;&nbsp; LT;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&lt;=",&nbsp;&nbsp; LE;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&gt;",&nbsp;&nbsp;&nbsp; GT;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&gt;=",&nbsp;&nbsp; GE;&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; ] |&gt; Map.of_list&nbsp;&nbsp;<br>
				}&nbsp;&nbsp;<br>
				&nbsp;<br>
				let char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = ['a'-'z' 'A'-'Z']&nbsp;&nbsp;<br>
				let digit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = ['0'-'9']&nbsp;&nbsp;<br>
				let int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = '-'?digit+&nbsp;&nbsp;<br>
				let float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = '-'?digit+ '.' digit+&nbsp;&nbsp;<br>
				let identifier&nbsp; = char(char|digit|['-' '_' '.'])*&nbsp;&nbsp;<br>
				let whitespace&nbsp; = [' ' '\t']&nbsp;&nbsp;<br>
				let newline&nbsp;&nbsp;&nbsp;&nbsp; = "\n\r" | '\n' | '\r'&nbsp;<br>
				let operator&nbsp;&nbsp;&nbsp; = "&gt;" | "&gt;=" | "&lt;" | "&lt;=" | "="&nbsp;<br>
				&nbsp;<br>
				rule tokenize = parse&nbsp;&nbsp;<br>
				| whitespace&nbsp;&nbsp;&nbsp; { tokenize lexbuf }&nbsp;&nbsp;<br>
				| newline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { lexbuf.EndPos &lt;- lexbuf.EndPos.NextLine; tokenize lexbuf; }&nbsp;&nbsp;<br>
				| int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { INT(Int32.Parse(lexeme lexbuf)) }&nbsp;&nbsp;<br>
				| float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { FLOAT(Double.Parse(lexeme lexbuf)) }&nbsp;&nbsp;<br>
				| operator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { ops.[lexeme lexbuf] }&nbsp;&nbsp;<br>
				| identifier&nbsp;&nbsp;&nbsp; { match keywords.TryFind(lexeme lexbuf) with&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Some(token) -&gt; token&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | None -&gt; ID(lexeme lexbuf) }&nbsp;&nbsp;<br>
				| ','&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { COMMA }&nbsp;&nbsp;<br>
				| eof&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { EOF }
			</p>
			<p class="TextBody">
				<span lang="EN-US">Program.fs</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				open System&nbsp;&nbsp;<br>
				open Sql&nbsp;&nbsp;<br>
				&nbsp;<br>
				let x = "&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; SELECT x, y, z&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; FROM t1&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; LEFT JOIN t2&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; INNER JOIN t3 ON t3.ID = t2.ID&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; WHERE x = 50 AND y = 20&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; ORDER BY x ASC, y DESC, z&nbsp;&nbsp;<br>
				"&nbsp;&nbsp;<br>
				&nbsp;<br>
				let lexbuf = Lexing.from_string x&nbsp;&nbsp;<br>
				let y = SqlParser.start SqlLexer.tokenize lexbuf&nbsp;&nbsp;<br>
				printfn "%A" y&nbsp;&nbsp;<br>
				&nbsp;<br>
				Console.WriteLine("(press any key)")&nbsp;&nbsp;<br>
				Console.ReadKey(true) |&gt; ignore
			</p>
			<p class="TextBody">
				<span lang="EN-US">Altogether, our minimal SQL lexer/parser is about 150 lines of code (including non-trivial lines of code and whitespace). I'll leave it as an exercise for the reader to implement the remainder of the SQL language spec.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">2011-03-06: I tried the above instructions with VS2010 and F# 2.0 and PowerPack 2.0. I had to make a few changes:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Add "module SqlLexer" on the 2nd line of SqlLexer.fsl</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Change Map.of_list to Map.ofList</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Add " --module SqlParser" to the command line of fsyacc</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Add FSharp.PowerPack to get Lexing module</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">2011-07-06: (Sjuul Janssen) These where the steps I had to take in order to make this work.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">If you get the message "Expecting a LexBuffer&lt;char&gt; but given a LexBuffer&lt;byte&gt; The type 'char' does not match the type 'byte'"</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Add "fslex.exe "$(ProjectDir)SqlLexer.fsl" --unicode" to the pre-build</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">in program.fs change "let lexbuf = Lexing.from_string x" to "let lexbuf = Lexing.LexBuffer&lt;_&gt;.FromString x"</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">in SqlLexer.fsi change "lexeme lexbuf" to "LexBuffer&lt;_&gt;.LexemeString lexbuf"</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">If you get the message that some module doesn't exist or that some module is declared multiple times. Make sure that in the solution explorer the files come in this order:</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Sql.fs</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">SqlParser.fsp</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">SqlLexer.fsl</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">SqlParser.fsi</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">SqlParser.fs</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">SqlLexer.fs</span>
			</p>
			<p class="TextBody" style='margin-left:0cm;text-indent:0cm'>
				<span lang="EN-US">&bull;<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span> <span lang="EN-US">Program.fs</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">&nbsp;</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">If you get the message "Method not found: 'System.Object Microsoft.FSharp.Text.Parsing.Tables`1.Interpret(Microsoft.FSharp.Core.FSharpFunc`2&lt;Microsoft.FSharp.Text.Lexing.LexBuffer`1&lt;Byte&gt;,!0&gt;, ..." Go to <a href="http://www.microsoft.com/download/en/details.aspx?id=15834"><span style='color:windowtext;text-decoration:none'>http://www.microsoft.com/download/en/details.aspx?id=15834</span></a> and reinstall Visual Studio 2010 F# 2.0 Runtime SP1 (choose for <span class="Bold">repair</span>)</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">2011-07-06: (mkduffi) Could someone please provide a sample project. I have followed all of your changes but still can not build. Thanks.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
			<h3 class="Heading2">
				Sample
			</h3>
			<p class="TextBody">
				<span lang="EN-US"><a href="https://github.com/obeleh/FsYacc-Example"><span style='color:windowtext; text-decoration:none'>https://github.com/obeleh/FsYacc-Example</span></a></span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">2011-07-07 (mkduffi) Thanks for posting the sample. Here is what I did to the Program.fs file:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				namespace FS<br>
				module Parser =<br>
				<br>
				open System&nbsp;&nbsp;<br>
				open Sql&nbsp;&nbsp;<br>
				&nbsp;<br>
				let x = "&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; SELECT x, y, z&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; FROM t1&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; LEFT JOIN t2&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; INNER JOIN t3 ON t3.ID = t2.ID&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; WHERE x = 50 AND y = 20&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; ORDER BY x ASC, y DESC, z&nbsp;&nbsp;<br>
				"&nbsp;&nbsp;<br>
				let ParseSql x =<br>
				&nbsp;&nbsp;&nbsp; let lexbuf = Lexing.LexBuffer&lt;_&gt;.FromString x<br>
				&nbsp;&nbsp;&nbsp; let y = SqlParser.start SqlLexer.tokenize lexbuf&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp; y<br>
				<br>
				let y = (ParseSql x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
				printfn "%A" y<br>
				&nbsp;<br>
				Console.WriteLine("(press any key)")&nbsp;&nbsp;<br>
				Console.ReadKey(true) |&gt; ignore
			</p>
			<p class="TextBody">
				<span lang="EN-US">I added a C# console project for testing and this is what is in the Program.cs file:</span>
			</p>
			<p class="Preformatted" style="font-size:smaller;font-family:'Courier New'">
				using System;<br>
				using System.Collections.Generic;<br>
				using System.Linq;<br>
				using System.Text;<br>
				<br>
				namespace ConsoleApplication1<br>
				{<br>
				&nbsp;&nbsp;&nbsp; class Program<br>
				&nbsp;&nbsp;&nbsp; {<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args)<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string query =<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @"SELECT x, y, z&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM t1&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LEFT JOIN t2&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INNER JOIN t3 ON t3.ID = t2.ID&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE x = 50 AND y = 20&nbsp;&nbsp;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ORDER BY x ASC, y DESC, z";<br>
				<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sql.sqlStatement stmnt = FS.Parser.ParseSql(query);<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
				&nbsp;&nbsp;&nbsp; };<br>
				}
			</p>
			<p class="TextBody">
				<span lang="EN-US">I had to add the YaccSample project reference as well as a reference to the FSharp.Core assembly to get this to work.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">If anyone could help me figure out how to support table aliases that would be awesome.</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">Thanks</span>
			</p>
			<p class="TextBody">
				<span lang="EN-US">2011-07-08 (Sjuul Janssen) Contact me through my github account. I'm working on this and some other stuff.</span>
			</p>
			<p class="MsoNormal">
				&nbsp;
			</p>
		</div>
	</body>
</html>

